Specifier: work/src/index.ts
Kind: JavaScript
---
console.debug = ()=>{} // stop debug logging for main app
;
// @deno-types="npm:@types/express"
import express from 'npm:express';
// @deno-types="npm:@types/body-parser"
import bodyParser from 'npm:body-parser';
import { connectToDatabase, closeDatabaseConnection, aggregateLocationEvents } from './mongodb.ts';
import { logger } from './logger.ts';
import { registerRoutes } from './routes.ts';
const app = express();
const port = Deno.env.get('PORT') || 3000;
const maintenanceInterval = parseInt(Deno.env.get('MAINTENANCE_INTERVAL') || '300000', 10); // default to 5 minutes
const uri = Deno.env.get('MONGODB_URI') || 'mongodb://localhost:27017';
const db = Deno.env.get('MONGODB_DB') || 'test';
app.use(bodyParser.json());
app.use(bodyParser.raw({
  type: 'application/msgpack'
}));
registerRoutes(app);
let server;
connectToDatabase(uri, db).then(()=>{
  server = app.listen(port, ()=>{
    logger.info(`Server is running on port ${port}`);
  });
  setInterval(async ()=>{
    try {
      await aggregateLocationEvents();
      logger.info('Maintenance task completed');
    } catch (err) {
      logger.error('Failed to run maintenance task', err);
    }
  }, maintenanceInterval);
}).catch(async (err)=>{
  logger.error('Failed to connect to the database', err);
  await closeDatabaseConnection();
  Deno.exit(1);
});
const gracefulShutdown = async ()=>{
  logger.info('Received shutdown signal, closing server...');
  if (server) {
    server.close(async (err)=>{
      if (err) {
        logger.error('Error closing server:', err);
        Deno.exit(1);
      }
      logger.info('Server closed');
      await closeDatabaseConnection();
      Deno.exit(0);
    });
  } else {
    await closeDatabaseConnection();
    Deno.exit(0);
  }
};
const handleSignal = async ()=>{
  logger.debug("handling signal, calling gracefulShutdown!");
  await gracefulShutdown();
  Deno.exit(0);
};
Deno.addSignalListener("SIGTERM", handleSignal);
Deno.addSignalListener("SIGINT", handleSignal);

---
{"version":3,"sources":["file:///work/src/index.ts"],"sourcesContent":["console.debug = () => {} // stop debug logging for main app\n\nimport http from 'node:http';\n// @deno-types=\"npm:@types/express\"\nimport express from 'npm:express';\n// @deno-types=\"npm:@types/body-parser\"\nimport bodyParser from 'npm:body-parser';\n\nimport { connectToDatabase, closeDatabaseConnection, aggregateLocationEvents } from './mongodb.ts';\nimport { logger } from './logger.ts';\nimport { registerRoutes } from './routes.ts';\n\nconst app = express();\nconst port = Deno.env.get('PORT') || 3000;\nconst maintenanceInterval = parseInt(Deno.env.get('MAINTENANCE_INTERVAL') || '300000', 10); // default to 5 minutes\nconst uri = Deno.env.get('MONGODB_URI') || 'mongodb://localhost:27017';\nconst db = Deno.env.get('MONGODB_DB') || 'test';\n\napp.use(bodyParser.json());\napp.use(bodyParser.raw({ type: 'application/msgpack' }));\n\nregisterRoutes(app);\n\nlet server: http.Server;\n\nconnectToDatabase(uri, db).then(() => {\n  server = app.listen(port, () => {\n    logger.info(`Server is running on port ${port}`);\n  });\n  setInterval(async () => {\n    try {\n      await aggregateLocationEvents();\n      logger.info('Maintenance task completed');\n    } catch (err) {\n      logger.error('Failed to run maintenance task', err);\n    }\n  }, maintenanceInterval);\n}).catch(async (err) => {\n  logger.error('Failed to connect to the database', err);\n  await closeDatabaseConnection();\n  Deno.exit(1);\n});\n\nconst gracefulShutdown = async () => {\n  logger.info('Received shutdown signal, closing server...');\n  if (server) {\n    server.close(async (err) => {\n      if (err) {\n        logger.error('Error closing server:', err);\n        Deno.exit(1);\n      }\n      logger.info('Server closed');\n      await closeDatabaseConnection();\n      Deno.exit(0);\n    });\n  } else {\n    await closeDatabaseConnection();\n    Deno.exit(0);\n  }\n};\n\nconst handleSignal = async () => {\n  logger.debug(\"handling signal, calling gracefulShutdown!\")\n  await gracefulShutdown();\n  Deno.exit(0);\n};\n\nDeno.addSignalListener(\"SIGTERM\", handleSignal);\nDeno.addSignalListener(\"SIGINT\", handleSignal);\n"],"names":[],"mappings":"AAAA,QAAQ,KAAK,GAAG,KAAO,EAAE,kCAAkC;;AAG3D,mCAAmC;AACnC,OAAO,aAAa,cAAc;AAClC,uCAAuC;AACvC,OAAO,gBAAgB,kBAAkB;AAEzC,SAAS,iBAAiB,EAAE,uBAAuB,EAAE,uBAAuB,QAAQ,eAAe;AACnG,SAAS,MAAM,QAAQ,cAAc;AACrC,SAAS,cAAc,QAAQ,cAAc;AAE7C,MAAM,MAAM;AACZ,MAAM,OAAO,KAAK,GAAG,CAAC,GAAG,CAAC,WAAW;AACrC,MAAM,sBAAsB,SAAS,KAAK,GAAG,CAAC,GAAG,CAAC,2BAA2B,UAAU,KAAK,uBAAuB;AACnH,MAAM,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,kBAAkB;AAC3C,MAAM,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,iBAAiB;AAEzC,IAAI,GAAG,CAAC,WAAW,IAAI;AACvB,IAAI,GAAG,CAAC,WAAW,GAAG,CAAC;EAAE,MAAM;AAAsB;AAErD,eAAe;AAEf,IAAI;AAEJ,kBAAkB,KAAK,IAAI,IAAI,CAAC;EAC9B,SAAS,IAAI,MAAM,CAAC,MAAM;IACxB,OAAO,IAAI,CAAC,CAAC,0BAA0B,EAAE,KAAK,CAAC;EACjD;EACA,YAAY;IACV,IAAI;MACF,MAAM;MACN,OAAO,IAAI,CAAC;IACd,EAAE,OAAO,KAAK;MACZ,OAAO,KAAK,CAAC,kCAAkC;IACjD;EACF,GAAG;AACL,GAAG,KAAK,CAAC,OAAO;EACd,OAAO,KAAK,CAAC,qCAAqC;EAClD,MAAM;EACN,KAAK,IAAI,CAAC;AACZ;AAEA,MAAM,mBAAmB;EACvB,OAAO,IAAI,CAAC;EACZ,IAAI,QAAQ;IACV,OAAO,KAAK,CAAC,OAAO;MAClB,IAAI,KAAK;QACP,OAAO,KAAK,CAAC,yBAAyB;QACtC,KAAK,IAAI,CAAC;MACZ;MACA,OAAO,IAAI,CAAC;MACZ,MAAM;MACN,KAAK,IAAI,CAAC;IACZ;EACF,OAAO;IACL,MAAM;IACN,KAAK,IAAI,CAAC;EACZ;AACF;AAEA,MAAM,eAAe;EACnB,OAAO,KAAK,CAAC;EACb,MAAM;EACN,KAAK,IAAI,CAAC;AACZ;AAEA,KAAK,iBAAiB,CAAC,WAAW;AAClC,KAAK,iBAAiB,CAAC,UAAU"}
============
Specifier: work/src/mongodb.ts
Kind: JavaScript
---
import { MongoClient, ObjectId, MongoInvalidArgumentError } from "npm:mongodb";
import { logger } from './logger.ts';
const CLOCK_THRESH = +(Deno.env.get('CLOCK_THRESH') || 60000);
let client;
let db;
let dbName;
let locationEvents;
let locationHistory;
export async function connectToDatabase(uri, dbName_) {
  client = new MongoClient(uri);
  try {
    await client.connect();
    logger.info('Connected to MongoDB');
  } catch (err) {
    logger.error('Failed to connect to MongoDB', err);
    throw err;
  }
  db = client.db(dbName_);
  dbName = dbName_;
  await createCollections();
}
async function createCollections() {
  // existance check not needed for mongodb 7.0
  //if ((await db.listCollections({ name: "location_events" }).toArray()).length == 0) { // only create if it does not exist
  await db.createCollection("location_events", {
    capped: true,
    max: 10000,
    size: 10000 * 128
  });
  //}
  locationEvents = db.collection("location_events");
  await locationEvents.createIndex({
    vid: 1,
    timestamp: 1
  }, {
    unique: true
  }) // avoid duplicates and make aggregate faster
  ;
  locationHistory = db.collection("location_history");
}
export async function closeDatabaseConnection() {
  if (client) {
    await client.close();
    logger.info('Disconnected from MongoDB');
  }
}
// only for testing
export async function clearDatabase() {
  await locationEvents.drop();
  await locationHistory.drop();
  logger.debug("Dropped collections in db '" + dbName + "'");
  // now recreate collections (since drop destroys indexes etc)
  await createCollections();
}
// only for testing
export async function getLocationEvents(filter) {
  return await locationEvents.find(filter).toArray();
}
// only for testing
export async function getLocationHistory(filter) {
  return await locationHistory.find(filter).toArray();
}
export async function insertLocationEvent(event, force = false) {
  if (!force) {
    const currentTime = new Date();
    if (Math.abs(currentTime.getTime() - event.timestamp) > CLOCK_THRESH) {
      throw new Error("Event timestamp is not within range of the current time");
    }
  }
  let doc = {
    _id: new ObjectId(),
    ...event
  }; // force new id to avoid duplicate key error on fast insertions
  await locationEvents.insertOne(doc);
}
function paginate(h, max_count, prev_count) {
  // split the single "h" LocationHistory into an array of LocationHistory values
  // each should have a maximum "count" value (ie. number of timestamps and number of coordinates) of max_count paramater
  // but the first LocationHistory should have (max_count-prev_count) as it's maximum "count"
  if (h.count <= max_count - prev_count) return [
    h
  ]; // optimize typical case
  // here at least 1 split is needed
  const paginatedHistories = [];
  let used = 0;
  let available = max_count - prev_count;
  while(used < h.count){
    let currentHistory = {
      vid: h.vid,
      count: available,
      starttime: h.timestamps[used],
      endtime: h.timestamps[used + available - 1],
      timestamps: h.timestamps.slice(used, used + available),
      lineString: {
        type: "LineString",
        coordinates: h.lineString.coordinates.slice(used, used + available)
      }
    };
    paginatedHistories.push(currentHistory);
    used += available;
    available = Math.min(max_count, h.count - used);
  }
  return paginatedHistories;
}
export async function aggregateLocationEvents() {
  const pipeline = [
    {
      $sort: {
        vid: 1,
        timestamp: 1
      } // so groups have entries ordered by time (optimized with index)
    },
    {
      $group: {
        _id: "$vid",
        last_id: {
          $max: "$_id"
        },
        starttime: {
          $min: "$timestamp"
        },
        endtime: {
          $max: "$timestamp"
        },
        timestamps: {
          $push: "$timestamp"
        },
        coords: {
          $push: "$point.coordinates"
        }
      }
    },
    {
      $project: {
        location_history: {
          _id: "$last_id",
          vid: "$_id",
          count: {
            $size: "$timestamps"
          },
          starttime: "$starttime",
          endtime: "$endtime",
          timestamps: "$timestamps",
          lineString: {
            type: "LineString",
            coordinates: "$coords"
          }
        }
      }
    }
  ];
  const aggregatedResults = await locationEvents.aggregate(pipeline).toArray();
  if (aggregatedResults.length == 0) return;
  const MAX_COUNT = 100; // max events in a single LocationHistory to avoid Mongo errors
  var bulk = locationHistory.initializeUnorderedBulkOp();
  var last_id = new ObjectId(0);
  for (var result of aggregatedResults){
    let h = result.location_history;
    if (h._id > last_id) last_id = h._id; // keep the last id across all groups
    let last_history_selector = {
      vid: h.vid
    };
    let last_history = (await locationHistory.find(last_history_selector).sort({
      endtime: -1
    }).limit(1).toArray()).shift();
    if (last_history == null) {
      let histories = paginate(h, MAX_COUNT, 0);
      for (var newh of histories){
        await bulk.insert(newh);
      }
    } else {
      last_history_selector.endtime = last_history.endtime; // now we can select the correct history to extend
      if (h.starttime >= last_history.endtime) {
        let histories = paginate(h, MAX_COUNT, last_history.count);
        let extra = histories.shift();
        // update last history up to the MAX_COUNT locations
        last_history.count += extra.count;
        last_history.endtime = extra.endtime;
        last_history.timestamps.push(...extra.timestamps);
        last_history.lineString.coordinates.push(...extra.lineString.coordinates);
        await bulk.find(last_history_selector).update({
          $set: {
            count: last_history.count,
            endtime: last_history.endtime,
            timestamps: last_history.timestamps,
            lineString: last_history.lineString
          }
        });
        // add complete additional history entries over MAX_COUNT
        for (var newh of histories){
          await bulk.insert(h);
        }
      } else {
      // just drop it since we already have a newer location, maybe implement later
      //throw new Error("todo");
      }
    }
  }
  try {
    await bulk.execute();
  } catch (e) {
    if (e instanceof MongoInvalidArgumentError) {
      // MongoInvalidArgumentError: Invalid BulkOperation, Batch cannot be empty
      logger.debug("handled exception in aggregateLocationEvents", e);
    } else {
      logger.error("unhandled exception in aggregateLocationEvents", e);
    }
  }
  // clear the locationEvents collection after aggregation up to and including the last_id
  await locationEvents.deleteMany({
    _id: {
      $lte: last_id
    }
  });
}

---
{"version":3,"sources":["file:///work/src/mongodb.ts"],"sourcesContent":["import {\n  MongoClient,\n  Db,\n  Collection,\n  CollectionOptions,\n  Filter,\n  WithId,\n  ObjectId,\n  MongoInvalidArgumentError\n} from \"npm:mongodb\";\nimport { logger } from './logger.ts';\n\nconst CLOCK_THRESH = +(Deno.env.get('CLOCK_THRESH') || 60000);\n\nexport interface LocationEvent {\n    vid: string;\n    timestamp: number;\n    point: { // GeoJSON Point\n        type: \"Point\";\n        coordinates: [number, number];\n    };\n}\n\nexport interface LocationHistory {\n    vid: string;\n    count: number;\n    starttime: number;\n    endtime: number;\n    timestamps: Array<number>;\n    lineString: { // GeoJSON LineString\n        type: \"LineString\";\n        coordinates: Array<[number, number]>;\n    };\n}\n\nlet client: MongoClient;\nlet db: Db;\nlet dbName: string;\nlet locationEvents: Collection<LocationEvent>;\nlet locationHistory: Collection<LocationHistory>;\n\nexport async function connectToDatabase(uri: string, dbName_: string): Promise<void> {\n    client = new MongoClient(uri);\n    try {\n      await client.connect();\n      logger.info('Connected to MongoDB');\n    } catch (err) {\n      logger.error('Failed to connect to MongoDB', err);\n      throw err;\n    }\n    db = client.db(dbName_);\n    dbName = dbName_\n    await createCollections()\n}\n\nasync function createCollections() {\n    // existance check not needed for mongodb 7.0\n    //if ((await db.listCollections({ name: \"location_events\" }).toArray()).length == 0) { // only create if it does not exist\n    await db.createCollection(\"location_events\", { capped: true, max: 10000, size: 10000*128 } );\n    //}\n    locationEvents = db.collection<LocationEvent>(\"location_events\");\n    await locationEvents.createIndex({ vid: 1, timestamp: 1 }, { unique: true }) // avoid duplicates and make aggregate faster\n    locationHistory = db.collection<LocationHistory>(\"location_history\");\n}\n\nexport async function closeDatabaseConnection(): Promise<void> {\n    if (client) {\n        await client.close();\n        logger.info('Disconnected from MongoDB');\n    }\n}\n\n// only for testing\nexport async function clearDatabase(): Promise<void> {\n    await locationEvents.drop()\n    await locationHistory.drop()\n    logger.debug(\"Dropped collections in db '\" + dbName + \"'\");\n    // now recreate collections (since drop destroys indexes etc)\n    await createCollections()\n}\n\n// only for testing\nexport async function getLocationEvents(filter: any) {\n    return await locationEvents.find(filter).toArray();\n}\n\n// only for testing\nexport async function getLocationHistory(filter: any) {\n    return await locationHistory.find(filter).toArray();\n}\n\nexport async function insertLocationEvent(event: LocationEvent, force: boolean = false) {\n\n    if (!force) { // force bypass for testing\n        const currentTime = new Date();\n\n        if (Math.abs(currentTime.getTime() - event.timestamp) > CLOCK_THRESH) {\n            throw new Error(\"Event timestamp is not within range of the current time\");\n        }\n    }\n\n    let doc = { _id: new ObjectId(), ...event }; // force new id to avoid duplicate key error on fast insertions\n    await locationEvents.insertOne(doc)\n}\n\nfunction paginate(h: LocationHistory, max_count: number, prev_count: number): Array<LocationHistory>\n{\n    // split the single \"h\" LocationHistory into an array of LocationHistory values\n    // each should have a maximum \"count\" value (ie. number of timestamps and number of coordinates) of max_count paramater\n    // but the first LocationHistory should have (max_count-prev_count) as it's maximum \"count\"\n\n    if ( h.count <= (max_count - prev_count) ) return [h]; // optimize typical case\n\n    // here at least 1 split is needed\n    const paginatedHistories: Array<LocationHistory> = [];\n    let used = 0;\n    let available = max_count - prev_count;\n\n    while (used < h.count) {\n      let currentHistory: LocationHistory = {\n          vid: h.vid,\n          count: available,\n          starttime: h.timestamps[used],\n          endtime: h.timestamps[used + available - 1],\n          timestamps: h.timestamps.slice(used, used + available),\n          lineString: {\n              type: \"LineString\",\n              coordinates: h.lineString.coordinates.slice(used, used + available)\n          }\n      };\n      paginatedHistories.push(currentHistory);\n      used += available;\n      available = Math.min(max_count, h.count - used);\n    }\n\n    return paginatedHistories;\n}\n\nexport async function aggregateLocationEvents() {\n    const pipeline: any[] = [\n        {\n            $sort: { vid: 1, timestamp: 1 } // so groups have entries ordered by time (optimized with index)\n        },\n        {\n            $group: {\n                _id: \"$vid\", // group on vid (orderd by timestamp above)\n                last_id: { $max: \"$_id\" }, // track latest entered event to avoid race condition and delete only the aggregated events\n                starttime: { $min: \"$timestamp\" },\n                endtime: { $max: \"$timestamp\" },\n                timestamps: { $push: \"$timestamp\" },\n                coords: { $push: \"$point.coordinates\" }\n            }\n        },\n        {\n            $project: {\n                location_history: {\n                  _id: \"$last_id\",\n                  vid: \"$_id\",\n                  count: { $size: \"$timestamps\" },\n                  starttime: \"$starttime\",\n                  endtime: \"$endtime\",\n                  timestamps: \"$timestamps\",\n                  lineString: {\n                      type: \"LineString\",\n                      coordinates: \"$coords\"\n                  }\n                }\n            }\n        }\n    ];\n\n    interface LocationResult {\n        location_history: WithId<LocationHistory>;\n    }\n\n    const aggregatedResults: Array<LocationResult> = await locationEvents.aggregate(pipeline).toArray() as Array<LocationResult>;\n\n    if (aggregatedResults.length == 0) return;\n\n    const MAX_COUNT = 100; // max events in a single LocationHistory to avoid Mongo errors\n\n    var bulk = locationHistory.initializeUnorderedBulkOp();\n    var last_id = new ObjectId(0);\n\n    for (var result of aggregatedResults) {\n        let h = result.location_history;\n        if (h._id > last_id) last_id = h._id; // keep the last id across all groups\n\n        let last_history_selector: Filter<LocationHistory>  = { vid: h.vid };\n        let last_history = (await locationHistory.find(last_history_selector).sort({ endtime: -1 }).limit(1).toArray()).shift();\n\n        if (last_history == null) { // must be a new vid\n            let histories = paginate(h, MAX_COUNT, 0);\n            for (var newh of histories) {\n                await bulk.insert(newh);\n            }\n        } else { // existing vid\n            last_history_selector.endtime = last_history.endtime; // now we can select the correct history to extend\n\n            if ( h.starttime >= last_history.endtime ) { // typical case\n                let histories = paginate(h, MAX_COUNT, last_history.count);\n                let extra = histories.shift()!;\n\n                // update last history up to the MAX_COUNT locations\n                last_history.count += extra.count;\n                last_history.endtime = extra.endtime;\n                last_history.timestamps.push(...extra.timestamps);\n                last_history.lineString.coordinates.push(...extra.lineString.coordinates);\n\n                await bulk.find(last_history_selector).update({ $set: {\n                    count: last_history.count,\n                    endtime: last_history.endtime,\n                    timestamps: last_history.timestamps,\n                    lineString: last_history.lineString\n                }});\n\n                // add complete additional history entries over MAX_COUNT\n                for (var newh of histories) {\n                    await bulk.insert(h);\n                }\n\n            } else { // unlikely but maybe possible out of order case:  h.starttime < last_history.endtime\n              // just drop it since we already have a newer location, maybe implement later\n              //throw new Error(\"todo\");\n            }\n        }\n    }\n\n    try { \n        await bulk.execute();\n    } catch (e) { // catch for the empty batch edge case\n        if (e instanceof MongoInvalidArgumentError) {\n            // MongoInvalidArgumentError: Invalid BulkOperation, Batch cannot be empty\n            logger.debug(\"handled exception in aggregateLocationEvents\", e);\n        } else {\n            logger.error(\"unhandled exception in aggregateLocationEvents\", e);\n        }\n    }\n\n    // clear the locationEvents collection after aggregation up to and including the last_id\n    await locationEvents.deleteMany({ _id: { $lte: last_id } });\n}\n\n"],"names":[],"mappings":"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"}
============
Specifier: work/src/logger.ts
Kind: JavaScript
---
import * as log from "https://deno.land/std/log/mod.ts";
await log.setup({
  handlers: {
    console: new log.ConsoleHandler("DEBUG", {
      //            formatter: "{datetime} {levelName} {msg}"
      formatter: (rec)=>JSON.stringify({
          t: rec.datetime,
          l: rec.levelName,
          m: rec.msg
        })
    })
  },
  loggers: {
    default: {
      level: "INFO",
      handlers: [
        "console"
      ]
    }
  }
});
export const logger = log;

---
{"version":3,"sources":["file:///work/src/logger.ts"],"sourcesContent":["import * as log from \"https://deno.land/std/log/mod.ts\";\n\nawait log.setup({\n    handlers: {\n        console: new log.ConsoleHandler(\"DEBUG\", {\n//            formatter: \"{datetime} {levelName} {msg}\"\n            formatter: rec => JSON.stringify({t: rec.datetime, l: rec.levelName, m: rec.msg})\n    }),\n  },\n  loggers: {\n      default: {\n          level: \"INFO\",\n          handlers: [\"console\"],\n    },\n  },\n});\n\nexport const logger = log;\n"],"names":[],"mappings":"AAAA,YAAY,SAAS,mCAAmC;AAExD,MAAM,IAAI,KAAK,CAAC;EACZ,UAAU;IACN,SAAS,IAAI,IAAI,cAAc,CAAC,SAAS;MACjD,uDAAuD;MAC3C,WAAW,CAAA,MAAO,KAAK,SAAS,CAAC;UAAC,GAAG,IAAI,QAAQ;UAAE,GAAG,IAAI,SAAS;UAAE,GAAG,IAAI,GAAG;QAAA;IACvF;EACF;EACA,SAAS;IACL,SAAS;MACL,OAAO;MACP,UAAU;QAAC;OAAU;IAC3B;EACF;AACF;AAEA,OAAO,MAAM,SAAS,IAAI"}
============
Specifier: https://deno.land/std@0.224.0/log/mod.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
/**
 * Logging library with the support for terminal and file outputs. Also provides
 * interfaces for building custom loggers.
 *
 * ## Loggers
 *
 * Loggers are objects that you interact with. When you use a logger method it
 * constructs a `LogRecord` and passes it down to its handlers for output. To
 * create custom loggers, specify them in `loggers` when calling `log.setup`.
 *
 * ## Custom message format
 *
 * If you want to override default format of message you can define `formatter`
 * option for handler. It can a function that takes `LogRecord`
 * as argument and outputs string.
 *
 * The default log format is `{levelName} {msg}`.
 *
 * ### Logging Structured JSON Lines
 *
 * To output logs in a structured JSON format you can configure most handlers
 * with a formatter that produces a JSON string. Either use the premade
 * `log.formatters.jsonFormatter` or write your own function that takes a
 * {@linkcode LogRecord} and returns a JSON.stringify'd object.
 * If you want the log to go to stdout then use {@linkcode ConsoleHandler} with
 * the configuration `useColors: false` to turn off the ANSI terminal colours.
 *
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * log.setup({
 *   handlers: {
 *     default: new log.ConsoleHandler("DEBUG", {
 *       formatter: log.formatters.jsonFormatter,
 *       useColors: false,
 *     }),
 *   },
 * });
 * ```
 *
 * The first argument passed to a log function is always treated as the
 * message and will be stringified differently. To have arguments JSON.stringify'd
 * you must pass them after the first.
 *
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * log.info("This is the message", { thisWillBe: "JSON.stringify'd"});
 * // {"level":"INFO","datetime":1702501580505,"message":"This is the message","args":{"thisWillBe":"JSON.stringify'd"}}
 *
 * log.info({ thisWontBe: "JSON.stringify'd"}, "This is an argument");
 * // {"level":"INFO","datetime":1702501580505,"message":"{\"thisWontBe\":\"JSON.stringify'd\"}","args":"This is an argument"}
 * ```
 *
 * ## Inline Logging
 *
 * Log functions return the data passed in the `msg` parameter. Data is returned
 * regardless if the logger actually logs it.
 *
 * ## Lazy Log Evaluation
 *
 * Some log statements are expensive to compute. In these cases, you can use
 * lazy log evaluation to prevent the computation taking place if the logger
 * won't log the message.
 *
 * > NOTE: When using lazy log evaluation, `undefined` will be returned if the
 * > resolver function is not called because the logger won't log it. It is an
 * > antipattern use lazy evaluation with inline logging because the return value
 * > depends on the current log level.
 *
 * ## For module authors
 *
 * The authors of public modules can let the users display the internal logs of the
 * module by using a custom logger:
 *
 * ```ts
 * import { getLogger } from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * function logger() {
 *   return getLogger("my-awesome-module");
 * }
 *
 * export function sum(a: number, b: number) {
 *   logger().debug(`running ${a} + ${b}`);
 *   return a + b;
 * }
 *
 * export function mult(a: number, b: number) {
 *   logger().debug(`running ${a} * ${b}`);
 *   return a * b;
 * }
 * ```
 *
 * The user of the module can then display the internal logs with:
 *
 * ```ts, ignore
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 * import { sum } from "<the-awesome-module>/mod.ts";
 *
 * log.setup({
 *   handlers: {
 *     console: new log.ConsoleHandler("DEBUG"),
 *   },
 *
 *   loggers: {
 *     "my-awesome-module": {
 *       level: "DEBUG",
 *       handlers: ["console"],
 *     },
 *   },
 * });
 *
 * sum(1, 2); // prints "running 1 + 2" to the console
 * ```
 *
 * Please note that, due to the order of initialization of the loggers, the
 * following won't work:
 *
 * ```ts
 * import { getLogger } from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * const logger = getLogger("my-awesome-module");
 *
 * export function sum(a: number, b: number) {
 *   logger.debug(`running ${a} + ${b}`); // no message will be logged, because getLogger() was called before log.setup()
 *   return a + b;
 * }
 * ```
 *
 * @example
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * // Simple default logger out of the box. You can customize it
 * // by overriding logger and handler named "default", or providing
 * // additional logger configurations. You can log any data type.
 * log.debug("Hello world");
 * log.info(123456);
 * log.warn(true);
 * log.error({ foo: "bar", fizz: "bazz" });
 * log.critical("500 Internal server error");
 *
 * // custom configuration with 2 loggers (the default and `tasks` loggers).
 * log.setup({
 *   handlers: {
 *     console: new log.ConsoleHandler("DEBUG"),
 *
 *     file: new log.FileHandler("WARN", {
 *       filename: "./log.txt",
 *       // you can change format of output message using any keys in `LogRecord`.
 *       formatter: (record) => `${record.levelName} ${record.msg}`,
 *     }),
 *   },
 *
 *   loggers: {
 *     // configure default logger available via short-hand methods above.
 *     default: {
 *       level: "DEBUG",
 *       handlers: ["console", "file"],
 *     },
 *
 *     tasks: {
 *       level: "ERROR",
 *       handlers: ["console"],
 *     },
 *   },
 * });
 *
 * let logger;
 *
 * // get default logger.
 * logger = log.getLogger();
 * logger.debug("fizz"); // logs to `console`, because `file` handler requires "WARN" level.
 * logger.warn(41256); // logs to both `console` and `file` handlers.
 *
 * // get custom logger
 * logger = log.getLogger("tasks");
 * logger.debug("fizz"); // won't get output because this logger has "ERROR" level.
 * logger.error({ productType: "book", value: "126.11" }); // log to `console`.
 *
 * // if you try to use a logger that hasn't been configured
 * // you're good to go, it gets created automatically with level set to 0
 * // so no message is logged.
 * const unknownLogger = log.getLogger("mystery");
 * unknownLogger.info("foobar"); // no-op
 * ```
 *
 * @example
 * Custom message format example
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * log.setup({
 *   handlers: {
 *     stringFmt: new log.ConsoleHandler("DEBUG", {
 *       formatter: (record) => `[${record.levelName}] ${record.msg}`,
 *     }),
 *
 *     functionFmt: new log.ConsoleHandler("DEBUG", {
 *       formatter: (logRecord) => {
 *         let msg = `${logRecord.level} ${logRecord.msg}`;
 *
 *         logRecord.args.forEach((arg, index) => {
 *           msg += `, arg${index}: ${arg}`;
 *         });
 *
 *         return msg;
 *       },
 *     }),
 *
 *     anotherFmt: new log.ConsoleHandler("DEBUG", {
 *       formatter: (record) => `[${record.loggerName}] - ${record.levelName} ${record.msg}`,
 *     }),
 *   },
 *
 *   loggers: {
 *     default: {
 *       level: "DEBUG",
 *       handlers: ["stringFmt", "functionFmt"],
 *     },
 *     dataLogger: {
 *       level: "INFO",
 *       handlers: ["anotherFmt"],
 *     },
 *   },
 * });
 *
 * // calling:
 * log.debug("Hello, world!", 1, "two", [3, 4, 5]);
 * // results in: [DEBUG] Hello, world!
 * // output from "stringFmt" handler.
 * // 10 Hello, world!, arg0: 1, arg1: two, arg3: [3, 4, 5] // output from "functionFmt" formatter.
 *
 * // calling:
 * log.getLogger("dataLogger").error("oh no!");
 * // results in:
 * // [dataLogger] - ERROR oh no! // output from anotherFmt handler.
 * ```

 *
 * @example
 * JSON to stdout with no color example
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * log.setup({
 *   handlers: {
 *     jsonStdout: new log.ConsoleHandler("DEBUG", {
 *       formatter: log.formatters.jsonFormatter,
 *       useColors: false,
 *     }),
 *   },
 *
 *   loggers: {
 *     default: {
 *       level: "DEBUG",
 *       handlers: ["jsonStdout"],
 *     },
 *   },
 * });
 *
 * // calling:
 * log.info("Hey");
 * // results in:
 * // {"level":"INFO","datetime":1702481922294,"message":"Hey"}
 *
 * // calling:
 * log.info("Hey", { product: "nail" });
 * // results in:
 * // {"level":"INFO","datetime":1702484111115,"message":"Hey","args":{"product":"nail"}}
 *
 * // calling:
 * log.info("Hey", 1, "two", [3, 4, 5]);
 * // results in:
 * // {"level":"INFO","datetime":1702481922294,"message":"Hey","args":[1,"two",[3,4,5]]}
 * ```
 *
 * @example
 * Custom JSON example
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * log.setup({
 *   handlers: {
 *     customJsonFmt: new log.ConsoleHandler("DEBUG", {
 *       formatter: (record) => JSON.stringify({
 *         lvl: record.level,
 *         msg: record.msg,
 *         time: record.datetime.toISOString(),
 *         name: record.loggerName,
 *       }),
 *       useColors: false,
 *     }),
 *   },
 *
 *   loggers: {
 *     default: {
 *       level: "DEBUG",
 *       handlers: ["customJsonFmt"],
 *     },
 *   },
 * });
 *
 * // calling:
 * log.info("complete");
 * // results in:
 * // {"lvl":20,"msg":"complete","time":"2023-12-13T16:38:27.328Z","name":"default"}
 * ```
 *
 * @example
 * Inline Logging
 * ```ts
 * import * as logger from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * const stringData: string = logger.debug("hello world");
 * const booleanData: boolean = logger.debug(true, 1, "abc");
 * const fn = (): number => {
 *   return 123;
 * };
 * const resolvedFunctionData: number = logger.debug(fn());
 * console.log(stringData); // 'hello world'
 * console.log(booleanData); // true
 * console.log(resolvedFunctionData); // 123
 * ```
 *
 * @example
 * Lazy Log Evaluation
 * ```ts
 * import * as log from "https://deno.land/std@$STD_VERSION/log/mod.ts";
 *
 * log.setup({
 *   handlers: {
 *     console: new log.ConsoleHandler("DEBUG"),
 *   },
 *
 *   loggers: {
 *     tasks: {
 *       level: "ERROR",
 *       handlers: ["console"],
 *     },
 *   },
 * });
 *
 * function someExpensiveFn(num: number, bool: boolean) {
 *   // do some expensive computation
 * }
 *
 * // not logged, as debug < error.
 * const data = log.debug(() => someExpensiveFn(5, true));
 * console.log(data); // undefined
 * ```
 *
 * Handlers are responsible for actual output of log messages. When a handler is
 * called by a logger, it firstly checks that {@linkcode LogRecord}'s level is
 * not lower than level of the handler. If level check passes, handlers formats
 * log record into string and outputs it to target.
 *
 * ## Custom handlers
 *
 * Custom handlers can be implemented by subclassing {@linkcode BaseHandler} or
 * {@linkcode WriterHandler}.
 *
 * {@linkcode BaseHandler} is bare-bones handler that has no output logic at all,
 *
 * {@linkcode WriterHandler} is an abstract class that supports any target with
 * `Writer` interface.
 *
 * During setup async hooks `setup` and `destroy` are called, you can use them
 * to open and close file/HTTP connection or any other action you might need.
 *
 * For examples check source code of {@linkcode FileHandler}`
 * and {@linkcode TestHandler}.
 *
 * @module
 */ export * from "./base_handler.ts";
export * from "./console_handler.ts";
export * from "./file_handler.ts";
export * from "./rotating_file_handler.ts";
export * from "./levels.ts";
export * from "./logger.ts";
export * from "./formatters.ts";
export * from "./critical.ts";
export * from "./debug.ts";
export * from "./error.ts";
export * from "./get_logger.ts";
export * from "./info.ts";
export * from "./setup.ts";
export * from "./warn.ts";

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/mod.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\n/**\n * Logging library with the support for terminal and file outputs. Also provides\n * interfaces for building custom loggers.\n *\n * ## Loggers\n *\n * Loggers are objects that you interact with. When you use a logger method it\n * constructs a `LogRecord` and passes it down to its handlers for output. To\n * create custom loggers, specify them in `loggers` when calling `log.setup`.\n *\n * ## Custom message format\n *\n * If you want to override default format of message you can define `formatter`\n * option for handler. It can a function that takes `LogRecord`\n * as argument and outputs string.\n *\n * The default log format is `{levelName} {msg}`.\n *\n * ### Logging Structured JSON Lines\n *\n * To output logs in a structured JSON format you can configure most handlers\n * with a formatter that produces a JSON string. Either use the premade\n * `log.formatters.jsonFormatter` or write your own function that takes a\n * {@linkcode LogRecord} and returns a JSON.stringify'd object.\n * If you want the log to go to stdout then use {@linkcode ConsoleHandler} with\n * the configuration `useColors: false` to turn off the ANSI terminal colours.\n *\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * log.setup({\n *   handlers: {\n *     default: new log.ConsoleHandler(\"DEBUG\", {\n *       formatter: log.formatters.jsonFormatter,\n *       useColors: false,\n *     }),\n *   },\n * });\n * ```\n *\n * The first argument passed to a log function is always treated as the\n * message and will be stringified differently. To have arguments JSON.stringify'd\n * you must pass them after the first.\n *\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * log.info(\"This is the message\", { thisWillBe: \"JSON.stringify'd\"});\n * // {\"level\":\"INFO\",\"datetime\":1702501580505,\"message\":\"This is the message\",\"args\":{\"thisWillBe\":\"JSON.stringify'd\"}}\n *\n * log.info({ thisWontBe: \"JSON.stringify'd\"}, \"This is an argument\");\n * // {\"level\":\"INFO\",\"datetime\":1702501580505,\"message\":\"{\\\"thisWontBe\\\":\\\"JSON.stringify'd\\\"}\",\"args\":\"This is an argument\"}\n * ```\n *\n * ## Inline Logging\n *\n * Log functions return the data passed in the `msg` parameter. Data is returned\n * regardless if the logger actually logs it.\n *\n * ## Lazy Log Evaluation\n *\n * Some log statements are expensive to compute. In these cases, you can use\n * lazy log evaluation to prevent the computation taking place if the logger\n * won't log the message.\n *\n * > NOTE: When using lazy log evaluation, `undefined` will be returned if the\n * > resolver function is not called because the logger won't log it. It is an\n * > antipattern use lazy evaluation with inline logging because the return value\n * > depends on the current log level.\n *\n * ## For module authors\n *\n * The authors of public modules can let the users display the internal logs of the\n * module by using a custom logger:\n *\n * ```ts\n * import { getLogger } from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * function logger() {\n *   return getLogger(\"my-awesome-module\");\n * }\n *\n * export function sum(a: number, b: number) {\n *   logger().debug(`running ${a} + ${b}`);\n *   return a + b;\n * }\n *\n * export function mult(a: number, b: number) {\n *   logger().debug(`running ${a} * ${b}`);\n *   return a * b;\n * }\n * ```\n *\n * The user of the module can then display the internal logs with:\n *\n * ```ts, ignore\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n * import { sum } from \"<the-awesome-module>/mod.ts\";\n *\n * log.setup({\n *   handlers: {\n *     console: new log.ConsoleHandler(\"DEBUG\"),\n *   },\n *\n *   loggers: {\n *     \"my-awesome-module\": {\n *       level: \"DEBUG\",\n *       handlers: [\"console\"],\n *     },\n *   },\n * });\n *\n * sum(1, 2); // prints \"running 1 + 2\" to the console\n * ```\n *\n * Please note that, due to the order of initialization of the loggers, the\n * following won't work:\n *\n * ```ts\n * import { getLogger } from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * const logger = getLogger(\"my-awesome-module\");\n *\n * export function sum(a: number, b: number) {\n *   logger.debug(`running ${a} + ${b}`); // no message will be logged, because getLogger() was called before log.setup()\n *   return a + b;\n * }\n * ```\n *\n * @example\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * // Simple default logger out of the box. You can customize it\n * // by overriding logger and handler named \"default\", or providing\n * // additional logger configurations. You can log any data type.\n * log.debug(\"Hello world\");\n * log.info(123456);\n * log.warn(true);\n * log.error({ foo: \"bar\", fizz: \"bazz\" });\n * log.critical(\"500 Internal server error\");\n *\n * // custom configuration with 2 loggers (the default and `tasks` loggers).\n * log.setup({\n *   handlers: {\n *     console: new log.ConsoleHandler(\"DEBUG\"),\n *\n *     file: new log.FileHandler(\"WARN\", {\n *       filename: \"./log.txt\",\n *       // you can change format of output message using any keys in `LogRecord`.\n *       formatter: (record) => `${record.levelName} ${record.msg}`,\n *     }),\n *   },\n *\n *   loggers: {\n *     // configure default logger available via short-hand methods above.\n *     default: {\n *       level: \"DEBUG\",\n *       handlers: [\"console\", \"file\"],\n *     },\n *\n *     tasks: {\n *       level: \"ERROR\",\n *       handlers: [\"console\"],\n *     },\n *   },\n * });\n *\n * let logger;\n *\n * // get default logger.\n * logger = log.getLogger();\n * logger.debug(\"fizz\"); // logs to `console`, because `file` handler requires \"WARN\" level.\n * logger.warn(41256); // logs to both `console` and `file` handlers.\n *\n * // get custom logger\n * logger = log.getLogger(\"tasks\");\n * logger.debug(\"fizz\"); // won't get output because this logger has \"ERROR\" level.\n * logger.error({ productType: \"book\", value: \"126.11\" }); // log to `console`.\n *\n * // if you try to use a logger that hasn't been configured\n * // you're good to go, it gets created automatically with level set to 0\n * // so no message is logged.\n * const unknownLogger = log.getLogger(\"mystery\");\n * unknownLogger.info(\"foobar\"); // no-op\n * ```\n *\n * @example\n * Custom message format example\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * log.setup({\n *   handlers: {\n *     stringFmt: new log.ConsoleHandler(\"DEBUG\", {\n *       formatter: (record) => `[${record.levelName}] ${record.msg}`,\n *     }),\n *\n *     functionFmt: new log.ConsoleHandler(\"DEBUG\", {\n *       formatter: (logRecord) => {\n *         let msg = `${logRecord.level} ${logRecord.msg}`;\n *\n *         logRecord.args.forEach((arg, index) => {\n *           msg += `, arg${index}: ${arg}`;\n *         });\n *\n *         return msg;\n *       },\n *     }),\n *\n *     anotherFmt: new log.ConsoleHandler(\"DEBUG\", {\n *       formatter: (record) => `[${record.loggerName}] - ${record.levelName} ${record.msg}`,\n *     }),\n *   },\n *\n *   loggers: {\n *     default: {\n *       level: \"DEBUG\",\n *       handlers: [\"stringFmt\", \"functionFmt\"],\n *     },\n *     dataLogger: {\n *       level: \"INFO\",\n *       handlers: [\"anotherFmt\"],\n *     },\n *   },\n * });\n *\n * // calling:\n * log.debug(\"Hello, world!\", 1, \"two\", [3, 4, 5]);\n * // results in: [DEBUG] Hello, world!\n * // output from \"stringFmt\" handler.\n * // 10 Hello, world!, arg0: 1, arg1: two, arg3: [3, 4, 5] // output from \"functionFmt\" formatter.\n *\n * // calling:\n * log.getLogger(\"dataLogger\").error(\"oh no!\");\n * // results in:\n * // [dataLogger] - ERROR oh no! // output from anotherFmt handler.\n * ```\n\n *\n * @example\n * JSON to stdout with no color example\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * log.setup({\n *   handlers: {\n *     jsonStdout: new log.ConsoleHandler(\"DEBUG\", {\n *       formatter: log.formatters.jsonFormatter,\n *       useColors: false,\n *     }),\n *   },\n *\n *   loggers: {\n *     default: {\n *       level: \"DEBUG\",\n *       handlers: [\"jsonStdout\"],\n *     },\n *   },\n * });\n *\n * // calling:\n * log.info(\"Hey\");\n * // results in:\n * // {\"level\":\"INFO\",\"datetime\":1702481922294,\"message\":\"Hey\"}\n *\n * // calling:\n * log.info(\"Hey\", { product: \"nail\" });\n * // results in:\n * // {\"level\":\"INFO\",\"datetime\":1702484111115,\"message\":\"Hey\",\"args\":{\"product\":\"nail\"}}\n *\n * // calling:\n * log.info(\"Hey\", 1, \"two\", [3, 4, 5]);\n * // results in:\n * // {\"level\":\"INFO\",\"datetime\":1702481922294,\"message\":\"Hey\",\"args\":[1,\"two\",[3,4,5]]}\n * ```\n *\n * @example\n * Custom JSON example\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * log.setup({\n *   handlers: {\n *     customJsonFmt: new log.ConsoleHandler(\"DEBUG\", {\n *       formatter: (record) => JSON.stringify({\n *         lvl: record.level,\n *         msg: record.msg,\n *         time: record.datetime.toISOString(),\n *         name: record.loggerName,\n *       }),\n *       useColors: false,\n *     }),\n *   },\n *\n *   loggers: {\n *     default: {\n *       level: \"DEBUG\",\n *       handlers: [\"customJsonFmt\"],\n *     },\n *   },\n * });\n *\n * // calling:\n * log.info(\"complete\");\n * // results in:\n * // {\"lvl\":20,\"msg\":\"complete\",\"time\":\"2023-12-13T16:38:27.328Z\",\"name\":\"default\"}\n * ```\n *\n * @example\n * Inline Logging\n * ```ts\n * import * as logger from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * const stringData: string = logger.debug(\"hello world\");\n * const booleanData: boolean = logger.debug(true, 1, \"abc\");\n * const fn = (): number => {\n *   return 123;\n * };\n * const resolvedFunctionData: number = logger.debug(fn());\n * console.log(stringData); // 'hello world'\n * console.log(booleanData); // true\n * console.log(resolvedFunctionData); // 123\n * ```\n *\n * @example\n * Lazy Log Evaluation\n * ```ts\n * import * as log from \"https://deno.land/std@$STD_VERSION/log/mod.ts\";\n *\n * log.setup({\n *   handlers: {\n *     console: new log.ConsoleHandler(\"DEBUG\"),\n *   },\n *\n *   loggers: {\n *     tasks: {\n *       level: \"ERROR\",\n *       handlers: [\"console\"],\n *     },\n *   },\n * });\n *\n * function someExpensiveFn(num: number, bool: boolean) {\n *   // do some expensive computation\n * }\n *\n * // not logged, as debug < error.\n * const data = log.debug(() => someExpensiveFn(5, true));\n * console.log(data); // undefined\n * ```\n *\n * Handlers are responsible for actual output of log messages. When a handler is\n * called by a logger, it firstly checks that {@linkcode LogRecord}'s level is\n * not lower than level of the handler. If level check passes, handlers formats\n * log record into string and outputs it to target.\n *\n * ## Custom handlers\n *\n * Custom handlers can be implemented by subclassing {@linkcode BaseHandler} or\n * {@linkcode WriterHandler}.\n *\n * {@linkcode BaseHandler} is bare-bones handler that has no output logic at all,\n *\n * {@linkcode WriterHandler} is an abstract class that supports any target with\n * `Writer` interface.\n *\n * During setup async hooks `setup` and `destroy` are called, you can use them\n * to open and close file/HTTP connection or any other action you might need.\n *\n * For examples check source code of {@linkcode FileHandler}`\n * and {@linkcode TestHandler}.\n *\n * @module\n */\n\nexport * from \"./base_handler.ts\";\nexport * from \"./console_handler.ts\";\nexport * from \"./file_handler.ts\";\nexport * from \"./rotating_file_handler.ts\";\nexport * from \"./levels.ts\";\nexport * from \"./logger.ts\";\nexport * from \"./formatters.ts\";\nexport * from \"./critical.ts\";\nexport * from \"./debug.ts\";\nexport * from \"./error.ts\";\nexport * from \"./get_logger.ts\";\nexport * from \"./info.ts\";\nexport * from \"./setup.ts\";\nexport * from \"./warn.ts\";\n"],"names":[],"mappings":"AAAA,0EAA0E;AAE1E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsXC,GAED,cAAc,oBAAoB;AAClC,cAAc,uBAAuB;AACrC,cAAc,oBAAoB;AAClC,cAAc,6BAA6B;AAC3C,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,kBAAkB;AAChC,cAAc,gBAAgB;AAC9B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,kBAAkB;AAChC,cAAc,YAAY;AAC1B,cAAc,aAAa;AAC3B,cAAc,YAAY"}
============
Specifier: https://deno.land/std@0.224.0/log/base_handler.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
var _computedKey;
import { getLevelByName, getLevelName } from "./levels.ts";
const DEFAULT_FORMATTER = ({ levelName, msg })=>`${levelName} ${msg}`;
_computedKey = Symbol.dispose;
export class BaseHandler {
  #levelName;
  #level;
  formatter;
  constructor(levelName, { formatter = DEFAULT_FORMATTER } = {}){
    this.#levelName = levelName;
    this.#level = getLevelByName(levelName);
    this.formatter = formatter;
  }
  get level() {
    return this.#level;
  }
  set level(level) {
    this.#level = level;
    this.#levelName = getLevelName(level);
  }
  get levelName() {
    return this.#levelName;
  }
  set levelName(levelName) {
    this.#levelName = levelName;
    this.#level = getLevelByName(levelName);
  }
  handle(logRecord) {
    if (this.level > logRecord.level) return;
    const msg = this.format(logRecord);
    this.log(msg);
  }
  format(logRecord) {
    return this.formatter(logRecord);
  }
  log(_msg) {}
  setup() {}
  destroy() {}
  [_computedKey]() {
    this.destroy();
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/base_handler.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport {\n  getLevelByName,\n  getLevelName,\n  type LevelName,\n  type LogLevel,\n} from \"./levels.ts\";\nimport type { LogRecord } from \"./logger.ts\";\n\nexport type FormatterFunction = (logRecord: LogRecord) => string;\nconst DEFAULT_FORMATTER: FormatterFunction = ({ levelName, msg }) =>\n  `${levelName} ${msg}`;\n\nexport interface BaseHandlerOptions {\n  formatter?: FormatterFunction;\n}\n\nexport class BaseHandler {\n  #levelName: LevelName;\n  #level: LogLevel;\n  formatter: FormatterFunction;\n\n  constructor(\n    levelName: LevelName,\n    { formatter = DEFAULT_FORMATTER }: BaseHandlerOptions = {},\n  ) {\n    this.#levelName = levelName;\n    this.#level = getLevelByName(levelName);\n    this.formatter = formatter;\n  }\n\n  get level(): LogLevel {\n    return this.#level;\n  }\n\n  set level(level: LogLevel) {\n    this.#level = level;\n    this.#levelName = getLevelName(level);\n  }\n\n  get levelName(): LevelName {\n    return this.#levelName;\n  }\n  set levelName(levelName: LevelName) {\n    this.#levelName = levelName;\n    this.#level = getLevelByName(levelName);\n  }\n\n  handle(logRecord: LogRecord) {\n    if (this.level > logRecord.level) return;\n\n    const msg = this.format(logRecord);\n    this.log(msg);\n  }\n\n  format(logRecord: LogRecord): string {\n    return this.formatter(logRecord);\n  }\n\n  log(_msg: string) {}\n  setup() {}\n  destroy() {}\n\n  [Symbol.dispose]() {\n    this.destroy();\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;;AACrC,SACE,cAAc,EACd,YAAY,QAGP,cAAc;AAIrB,MAAM,oBAAuC,CAAC,EAAE,SAAS,EAAE,GAAG,EAAE,GAC9D,CAAC,EAAE,UAAU,CAAC,EAAE,IAAI,CAAC;eAoDpB,OAAO,OAAO;AA9CjB,OAAO,MAAM;EACX,CAAC,SAAS,CAAY;EACtB,CAAC,KAAK,CAAW;EACjB,UAA6B;EAE7B,YACE,SAAoB,EACpB,EAAE,YAAY,iBAAiB,EAAsB,GAAG,CAAC,CAAC,CAC1D;IACA,IAAI,CAAC,CAAC,SAAS,GAAG;IAClB,IAAI,CAAC,CAAC,KAAK,GAAG,eAAe;IAC7B,IAAI,CAAC,SAAS,GAAG;EACnB;EAEA,IAAI,QAAkB;IACpB,OAAO,IAAI,CAAC,CAAC,KAAK;EACpB;EAEA,IAAI,MAAM,KAAe,EAAE;IACzB,IAAI,CAAC,CAAC,KAAK,GAAG;IACd,IAAI,CAAC,CAAC,SAAS,GAAG,aAAa;EACjC;EAEA,IAAI,YAAuB;IACzB,OAAO,IAAI,CAAC,CAAC,SAAS;EACxB;EACA,IAAI,UAAU,SAAoB,EAAE;IAClC,IAAI,CAAC,CAAC,SAAS,GAAG;IAClB,IAAI,CAAC,CAAC,KAAK,GAAG,eAAe;EAC/B;EAEA,OAAO,SAAoB,EAAE;IAC3B,IAAI,IAAI,CAAC,KAAK,GAAG,UAAU,KAAK,EAAE;IAElC,MAAM,MAAM,IAAI,CAAC,MAAM,CAAC;IACxB,IAAI,CAAC,GAAG,CAAC;EACX;EAEA,OAAO,SAAoB,EAAU;IACnC,OAAO,IAAI,CAAC,SAAS,CAAC;EACxB;EAEA,IAAI,IAAY,EAAE,CAAC;EACnB,QAAQ,CAAC;EACT,UAAU,CAAC;EAEX,iBAAmB;IACjB,IAAI,CAAC,OAAO;EACd;AACF"}
============
Specifier: https://deno.land/std@0.224.0/log/levels.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Use this to retrieve the numeric log level by it's associated name.
 * Defaults to INFO.
 */ export const LogLevels = {
  NOTSET: 0,
  DEBUG: 10,
  INFO: 20,
  WARN: 30,
  ERROR: 40,
  CRITICAL: 50
};
/** Permitted log level names */ export const LogLevelNames = Object.keys(LogLevels).filter((key)=>isNaN(Number(key)));
const byLevel = {
  [LogLevels.NOTSET]: "NOTSET",
  [LogLevels.DEBUG]: "DEBUG",
  [LogLevels.INFO]: "INFO",
  [LogLevels.WARN]: "WARN",
  [LogLevels.ERROR]: "ERROR",
  [LogLevels.CRITICAL]: "CRITICAL"
};
/**
 * Returns the numeric log level associated with the passed,
 * stringy log level name.
 */ export function getLevelByName(name) {
  const level = LogLevels[name];
  if (level !== undefined) {
    return level;
  }
  throw new Error(`no log level found for name: ${name}`);
}
/** Returns the stringy log level name provided the numeric log level. */ export function getLevelName(level) {
  const levelName = byLevel[level];
  if (levelName) {
    return levelName;
  }
  throw new Error(`no level name found for level: ${level}`);
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/levels.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Use this to retrieve the numeric log level by it's associated name.\n * Defaults to INFO.\n */\nexport const LogLevels = {\n  NOTSET: 0,\n  DEBUG: 10,\n  INFO: 20,\n  WARN: 30,\n  ERROR: 40,\n  CRITICAL: 50,\n} as const;\n\n/** Union of valid log levels */\nexport type LogLevel = typeof LogLevels[LevelName];\n\n/** Union of valid log level names */\nexport type LevelName = Exclude<keyof typeof LogLevels, number>;\n\n/** Permitted log level names */\nexport const LogLevelNames: LevelName[] = Object.keys(LogLevels).filter((key) =>\n  isNaN(Number(key))\n) as LevelName[];\n\nconst byLevel: Record<LogLevel, LevelName> = {\n  [LogLevels.NOTSET]: \"NOTSET\",\n  [LogLevels.DEBUG]: \"DEBUG\",\n  [LogLevels.INFO]: \"INFO\",\n  [LogLevels.WARN]: \"WARN\",\n  [LogLevels.ERROR]: \"ERROR\",\n  [LogLevels.CRITICAL]: \"CRITICAL\",\n};\n\n/**\n * Returns the numeric log level associated with the passed,\n * stringy log level name.\n */\nexport function getLevelByName(name: LevelName): LogLevel {\n  const level = LogLevels[name];\n  if (level !== undefined) {\n    return level;\n  }\n  throw new Error(`no log level found for name: ${name}`);\n}\n\n/** Returns the stringy log level name provided the numeric log level. */\nexport function getLevelName(level: LogLevel): LevelName {\n  const levelName = byLevel[level as LogLevel];\n  if (levelName) {\n    return levelName;\n  }\n  throw new Error(`no level name found for level: ${level}`);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC;;;CAGC,GACD,OAAO,MAAM,YAAY;EACvB,QAAQ;EACR,OAAO;EACP,MAAM;EACN,MAAM;EACN,OAAO;EACP,UAAU;AACZ,EAAW;AAQX,8BAA8B,GAC9B,OAAO,MAAM,gBAA6B,OAAO,IAAI,CAAC,WAAW,MAAM,CAAC,CAAC,MACvE,MAAM,OAAO,OACE;AAEjB,MAAM,UAAuC;EAC3C,CAAC,UAAU,MAAM,CAAC,EAAE;EACpB,CAAC,UAAU,KAAK,CAAC,EAAE;EACnB,CAAC,UAAU,IAAI,CAAC,EAAE;EAClB,CAAC,UAAU,IAAI,CAAC,EAAE;EAClB,CAAC,UAAU,KAAK,CAAC,EAAE;EACnB,CAAC,UAAU,QAAQ,CAAC,EAAE;AACxB;AAEA;;;CAGC,GACD,OAAO,SAAS,eAAe,IAAe;EAC5C,MAAM,QAAQ,SAAS,CAAC,KAAK;EAC7B,IAAI,UAAU,WAAW;IACvB,OAAO;EACT;EACA,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,KAAK,CAAC;AACxD;AAEA,uEAAuE,GACvE,OAAO,SAAS,aAAa,KAAe;EAC1C,MAAM,YAAY,OAAO,CAAC,MAAkB;EAC5C,IAAI,WAAW;IACb,OAAO;EACT;EACA,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,MAAM,CAAC;AAC3D"}
============
Specifier: https://deno.land/std@0.224.0/log/console_handler.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { LogLevels } from "./levels.ts";
import { blue, bold, red, yellow } from "../fmt/colors.ts";
import { BaseHandler } from "./base_handler.ts";
/**
 * This is the default logger. It will output color coded log messages to the
 * console via `console.log()`.
 */ export class ConsoleHandler extends BaseHandler {
  #useColors;
  constructor(levelName, options = {}){
    super(levelName, options);
    this.#useColors = options.useColors ?? true;
  }
  format(logRecord) {
    let msg = super.format(logRecord);
    if (this.#useColors) {
      msg = this.applyColors(msg, logRecord.level);
    }
    return msg;
  }
  applyColors(msg, level) {
    switch(level){
      case LogLevels.INFO:
        msg = blue(msg);
        break;
      case LogLevels.WARN:
        msg = yellow(msg);
        break;
      case LogLevels.ERROR:
        msg = red(msg);
        break;
      case LogLevels.CRITICAL:
        msg = bold(red(msg));
        break;
      default:
        break;
    }
    return msg;
  }
  log(msg) {
    console.log(msg);
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/console_handler.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { type LevelName, LogLevels } from \"./levels.ts\";\nimport type { LogRecord } from \"./logger.ts\";\nimport { blue, bold, red, yellow } from \"../fmt/colors.ts\";\nimport { BaseHandler, type BaseHandlerOptions } from \"./base_handler.ts\";\n\nexport interface ConsoleHandlerOptions extends BaseHandlerOptions {\n  useColors?: boolean;\n}\n\n/**\n * This is the default logger. It will output color coded log messages to the\n * console via `console.log()`.\n */\nexport class ConsoleHandler extends BaseHandler {\n  #useColors?: boolean;\n\n  constructor(levelName: LevelName, options: ConsoleHandlerOptions = {}) {\n    super(levelName, options);\n    this.#useColors = options.useColors ?? true;\n  }\n\n  override format(logRecord: LogRecord): string {\n    let msg = super.format(logRecord);\n\n    if (this.#useColors) {\n      msg = this.applyColors(msg, logRecord.level);\n    }\n\n    return msg;\n  }\n\n  applyColors(msg: string, level: number): string {\n    switch (level) {\n      case LogLevels.INFO:\n        msg = blue(msg);\n        break;\n      case LogLevels.WARN:\n        msg = yellow(msg);\n        break;\n      case LogLevels.ERROR:\n        msg = red(msg);\n        break;\n      case LogLevels.CRITICAL:\n        msg = bold(red(msg));\n        break;\n      default:\n        break;\n    }\n\n    return msg;\n  }\n\n  override log(msg: string) {\n    console.log(msg);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAyB,SAAS,QAAQ,cAAc;AAExD,SAAS,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,QAAQ,mBAAmB;AAC3D,SAAS,WAAW,QAAiC,oBAAoB;AAMzE;;;CAGC,GACD,OAAO,MAAM,uBAAuB;EAClC,CAAC,SAAS,CAAW;EAErB,YAAY,SAAoB,EAAE,UAAiC,CAAC,CAAC,CAAE;IACrE,KAAK,CAAC,WAAW;IACjB,IAAI,CAAC,CAAC,SAAS,GAAG,QAAQ,SAAS,IAAI;EACzC;EAES,OAAO,SAAoB,EAAU;IAC5C,IAAI,MAAM,KAAK,CAAC,OAAO;IAEvB,IAAI,IAAI,CAAC,CAAC,SAAS,EAAE;MACnB,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,UAAU,KAAK;IAC7C;IAEA,OAAO;EACT;EAEA,YAAY,GAAW,EAAE,KAAa,EAAU;IAC9C,OAAQ;MACN,KAAK,UAAU,IAAI;QACjB,MAAM,KAAK;QACX;MACF,KAAK,UAAU,IAAI;QACjB,MAAM,OAAO;QACb;MACF,KAAK,UAAU,KAAK;QAClB,MAAM,IAAI;QACV;MACF,KAAK,UAAU,QAAQ;QACrB,MAAM,KAAK,IAAI;QACf;MACF;QACE;IACJ;IAEA,OAAO;EACT;EAES,IAAI,GAAW,EAAE;IACxB,QAAQ,GAAG,CAAC;EACd;AACF"}
============
Specifier: https://deno.land/std@0.224.0/fmt/colors.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
// on npm.
/**
 * String formatters and utilities for dealing with ANSI color codes.
 *
 * This module is browser compatible.
 *
 * This module supports `NO_COLOR` environmental variable disabling any coloring
 * if `NO_COLOR` is set.
 *
 * @example
 * ```ts
 * import {
 *   bgBlue,
 *   bgRgb24,
 *   bgRgb8,
 *   bold,
 *   italic,
 *   red,
 *   rgb24,
 *   rgb8,
 * } from "https://deno.land/std@$STD_VERSION/fmt/colors.ts";
 *
 * console.log(bgBlue(italic(red(bold("Hello, World!")))));
 *
 * // also supports 8bit colors
 *
 * console.log(rgb8("Hello, World!", 42));
 *
 * console.log(bgRgb8("Hello, World!", 42));
 *
 * // and 24bit rgb
 *
 * console.log(rgb24("Hello, World!", {
 *   r: 41,
 *   g: 42,
 *   b: 43,
 * }));
 *
 * console.log(bgRgb24("Hello, World!", {
 *   r: 41,
 *   g: 42,
 *   b: 43,
 * }));
 * ```
 *
 * @module
 */ // deno-lint-ignore no-explicit-any
const { Deno } = globalThis;
const noColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : false;
let enabled = !noColor;
/**
 * Set changing text color to enabled or disabled
 * @param value
 */ export function setColorEnabled(value) {
  if (Deno?.noColor) {
    return;
  }
  enabled = value;
}
/** Get whether text color change is enabled or disabled. */ export function getColorEnabled() {
  return enabled;
}
/**
 * Builds color code
 * @param open
 * @param close
 */ function code(open, close) {
  return {
    open: `\x1b[${open.join(";")}m`,
    close: `\x1b[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
/**
 * Applies color and background based on color code and its associated text
 * @param str text to apply color settings to
 * @param code color code to apply
 */ function run(str, code) {
  return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
/**
 * Reset the text modified.
 * @param str text to reset
 */ export function reset(str) {
  return run(str, code([
    0
  ], 0));
}
/**
 * Make the text bold.
 * @param str text to make bold
 */ export function bold(str) {
  return run(str, code([
    1
  ], 22));
}
/**
 * The text emits only a small amount of light.
 * @param str text to dim
 *
 * Warning: Not all terminal emulators support `dim`.
 * For compatibility across all terminals, use {@linkcode gray} or {@linkcode brightBlack} instead.
 */ export function dim(str) {
  return run(str, code([
    2
  ], 22));
}
/**
 * Make the text italic.
 * @param str text to make italic
 */ export function italic(str) {
  return run(str, code([
    3
  ], 23));
}
/**
 * Make the text underline.
 * @param str text to underline
 */ export function underline(str) {
  return run(str, code([
    4
  ], 24));
}
/**
 * Invert background color and text color.
 * @param str text to invert its color
 */ export function inverse(str) {
  return run(str, code([
    7
  ], 27));
}
/**
 * Make the text hidden.
 * @param str text to hide
 */ export function hidden(str) {
  return run(str, code([
    8
  ], 28));
}
/**
 * Put horizontal line through the center of the text.
 * @param str text to strike through
 */ export function strikethrough(str) {
  return run(str, code([
    9
  ], 29));
}
/**
 * Set text color to black.
 * @param str text to make black
 */ export function black(str) {
  return run(str, code([
    30
  ], 39));
}
/**
 * Set text color to red.
 * @param str text to make red
 */ export function red(str) {
  return run(str, code([
    31
  ], 39));
}
/**
 * Set text color to green.
 * @param str text to make green
 */ export function green(str) {
  return run(str, code([
    32
  ], 39));
}
/**
 * Set text color to yellow.
 * @param str text to make yellow
 */ export function yellow(str) {
  return run(str, code([
    33
  ], 39));
}
/**
 * Set text color to blue.
 * @param str text to make blue
 */ export function blue(str) {
  return run(str, code([
    34
  ], 39));
}
/**
 * Set text color to magenta.
 * @param str text to make magenta
 */ export function magenta(str) {
  return run(str, code([
    35
  ], 39));
}
/**
 * Set text color to cyan.
 * @param str text to make cyan
 */ export function cyan(str) {
  return run(str, code([
    36
  ], 39));
}
/**
 * Set text color to white.
 * @param str text to make white
 */ export function white(str) {
  return run(str, code([
    37
  ], 39));
}
/**
 * Set text color to gray.
 * @param str text to make gray
 */ export function gray(str) {
  return brightBlack(str);
}
/**
 * Set text color to bright black.
 * @param str text to make bright-black
 */ export function brightBlack(str) {
  return run(str, code([
    90
  ], 39));
}
/**
 * Set text color to bright red.
 * @param str text to make bright-red
 */ export function brightRed(str) {
  return run(str, code([
    91
  ], 39));
}
/**
 * Set text color to bright green.
 * @param str text to make bright-green
 */ export function brightGreen(str) {
  return run(str, code([
    92
  ], 39));
}
/**
 * Set text color to bright yellow.
 * @param str text to make bright-yellow
 */ export function brightYellow(str) {
  return run(str, code([
    93
  ], 39));
}
/**
 * Set text color to bright blue.
 * @param str text to make bright-blue
 */ export function brightBlue(str) {
  return run(str, code([
    94
  ], 39));
}
/**
 * Set text color to bright magenta.
 * @param str text to make bright-magenta
 */ export function brightMagenta(str) {
  return run(str, code([
    95
  ], 39));
}
/**
 * Set text color to bright cyan.
 * @param str text to make bright-cyan
 */ export function brightCyan(str) {
  return run(str, code([
    96
  ], 39));
}
/**
 * Set text color to bright white.
 * @param str text to make bright-white
 */ export function brightWhite(str) {
  return run(str, code([
    97
  ], 39));
}
/**
 * Set background color to black.
 * @param str text to make its background black
 */ export function bgBlack(str) {
  return run(str, code([
    40
  ], 49));
}
/**
 * Set background color to red.
 * @param str text to make its background red
 */ export function bgRed(str) {
  return run(str, code([
    41
  ], 49));
}
/**
 * Set background color to green.
 * @param str text to make its background green
 */ export function bgGreen(str) {
  return run(str, code([
    42
  ], 49));
}
/**
 * Set background color to yellow.
 * @param str text to make its background yellow
 */ export function bgYellow(str) {
  return run(str, code([
    43
  ], 49));
}
/**
 * Set background color to blue.
 * @param str text to make its background blue
 */ export function bgBlue(str) {
  return run(str, code([
    44
  ], 49));
}
/**
 *  Set background color to magenta.
 * @param str text to make its background magenta
 */ export function bgMagenta(str) {
  return run(str, code([
    45
  ], 49));
}
/**
 * Set background color to cyan.
 * @param str text to make its background cyan
 */ export function bgCyan(str) {
  return run(str, code([
    46
  ], 49));
}
/**
 * Set background color to white.
 * @param str text to make its background white
 */ export function bgWhite(str) {
  return run(str, code([
    47
  ], 49));
}
/**
 * Set background color to bright black.
 * @param str text to make its background bright-black
 */ export function bgBrightBlack(str) {
  return run(str, code([
    100
  ], 49));
}
/**
 * Set background color to bright red.
 * @param str text to make its background bright-red
 */ export function bgBrightRed(str) {
  return run(str, code([
    101
  ], 49));
}
/**
 * Set background color to bright green.
 * @param str text to make its background bright-green
 */ export function bgBrightGreen(str) {
  return run(str, code([
    102
  ], 49));
}
/**
 * Set background color to bright yellow.
 * @param str text to make its background bright-yellow
 */ export function bgBrightYellow(str) {
  return run(str, code([
    103
  ], 49));
}
/**
 * Set background color to bright blue.
 * @param str text to make its background bright-blue
 */ export function bgBrightBlue(str) {
  return run(str, code([
    104
  ], 49));
}
/**
 * Set background color to bright magenta.
 * @param str text to make its background bright-magenta
 */ export function bgBrightMagenta(str) {
  return run(str, code([
    105
  ], 49));
}
/**
 * Set background color to bright cyan.
 * @param str text to make its background bright-cyan
 */ export function bgBrightCyan(str) {
  return run(str, code([
    106
  ], 49));
}
/**
 * Set background color to bright white.
 * @param str text to make its background bright-white
 */ export function bgBrightWhite(str) {
  return run(str, code([
    107
  ], 49));
}
/* Special Color Sequences */ /**
 * Clam and truncate color codes
 * @param n
 * @param max number to truncate to
 * @param min number to truncate from
 */ function clampAndTruncate(n, max = 255, min = 0) {
  return Math.trunc(Math.max(Math.min(n, max), min));
}
/**
 * Set text color using paletted 8bit colors.
 * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
 * @param str text color to apply paletted 8bit colors to
 * @param color code
 */ export function rgb8(str, color) {
  return run(str, code([
    38,
    5,
    clampAndTruncate(color)
  ], 39));
}
/**
 * Set background color using paletted 8bit colors.
 * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
 * @param str text color to apply paletted 8bit background colors to
 * @param color code
 */ export function bgRgb8(str, color) {
  return run(str, code([
    48,
    5,
    clampAndTruncate(color)
  ], 49));
}
/**
 * Set text color using 24bit rgb.
 * `color` can be a number in range `0x000000` to `0xffffff` or
 * an `Rgb`.
 *
 * To produce the color magenta:
 *
 * ```ts
 * import { rgb24 } from "https://deno.land/std@$STD_VERSION/fmt/colors.ts";
 *
 * rgb24("foo", 0xff00ff);
 * rgb24("foo", {r: 255, g: 0, b: 255});
 * ```
 * @param str text color to apply 24bit rgb to
 * @param color code
 */ export function rgb24(str, color) {
  if (typeof color === "number") {
    return run(str, code([
      38,
      2,
      color >> 16 & 0xff,
      color >> 8 & 0xff,
      color & 0xff
    ], 39));
  }
  return run(str, code([
    38,
    2,
    clampAndTruncate(color.r),
    clampAndTruncate(color.g),
    clampAndTruncate(color.b)
  ], 39));
}
/**
 * Set background color using 24bit rgb.
 * `color` can be a number in range `0x000000` to `0xffffff` or
 * an `Rgb`.
 *
 * To produce the color magenta:
 *
 * ```ts
 * import { bgRgb24 } from "https://deno.land/std@$STD_VERSION/fmt/colors.ts";
 *
 * bgRgb24("foo", 0xff00ff);
 * bgRgb24("foo", {r: 255, g: 0, b: 255});
 * ```
 * @param str text color to apply 24bit rgb to
 * @param color code
 */ export function bgRgb24(str, color) {
  if (typeof color === "number") {
    return run(str, code([
      48,
      2,
      color >> 16 & 0xff,
      color >> 8 & 0xff,
      color & 0xff
    ], 49));
  }
  return run(str, code([
    48,
    2,
    clampAndTruncate(color.r),
    clampAndTruncate(color.g),
    clampAndTruncate(color.b)
  ], 49));
}
// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js
const ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
].join("|"), "g");
/**
 * Remove ANSI escape codes from the string.
 * @param string to remove ANSI escape codes from
 *
 *  @deprecated This will be removed in 1.0.0. Use {@linkcode stripAnsiCode} instead.
 */ export function stripColor(string) {
  return stripAnsiCode(string);
}
/**
 * Remove ANSI escape codes from the string.
 *
 * @param string to remove ANSI escape codes from
 */ export function stripAnsiCode(string) {
  return string.replace(ANSI_PATTERN, "");
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/fmt/colors.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n\n/**\n * String formatters and utilities for dealing with ANSI color codes.\n *\n * This module is browser compatible.\n *\n * This module supports `NO_COLOR` environmental variable disabling any coloring\n * if `NO_COLOR` is set.\n *\n * @example\n * ```ts\n * import {\n *   bgBlue,\n *   bgRgb24,\n *   bgRgb8,\n *   bold,\n *   italic,\n *   red,\n *   rgb24,\n *   rgb8,\n * } from \"https://deno.land/std@$STD_VERSION/fmt/colors.ts\";\n *\n * console.log(bgBlue(italic(red(bold(\"Hello, World!\")))));\n *\n * // also supports 8bit colors\n *\n * console.log(rgb8(\"Hello, World!\", 42));\n *\n * console.log(bgRgb8(\"Hello, World!\", 42));\n *\n * // and 24bit rgb\n *\n * console.log(rgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n *\n * console.log(bgRgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n * ```\n *\n * @module\n */\n\n// deno-lint-ignore no-explicit-any\nconst { Deno } = globalThis as any;\nconst noColor = typeof Deno?.noColor === \"boolean\"\n  ? Deno.noColor as boolean\n  : false;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\n/** RGB 8-bits per channel. Each in range `0->255` or `0x00->0xff` */\nexport interface Rgb {\n  /** Red component value */\n  r: number;\n  /** Green component value */\n  g: number;\n  /** Blue component value */\n  b: number;\n}\n\nlet enabled = !noColor;\n\n/**\n * Set changing text color to enabled or disabled\n * @param value\n */\nexport function setColorEnabled(value: boolean) {\n  if (Deno?.noColor) {\n    return;\n  }\n\n  enabled = value;\n}\n\n/** Get whether text color change is enabled or disabled. */\nexport function getColorEnabled(): boolean {\n  return enabled;\n}\n\n/**\n * Builds color code\n * @param open\n * @param close\n */\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\n/**\n * Applies color and background based on color code and its associated text\n * @param str text to apply color settings to\n * @param code color code to apply\n */\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\n/**\n * Reset the text modified.\n * @param str text to reset\n */\nexport function reset(str: string): string {\n  return run(str, code([0], 0));\n}\n\n/**\n * Make the text bold.\n * @param str text to make bold\n */\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\n/**\n * The text emits only a small amount of light.\n * @param str text to dim\n *\n * Warning: Not all terminal emulators support `dim`.\n * For compatibility across all terminals, use {@linkcode gray} or {@linkcode brightBlack} instead.\n */\nexport function dim(str: string): string {\n  return run(str, code([2], 22));\n}\n\n/**\n * Make the text italic.\n * @param str text to make italic\n */\nexport function italic(str: string): string {\n  return run(str, code([3], 23));\n}\n\n/**\n * Make the text underline.\n * @param str text to underline\n */\nexport function underline(str: string): string {\n  return run(str, code([4], 24));\n}\n\n/**\n * Invert background color and text color.\n * @param str text to invert its color\n */\nexport function inverse(str: string): string {\n  return run(str, code([7], 27));\n}\n\n/**\n * Make the text hidden.\n * @param str text to hide\n */\nexport function hidden(str: string): string {\n  return run(str, code([8], 28));\n}\n\n/**\n * Put horizontal line through the center of the text.\n * @param str text to strike through\n */\nexport function strikethrough(str: string): string {\n  return run(str, code([9], 29));\n}\n\n/**\n * Set text color to black.\n * @param str text to make black\n */\nexport function black(str: string): string {\n  return run(str, code([30], 39));\n}\n\n/**\n * Set text color to red.\n * @param str text to make red\n */\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\n/**\n * Set text color to green.\n * @param str text to make green\n */\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\n/**\n * Set text color to yellow.\n * @param str text to make yellow\n */\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\n/**\n * Set text color to blue.\n * @param str text to make blue\n */\nexport function blue(str: string): string {\n  return run(str, code([34], 39));\n}\n\n/**\n * Set text color to magenta.\n * @param str text to make magenta\n */\nexport function magenta(str: string): string {\n  return run(str, code([35], 39));\n}\n\n/**\n * Set text color to cyan.\n * @param str text to make cyan\n */\nexport function cyan(str: string): string {\n  return run(str, code([36], 39));\n}\n\n/**\n * Set text color to white.\n * @param str text to make white\n */\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\n/**\n * Set text color to gray.\n * @param str text to make gray\n */\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\n/**\n * Set text color to bright black.\n * @param str text to make bright-black\n */\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\n/**\n * Set text color to bright red.\n * @param str text to make bright-red\n */\nexport function brightRed(str: string): string {\n  return run(str, code([91], 39));\n}\n\n/**\n * Set text color to bright green.\n * @param str text to make bright-green\n */\nexport function brightGreen(str: string): string {\n  return run(str, code([92], 39));\n}\n\n/**\n * Set text color to bright yellow.\n * @param str text to make bright-yellow\n */\nexport function brightYellow(str: string): string {\n  return run(str, code([93], 39));\n}\n\n/**\n * Set text color to bright blue.\n * @param str text to make bright-blue\n */\nexport function brightBlue(str: string): string {\n  return run(str, code([94], 39));\n}\n\n/**\n * Set text color to bright magenta.\n * @param str text to make bright-magenta\n */\nexport function brightMagenta(str: string): string {\n  return run(str, code([95], 39));\n}\n\n/**\n * Set text color to bright cyan.\n * @param str text to make bright-cyan\n */\nexport function brightCyan(str: string): string {\n  return run(str, code([96], 39));\n}\n\n/**\n * Set text color to bright white.\n * @param str text to make bright-white\n */\nexport function brightWhite(str: string): string {\n  return run(str, code([97], 39));\n}\n\n/**\n * Set background color to black.\n * @param str text to make its background black\n */\nexport function bgBlack(str: string): string {\n  return run(str, code([40], 49));\n}\n\n/**\n * Set background color to red.\n * @param str text to make its background red\n */\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\n/**\n * Set background color to green.\n * @param str text to make its background green\n */\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\n/**\n * Set background color to yellow.\n * @param str text to make its background yellow\n */\nexport function bgYellow(str: string): string {\n  return run(str, code([43], 49));\n}\n\n/**\n * Set background color to blue.\n * @param str text to make its background blue\n */\nexport function bgBlue(str: string): string {\n  return run(str, code([44], 49));\n}\n\n/**\n *  Set background color to magenta.\n * @param str text to make its background magenta\n */\nexport function bgMagenta(str: string): string {\n  return run(str, code([45], 49));\n}\n\n/**\n * Set background color to cyan.\n * @param str text to make its background cyan\n */\nexport function bgCyan(str: string): string {\n  return run(str, code([46], 49));\n}\n\n/**\n * Set background color to white.\n * @param str text to make its background white\n */\nexport function bgWhite(str: string): string {\n  return run(str, code([47], 49));\n}\n\n/**\n * Set background color to bright black.\n * @param str text to make its background bright-black\n */\nexport function bgBrightBlack(str: string): string {\n  return run(str, code([100], 49));\n}\n\n/**\n * Set background color to bright red.\n * @param str text to make its background bright-red\n */\nexport function bgBrightRed(str: string): string {\n  return run(str, code([101], 49));\n}\n\n/**\n * Set background color to bright green.\n * @param str text to make its background bright-green\n */\nexport function bgBrightGreen(str: string): string {\n  return run(str, code([102], 49));\n}\n\n/**\n * Set background color to bright yellow.\n * @param str text to make its background bright-yellow\n */\nexport function bgBrightYellow(str: string): string {\n  return run(str, code([103], 49));\n}\n\n/**\n * Set background color to bright blue.\n * @param str text to make its background bright-blue\n */\nexport function bgBrightBlue(str: string): string {\n  return run(str, code([104], 49));\n}\n\n/**\n * Set background color to bright magenta.\n * @param str text to make its background bright-magenta\n */\nexport function bgBrightMagenta(str: string): string {\n  return run(str, code([105], 49));\n}\n\n/**\n * Set background color to bright cyan.\n * @param str text to make its background bright-cyan\n */\nexport function bgBrightCyan(str: string): string {\n  return run(str, code([106], 49));\n}\n\n/**\n * Set background color to bright white.\n * @param str text to make its background bright-white\n */\nexport function bgBrightWhite(str: string): string {\n  return run(str, code([107], 49));\n}\n\n/* Special Color Sequences */\n\n/**\n * Clam and truncate color codes\n * @param n\n * @param max number to truncate to\n * @param min number to truncate from\n */\nfunction clampAndTruncate(n: number, max = 255, min = 0): number {\n  return Math.trunc(Math.max(Math.min(n, max), min));\n}\n\n/**\n * Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit colors to\n * @param color code\n */\nexport function rgb8(str: string, color: number): string {\n  return run(str, code([38, 5, clampAndTruncate(color)], 39));\n}\n\n/**\n * Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit background colors to\n * @param color code\n */\nexport function bgRgb8(str: string, color: number): string {\n  return run(str, code([48, 5, clampAndTruncate(color)], 49));\n}\n\n/**\n * Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { rgb24 } from \"https://deno.land/std@$STD_VERSION/fmt/colors.ts\";\n *\n * rgb24(\"foo\", 0xff00ff);\n * rgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function rgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        39,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      39,\n    ),\n  );\n}\n\n/**\n * Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n * import { bgRgb24 } from \"https://deno.land/std@$STD_VERSION/fmt/colors.ts\";\n *\n * bgRgb24(\"foo\", 0xff00ff);\n * bgRgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function bgRgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        49,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      49,\n    ),\n  );\n}\n\n// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TXZcf-nq-uy=><~]))\",\n  ].join(\"|\"),\n  \"g\",\n);\n\n/**\n * Remove ANSI escape codes from the string.\n * @param string to remove ANSI escape codes from\n *\n *  @deprecated This will be removed in 1.0.0. Use {@linkcode stripAnsiCode} instead.\n */\nexport function stripColor(string: string): string {\n  return stripAnsiCode(string);\n}\n\n/**\n * Remove ANSI escape codes from the string.\n *\n * @param string to remove ANSI escape codes from\n */\nexport function stripAnsiCode(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,+EAA+E;AAC/E,UAAU;AAEV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CC,GAED,mCAAmC;AACnC,MAAM,EAAE,IAAI,EAAE,GAAG;AACjB,MAAM,UAAU,OAAO,MAAM,YAAY,YACrC,KAAK,OAAO,GACZ;AAkBJ,IAAI,UAAU,CAAC;AAEf;;;CAGC,GACD,OAAO,SAAS,gBAAgB,KAAc;EAC5C,IAAI,MAAM,SAAS;IACjB;EACF;EAEA,UAAU;AACZ;AAEA,0DAA0D,GAC1D,OAAO,SAAS;EACd,OAAO;AACT;AAEA;;;;CAIC,GACD,SAAS,KAAK,IAAc,EAAE,KAAa;EACzC,OAAO;IACL,MAAM,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC;IAC/B,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACvB,QAAQ,IAAI,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,EAAE;EAC1C;AACF;AAEA;;;;CAIC,GACD,SAAS,IAAI,GAAW,EAAE,IAAU;EAClC,OAAO,UACH,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,IAAI,OAAO,CAAC,KAAK,MAAM,EAAE,KAAK,IAAI,EAAE,EAAE,KAAK,KAAK,CAAC,CAAC,GACjE;AACN;AAEA;;;CAGC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,KAAK,GAAW;EAC9B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;;;;CAMC,GACD,OAAO,SAAS,IAAI,GAAW;EAC7B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,OAAO,GAAW;EAChC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,UAAU,GAAW;EACnC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,QAAQ,GAAW;EACjC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,OAAO,GAAW;EAChC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,cAAc,GAAW;EACvC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;CAGC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,IAAI,GAAW;EAC7B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,OAAO,GAAW;EAChC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,KAAK,GAAW;EAC9B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,QAAQ,GAAW;EACjC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,KAAK,GAAW;EAC9B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,KAAK,GAAW;EAC9B,OAAO,YAAY;AACrB;AAEA;;;CAGC,GACD,OAAO,SAAS,YAAY,GAAW;EACrC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,UAAU,GAAW;EACnC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,YAAY,GAAW;EACrC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,aAAa,GAAW;EACtC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,WAAW,GAAW;EACpC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,cAAc,GAAW;EACvC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,WAAW,GAAW;EACpC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,YAAY,GAAW;EACrC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,QAAQ,GAAW;EACjC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,QAAQ,GAAW;EACjC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,SAAS,GAAW;EAClC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,OAAO,GAAW;EAChC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,UAAU,GAAW;EACnC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,OAAO,GAAW;EAChC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,QAAQ,GAAW;EACjC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;CAGC,GACD,OAAO,SAAS,cAAc,GAAW;EACvC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,YAAY,GAAW;EACrC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,cAAc,GAAW;EACvC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,eAAe,GAAW;EACxC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,aAAa,GAAW;EACtC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,gBAAgB,GAAW;EACzC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,aAAa,GAAW;EACtC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA;;;CAGC,GACD,OAAO,SAAS,cAAc,GAAW;EACvC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAI,EAAE;AAC9B;AAEA,2BAA2B,GAE3B;;;;;CAKC,GACD,SAAS,iBAAiB,CAAS,EAAE,MAAM,GAAG,EAAE,MAAM,CAAC;EACrD,OAAO,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,MAAM;AAC/C;AAEA;;;;;CAKC,GACD,OAAO,SAAS,KAAK,GAAW,EAAE,KAAa;EAC7C,OAAO,IAAI,KAAK,KAAK;IAAC;IAAI;IAAG,iBAAiB;GAAO,EAAE;AACzD;AAEA;;;;;CAKC,GACD,OAAO,SAAS,OAAO,GAAW,EAAE,KAAa;EAC/C,OAAO,IAAI,KAAK,KAAK;IAAC;IAAI;IAAG,iBAAiB;GAAO,EAAE;AACzD;AAEA;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,MAAM,GAAW,EAAE,KAAmB;EACpD,IAAI,OAAO,UAAU,UAAU;IAC7B,OAAO,IACL,KACA,KACE;MAAC;MAAI;MAAI,SAAS,KAAM;MAAO,SAAS,IAAK;MAAM,QAAQ;KAAK,EAChE;EAGN;EACA,OAAO,IACL,KACA,KACE;IACE;IACA;IACA,iBAAiB,MAAM,CAAC;IACxB,iBAAiB,MAAM,CAAC;IACxB,iBAAiB,MAAM,CAAC;GACzB,EACD;AAGN;AAEA;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,QAAQ,GAAW,EAAE,KAAmB;EACtD,IAAI,OAAO,UAAU,UAAU;IAC7B,OAAO,IACL,KACA,KACE;MAAC;MAAI;MAAI,SAAS,KAAM;MAAO,SAAS,IAAK;MAAM,QAAQ;KAAK,EAChE;EAGN;EACA,OAAO,IACL,KACA,KACE;IACE;IACA;IACA,iBAAiB,MAAM,CAAC;IACxB,iBAAiB,MAAM,CAAC;IACxB,iBAAiB,MAAM,CAAC;GACzB,EACD;AAGN;AAEA,6FAA6F;AAC7F,MAAM,eAAe,IAAI,OACvB;EACE;EACA;CACD,CAAC,IAAI,CAAC,MACP;AAGF;;;;;CAKC,GACD,OAAO,SAAS,WAAW,MAAc;EACvC,OAAO,cAAc;AACvB;AAEA;;;;CAIC,GACD,OAAO,SAAS,cAAc,MAAc;EAC1C,OAAO,OAAO,OAAO,CAAC,cAAc;AACtC"}
============
Specifier: https://deno.land/std@0.224.0/log/file_handler.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
import { LogLevels } from "./levels.ts";
import { BaseHandler } from "./base_handler.ts";
import { writeAllSync } from "../io/write_all.ts";
const PAGE_SIZE = 4096;
/**
 * This handler will output to a file using an optional mode (default is `a`,
 * e.g. append). The file will grow indefinitely. It uses a buffer for writing
 * to file. Logs can be manually flushed with `fileHandler.flush()`. Log
 * messages with a log level greater than error are immediately flushed. Logs
 * are also flushed on process completion.
 *
 * Behavior of the log modes is as follows:
 *
 * - `'a'` - Default mode. Appends new log messages to the end of an existing log
 *   file, or create a new log file if none exists.
 * - `'w'` - Upon creation of the handler, any existing log file will be removed
 *   and a new one created.
 * - `'x'` - This will create a new log file and throw an error if one already
 *   exists.
 *
 * This handler requires `--allow-write` permission on the log file.
 */ export class FileHandler extends BaseHandler {
  _file;
  _buf = new Uint8Array(PAGE_SIZE);
  _pointer = 0;
  _filename;
  _mode;
  _openOptions;
  _encoder = new TextEncoder();
  #unloadCallback = (()=>{
    this.destroy();
  }).bind(this);
  constructor(levelName, options){
    super(levelName, options);
    this._filename = options.filename;
    // default to append mode, write only
    this._mode = options.mode ? options.mode : "a";
    this._openOptions = {
      createNew: this._mode === "x",
      create: this._mode !== "x",
      append: this._mode === "a",
      truncate: this._mode !== "a",
      write: true
    };
  }
  setup() {
    this._file = Deno.openSync(this._filename, this._openOptions);
    this.#resetBuffer();
    addEventListener("unload", this.#unloadCallback);
  }
  handle(logRecord) {
    super.handle(logRecord);
    // Immediately flush if log level is higher than ERROR
    if (logRecord.level > LogLevels.ERROR) {
      this.flush();
    }
  }
  log(msg) {
    const bytes = this._encoder.encode(msg + "\n");
    if (bytes.byteLength > this._buf.byteLength - this._pointer) {
      this.flush();
    }
    if (bytes.byteLength > this._buf.byteLength) {
      writeAllSync(this._file, bytes);
    } else {
      this._buf.set(bytes, this._pointer);
      this._pointer += bytes.byteLength;
    }
  }
  flush() {
    if (this._pointer > 0 && this._file) {
      let written = 0;
      while(written < this._pointer){
        written += this._file.writeSync(this._buf.subarray(written, this._pointer));
      }
      this.#resetBuffer();
    }
  }
  #resetBuffer() {
    this._pointer = 0;
  }
  destroy() {
    this.flush();
    this._file?.close();
    this._file = undefined;
    removeEventListener("unload", this.#unloadCallback);
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/file_handler.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\nimport { type LevelName, LogLevels } from \"./levels.ts\";\nimport type { LogRecord } from \"./logger.ts\";\nimport { BaseHandler, type BaseHandlerOptions } from \"./base_handler.ts\";\nimport { writeAllSync } from \"../io/write_all.ts\";\n\nconst PAGE_SIZE = 4096;\nexport type LogMode = \"a\" | \"w\" | \"x\";\n\nexport interface FileHandlerOptions extends BaseHandlerOptions {\n  filename: string;\n  mode?: LogMode;\n}\n\n/**\n * This handler will output to a file using an optional mode (default is `a`,\n * e.g. append). The file will grow indefinitely. It uses a buffer for writing\n * to file. Logs can be manually flushed with `fileHandler.flush()`. Log\n * messages with a log level greater than error are immediately flushed. Logs\n * are also flushed on process completion.\n *\n * Behavior of the log modes is as follows:\n *\n * - `'a'` - Default mode. Appends new log messages to the end of an existing log\n *   file, or create a new log file if none exists.\n * - `'w'` - Upon creation of the handler, any existing log file will be removed\n *   and a new one created.\n * - `'x'` - This will create a new log file and throw an error if one already\n *   exists.\n *\n * This handler requires `--allow-write` permission on the log file.\n */\nexport class FileHandler extends BaseHandler {\n  protected _file: Deno.FsFile | undefined;\n  protected _buf: Uint8Array = new Uint8Array(PAGE_SIZE);\n  protected _pointer = 0;\n  protected _filename: string;\n  protected _mode: LogMode;\n  protected _openOptions: Deno.OpenOptions;\n  protected _encoder: TextEncoder = new TextEncoder();\n  #unloadCallback = (() => {\n    this.destroy();\n  }).bind(this);\n\n  constructor(levelName: LevelName, options: FileHandlerOptions) {\n    super(levelName, options);\n    this._filename = options.filename;\n    // default to append mode, write only\n    this._mode = options.mode ? options.mode : \"a\";\n    this._openOptions = {\n      createNew: this._mode === \"x\",\n      create: this._mode !== \"x\",\n      append: this._mode === \"a\",\n      truncate: this._mode !== \"a\",\n      write: true,\n    };\n  }\n\n  override setup() {\n    this._file = Deno.openSync(this._filename, this._openOptions);\n    this.#resetBuffer();\n\n    addEventListener(\"unload\", this.#unloadCallback);\n  }\n\n  override handle(logRecord: LogRecord) {\n    super.handle(logRecord);\n\n    // Immediately flush if log level is higher than ERROR\n    if (logRecord.level > LogLevels.ERROR) {\n      this.flush();\n    }\n  }\n\n  override log(msg: string) {\n    const bytes = this._encoder.encode(msg + \"\\n\");\n    if (bytes.byteLength > this._buf.byteLength - this._pointer) {\n      this.flush();\n    }\n    if (bytes.byteLength > this._buf.byteLength) {\n      writeAllSync(this._file!, bytes);\n    } else {\n      this._buf.set(bytes, this._pointer);\n      this._pointer += bytes.byteLength;\n    }\n  }\n\n  flush() {\n    if (this._pointer > 0 && this._file) {\n      let written = 0;\n      while (written < this._pointer) {\n        written += this._file.writeSync(\n          this._buf.subarray(written, this._pointer),\n        );\n      }\n      this.#resetBuffer();\n    }\n  }\n\n  #resetBuffer() {\n    this._pointer = 0;\n  }\n\n  override destroy() {\n    this.flush();\n    this._file?.close();\n    this._file = undefined;\n    removeEventListener(\"unload\", this.#unloadCallback);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,SAAyB,SAAS,QAAQ,cAAc;AAExD,SAAS,WAAW,QAAiC,oBAAoB;AACzE,SAAS,YAAY,QAAQ,qBAAqB;AAElD,MAAM,YAAY;AAQlB;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,MAAM,oBAAoB;EACrB,MAA+B;EAC/B,OAAmB,IAAI,WAAW,WAAW;EAC7C,WAAW,EAAE;EACb,UAAkB;EAClB,MAAe;EACf,aAA+B;EAC/B,WAAwB,IAAI,cAAc;EACpD,CAAC,cAAc,GAAG,CAAC;IACjB,IAAI,CAAC,OAAO;EACd,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE;EAEd,YAAY,SAAoB,EAAE,OAA2B,CAAE;IAC7D,KAAK,CAAC,WAAW;IACjB,IAAI,CAAC,SAAS,GAAG,QAAQ,QAAQ;IACjC,qCAAqC;IACrC,IAAI,CAAC,KAAK,GAAG,QAAQ,IAAI,GAAG,QAAQ,IAAI,GAAG;IAC3C,IAAI,CAAC,YAAY,GAAG;MAClB,WAAW,IAAI,CAAC,KAAK,KAAK;MAC1B,QAAQ,IAAI,CAAC,KAAK,KAAK;MACvB,QAAQ,IAAI,CAAC,KAAK,KAAK;MACvB,UAAU,IAAI,CAAC,KAAK,KAAK;MACzB,OAAO;IACT;EACF;EAES,QAAQ;IACf,IAAI,CAAC,KAAK,GAAG,KAAK,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY;IAC5D,IAAI,CAAC,CAAC,WAAW;IAEjB,iBAAiB,UAAU,IAAI,CAAC,CAAC,cAAc;EACjD;EAES,OAAO,SAAoB,EAAE;IACpC,KAAK,CAAC,OAAO;IAEb,sDAAsD;IACtD,IAAI,UAAU,KAAK,GAAG,UAAU,KAAK,EAAE;MACrC,IAAI,CAAC,KAAK;IACZ;EACF;EAES,IAAI,GAAW,EAAE;IACxB,MAAM,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;IACzC,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,QAAQ,EAAE;MAC3D,IAAI,CAAC,KAAK;IACZ;IACA,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;MAC3C,aAAa,IAAI,CAAC,KAAK,EAAG;IAC5B,OAAO;MACL,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,QAAQ;MAClC,IAAI,CAAC,QAAQ,IAAI,MAAM,UAAU;IACnC;EACF;EAEA,QAAQ;IACN,IAAI,IAAI,CAAC,QAAQ,GAAG,KAAK,IAAI,CAAC,KAAK,EAAE;MACnC,IAAI,UAAU;MACd,MAAO,UAAU,IAAI,CAAC,QAAQ,CAAE;QAC9B,WAAW,IAAI,CAAC,KAAK,CAAC,SAAS,CAC7B,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,QAAQ;MAE7C;MACA,IAAI,CAAC,CAAC,WAAW;IACnB;EACF;EAEA,CAAC,WAAW;IACV,IAAI,CAAC,QAAQ,GAAG;EAClB;EAES,UAAU;IACjB,IAAI,CAAC,KAAK;IACV,IAAI,CAAC,KAAK,EAAE;IACZ,IAAI,CAAC,KAAK,GAAG;IACb,oBAAoB,UAAU,IAAI,CAAC,CAAC,cAAc;EACpD;AACF"}
============
Specifier: https://deno.land/std@0.224.0/io/write_all.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Write all the content of the array buffer (`arr`) to the writer (`w`).
 *
 * @example
 * ```ts
 * import { writeAll } from "https://deno.land/std@$STD_VERSION/io/write_all.ts";

 * // Example writing to stdout
 * let contentBytes = new TextEncoder().encode("Hello World");
 * await writeAll(Deno.stdout, contentBytes);
 *
 * // Example writing to file
 * contentBytes = new TextEncoder().encode("Hello World");
 * using file = await Deno.open('test.file', {write: true});
 * await writeAll(file, contentBytes);
 * ```
 */ export async function writeAll(writer, data) {
  let nwritten = 0;
  while(nwritten < data.length){
    nwritten += await writer.write(data.subarray(nwritten));
  }
}
/**
 * Synchronously write all the content of the array buffer (`arr`) to the
 * writer (`w`).
 *
 * @example
 * ```ts
 * import { writeAllSync } from "https://deno.land/std@$STD_VERSION/io/write_all.ts";
 *
 * // Example writing to stdout
 * let contentBytes = new TextEncoder().encode("Hello World");
 * writeAllSync(Deno.stdout, contentBytes);
 *
 * // Example writing to file
 * contentBytes = new TextEncoder().encode("Hello World");
 * using file = Deno.openSync('test.file', {write: true});
 * writeAllSync(file, contentBytes);
 * ```
 */ export function writeAllSync(writer, data) {
  let nwritten = 0;
  while(nwritten < data.length){
    nwritten += writer.writeSync(data.subarray(nwritten));
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/io/write_all.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { Writer, WriterSync } from \"./types.ts\";\n\n/**\n * Write all the content of the array buffer (`arr`) to the writer (`w`).\n *\n * @example\n * ```ts\n * import { writeAll } from \"https://deno.land/std@$STD_VERSION/io/write_all.ts\";\n\n * // Example writing to stdout\n * let contentBytes = new TextEncoder().encode(\"Hello World\");\n * await writeAll(Deno.stdout, contentBytes);\n *\n * // Example writing to file\n * contentBytes = new TextEncoder().encode(\"Hello World\");\n * using file = await Deno.open('test.file', {write: true});\n * await writeAll(file, contentBytes);\n * ```\n */\nexport async function writeAll(writer: Writer, data: Uint8Array) {\n  let nwritten = 0;\n  while (nwritten < data.length) {\n    nwritten += await writer.write(data.subarray(nwritten));\n  }\n}\n\n/**\n * Synchronously write all the content of the array buffer (`arr`) to the\n * writer (`w`).\n *\n * @example\n * ```ts\n * import { writeAllSync } from \"https://deno.land/std@$STD_VERSION/io/write_all.ts\";\n *\n * // Example writing to stdout\n * let contentBytes = new TextEncoder().encode(\"Hello World\");\n * writeAllSync(Deno.stdout, contentBytes);\n *\n * // Example writing to file\n * contentBytes = new TextEncoder().encode(\"Hello World\");\n * using file = Deno.openSync('test.file', {write: true});\n * writeAllSync(file, contentBytes);\n * ```\n */\nexport function writeAllSync(writer: WriterSync, data: Uint8Array) {\n  let nwritten = 0;\n  while (nwritten < data.length) {\n    nwritten += writer.writeSync(data.subarray(nwritten));\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAIrC;;;;;;;;;;;;;;;;CAgBC,GACD,OAAO,eAAe,SAAS,MAAc,EAAE,IAAgB;EAC7D,IAAI,WAAW;EACf,MAAO,WAAW,KAAK,MAAM,CAAE;IAC7B,YAAY,MAAM,OAAO,KAAK,CAAC,KAAK,QAAQ,CAAC;EAC/C;AACF;AAEA;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,aAAa,MAAkB,EAAE,IAAgB;EAC/D,IAAI,WAAW;EACf,MAAO,WAAW,KAAK,MAAM,CAAE;IAC7B,YAAY,OAAO,SAAS,CAAC,KAAK,QAAQ,CAAC;EAC7C;AACF"}
============
Specifier: https://deno.land/std@0.224.0/log/rotating_file_handler.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
import { existsSync } from "../fs/exists.ts";
import { FileHandler } from "./file_handler.ts";
/**
 * This handler extends the functionality of the {@linkcode FileHandler} by
 * "rotating" the log file when it reaches a certain size. `maxBytes` specifies
 * the maximum size in bytes that the log file can grow to before rolling over
 * to a new one. If the size of the new log message plus the current log file
 * size exceeds `maxBytes` then a roll-over is triggered. When a roll-over
 * occurs, before the log message is written, the log file is renamed and
 * appended with `.1`. If a `.1` version already existed, it would have been
 * renamed `.2` first and so on. The maximum number of log files to keep is
 * specified by `maxBackupCount`. After the renames are complete the log message
 * is written to the original, now blank, file.
 *
 * Example: Given `log.txt`, `log.txt.1`, `log.txt.2` and `log.txt.3`, a
 * `maxBackupCount` of 3 and a new log message which would cause `log.txt` to
 * exceed `maxBytes`, then `log.txt.2` would be renamed to `log.txt.3` (thereby
 * discarding the original contents of `log.txt.3` since 3 is the maximum number
 * of backups to keep), `log.txt.1` would be renamed to `log.txt.2`, `log.txt`
 * would be renamed to `log.txt.1` and finally `log.txt` would be created from
 * scratch where the new log message would be written.
 *
 * This handler uses a buffer for writing log messages to file. Logs can be
 * manually flushed with `fileHandler.flush()`. Log messages with a log level
 * greater than ERROR are immediately flushed. Logs are also flushed on process
 * completion.
 *
 * Additional notes on `mode` as described above:
 *
 * - `'a'` Default mode. As above, this will pick up where the logs left off in
 *   rotation, or create a new log file if it doesn't exist.
 * - `'w'` in addition to starting with a clean `filename`, this mode will also
 *   cause any existing backups (up to `maxBackupCount`) to be deleted on setup
 *   giving a fully clean slate.
 * - `'x'` requires that neither `filename`, nor any backups (up to
 *   `maxBackupCount`), exist before setup.
 *
 * This handler requires both `--allow-read` and `--allow-write` permissions on
 * the log files.
 */ export class RotatingFileHandler extends FileHandler {
  #maxBytes;
  #maxBackupCount;
  #currentFileSize = 0;
  constructor(levelName, options){
    super(levelName, options);
    this.#maxBytes = options.maxBytes;
    this.#maxBackupCount = options.maxBackupCount;
  }
  setup() {
    if (this.#maxBytes < 1) {
      this.destroy();
      throw new Error("maxBytes cannot be less than 1");
    }
    if (this.#maxBackupCount < 1) {
      this.destroy();
      throw new Error("maxBackupCount cannot be less than 1");
    }
    super.setup();
    if (this._mode === "w") {
      // Remove old backups too as it doesn't make sense to start with a clean
      // log file, but old backups
      for(let i = 1; i <= this.#maxBackupCount; i++){
        try {
          Deno.removeSync(this._filename + "." + i);
        } catch (error) {
          if (!(error instanceof Deno.errors.NotFound)) {
            throw error;
          }
        }
      }
    } else if (this._mode === "x") {
      // Throw if any backups also exist
      for(let i = 1; i <= this.#maxBackupCount; i++){
        if (existsSync(this._filename + "." + i)) {
          this.destroy();
          throw new Deno.errors.AlreadyExists("Backup log file " + this._filename + "." + i + " already exists");
        }
      }
    } else {
      this.#currentFileSize = Deno.statSync(this._filename).size;
    }
  }
  log(msg) {
    const msgByteLength = this._encoder.encode(msg).byteLength + 1;
    if (this.#currentFileSize + msgByteLength > this.#maxBytes) {
      this.rotateLogFiles();
      this.#currentFileSize = 0;
    }
    super.log(msg);
    this.#currentFileSize += msgByteLength;
  }
  rotateLogFiles() {
    this.flush();
    this._file.close();
    for(let i = this.#maxBackupCount - 1; i >= 0; i--){
      const source = this._filename + (i === 0 ? "" : "." + i);
      const dest = this._filename + "." + (i + 1);
      if (existsSync(source)) {
        Deno.renameSync(source, dest);
      }
    }
    this._file = Deno.openSync(this._filename, this._openOptions);
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/rotating_file_handler.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\nimport type { LevelName } from \"./levels.ts\";\nimport { existsSync } from \"../fs/exists.ts\";\nimport { FileHandler, type FileHandlerOptions } from \"./file_handler.ts\";\n\ninterface RotatingFileHandlerOptions extends FileHandlerOptions {\n  maxBytes: number;\n  maxBackupCount: number;\n}\n\n/**\n * This handler extends the functionality of the {@linkcode FileHandler} by\n * \"rotating\" the log file when it reaches a certain size. `maxBytes` specifies\n * the maximum size in bytes that the log file can grow to before rolling over\n * to a new one. If the size of the new log message plus the current log file\n * size exceeds `maxBytes` then a roll-over is triggered. When a roll-over\n * occurs, before the log message is written, the log file is renamed and\n * appended with `.1`. If a `.1` version already existed, it would have been\n * renamed `.2` first and so on. The maximum number of log files to keep is\n * specified by `maxBackupCount`. After the renames are complete the log message\n * is written to the original, now blank, file.\n *\n * Example: Given `log.txt`, `log.txt.1`, `log.txt.2` and `log.txt.3`, a\n * `maxBackupCount` of 3 and a new log message which would cause `log.txt` to\n * exceed `maxBytes`, then `log.txt.2` would be renamed to `log.txt.3` (thereby\n * discarding the original contents of `log.txt.3` since 3 is the maximum number\n * of backups to keep), `log.txt.1` would be renamed to `log.txt.2`, `log.txt`\n * would be renamed to `log.txt.1` and finally `log.txt` would be created from\n * scratch where the new log message would be written.\n *\n * This handler uses a buffer for writing log messages to file. Logs can be\n * manually flushed with `fileHandler.flush()`. Log messages with a log level\n * greater than ERROR are immediately flushed. Logs are also flushed on process\n * completion.\n *\n * Additional notes on `mode` as described above:\n *\n * - `'a'` Default mode. As above, this will pick up where the logs left off in\n *   rotation, or create a new log file if it doesn't exist.\n * - `'w'` in addition to starting with a clean `filename`, this mode will also\n *   cause any existing backups (up to `maxBackupCount`) to be deleted on setup\n *   giving a fully clean slate.\n * - `'x'` requires that neither `filename`, nor any backups (up to\n *   `maxBackupCount`), exist before setup.\n *\n * This handler requires both `--allow-read` and `--allow-write` permissions on\n * the log files.\n */\nexport class RotatingFileHandler extends FileHandler {\n  #maxBytes: number;\n  #maxBackupCount: number;\n  #currentFileSize = 0;\n\n  constructor(levelName: LevelName, options: RotatingFileHandlerOptions) {\n    super(levelName, options);\n    this.#maxBytes = options.maxBytes;\n    this.#maxBackupCount = options.maxBackupCount;\n  }\n\n  override setup() {\n    if (this.#maxBytes < 1) {\n      this.destroy();\n      throw new Error(\"maxBytes cannot be less than 1\");\n    }\n    if (this.#maxBackupCount < 1) {\n      this.destroy();\n      throw new Error(\"maxBackupCount cannot be less than 1\");\n    }\n    super.setup();\n\n    if (this._mode === \"w\") {\n      // Remove old backups too as it doesn't make sense to start with a clean\n      // log file, but old backups\n      for (let i = 1; i <= this.#maxBackupCount; i++) {\n        try {\n          Deno.removeSync(this._filename + \".\" + i);\n        } catch (error) {\n          if (!(error instanceof Deno.errors.NotFound)) {\n            throw error;\n          }\n        }\n      }\n    } else if (this._mode === \"x\") {\n      // Throw if any backups also exist\n      for (let i = 1; i <= this.#maxBackupCount; i++) {\n        if (existsSync(this._filename + \".\" + i)) {\n          this.destroy();\n          throw new Deno.errors.AlreadyExists(\n            \"Backup log file \" + this._filename + \".\" + i + \" already exists\",\n          );\n        }\n      }\n    } else {\n      this.#currentFileSize = (Deno.statSync(this._filename)).size;\n    }\n  }\n\n  override log(msg: string) {\n    const msgByteLength = this._encoder.encode(msg).byteLength + 1;\n\n    if (this.#currentFileSize + msgByteLength > this.#maxBytes) {\n      this.rotateLogFiles();\n      this.#currentFileSize = 0;\n    }\n\n    super.log(msg);\n\n    this.#currentFileSize += msgByteLength;\n  }\n\n  rotateLogFiles() {\n    this.flush();\n    this._file!.close();\n\n    for (let i = this.#maxBackupCount - 1; i >= 0; i--) {\n      const source = this._filename + (i === 0 ? \"\" : \".\" + i);\n      const dest = this._filename + \".\" + (i + 1);\n\n      if (existsSync(source)) {\n        Deno.renameSync(source, dest);\n      }\n    }\n\n    this._file = Deno.openSync(this._filename, this._openOptions);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAE1E,SAAS,UAAU,QAAQ,kBAAkB;AAC7C,SAAS,WAAW,QAAiC,oBAAoB;AAOzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCC,GACD,OAAO,MAAM,4BAA4B;EACvC,CAAC,QAAQ,CAAS;EAClB,CAAC,cAAc,CAAS;EACxB,CAAC,eAAe,GAAG,EAAE;EAErB,YAAY,SAAoB,EAAE,OAAmC,CAAE;IACrE,KAAK,CAAC,WAAW;IACjB,IAAI,CAAC,CAAC,QAAQ,GAAG,QAAQ,QAAQ;IACjC,IAAI,CAAC,CAAC,cAAc,GAAG,QAAQ,cAAc;EAC/C;EAES,QAAQ;IACf,IAAI,IAAI,CAAC,CAAC,QAAQ,GAAG,GAAG;MACtB,IAAI,CAAC,OAAO;MACZ,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,IAAI,CAAC,CAAC,cAAc,GAAG,GAAG;MAC5B,IAAI,CAAC,OAAO;MACZ,MAAM,IAAI,MAAM;IAClB;IACA,KAAK,CAAC;IAEN,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK;MACtB,wEAAwE;MACxE,4BAA4B;MAC5B,IAAK,IAAI,IAAI,GAAG,KAAK,IAAI,CAAC,CAAC,cAAc,EAAE,IAAK;QAC9C,IAAI;UACF,KAAK,UAAU,CAAC,IAAI,CAAC,SAAS,GAAG,MAAM;QACzC,EAAE,OAAO,OAAO;UACd,IAAI,CAAC,CAAC,iBAAiB,KAAK,MAAM,CAAC,QAAQ,GAAG;YAC5C,MAAM;UACR;QACF;MACF;IACF,OAAO,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK;MAC7B,kCAAkC;MAClC,IAAK,IAAI,IAAI,GAAG,KAAK,IAAI,CAAC,CAAC,cAAc,EAAE,IAAK;QAC9C,IAAI,WAAW,IAAI,CAAC,SAAS,GAAG,MAAM,IAAI;UACxC,IAAI,CAAC,OAAO;UACZ,MAAM,IAAI,KAAK,MAAM,CAAC,aAAa,CACjC,qBAAqB,IAAI,CAAC,SAAS,GAAG,MAAM,IAAI;QAEpD;MACF;IACF,OAAO;MACL,IAAI,CAAC,CAAC,eAAe,GAAG,AAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAG,IAAI;IAC9D;EACF;EAES,IAAI,GAAW,EAAE;IACxB,MAAM,gBAAgB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,UAAU,GAAG;IAE7D,IAAI,IAAI,CAAC,CAAC,eAAe,GAAG,gBAAgB,IAAI,CAAC,CAAC,QAAQ,EAAE;MAC1D,IAAI,CAAC,cAAc;MACnB,IAAI,CAAC,CAAC,eAAe,GAAG;IAC1B;IAEA,KAAK,CAAC,IAAI;IAEV,IAAI,CAAC,CAAC,eAAe,IAAI;EAC3B;EAEA,iBAAiB;IACf,IAAI,CAAC,KAAK;IACV,IAAI,CAAC,KAAK,CAAE,KAAK;IAEjB,IAAK,IAAI,IAAI,IAAI,CAAC,CAAC,cAAc,GAAG,GAAG,KAAK,GAAG,IAAK;MAClD,MAAM,SAAS,IAAI,CAAC,SAAS,GAAG,CAAC,MAAM,IAAI,KAAK,MAAM,CAAC;MACvD,MAAM,OAAO,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC;MAE1C,IAAI,WAAW,SAAS;QACtB,KAAK,UAAU,CAAC,QAAQ;MAC1B;IACF;IAEA,IAAI,CAAC,KAAK,GAAG,KAAK,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY;EAC9D;AACF"}
============
Specifier: https://deno.land/std@0.224.0/fs/exists.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
/** Options for {@linkcode exists} and {@linkcode existsSync.} */ /**
 * Asynchronously test whether or not the given path exists by checking with
 * the file system.
 *
 * Note: Do not use this function if performing a check before another operation
 * on that file. Doing so creates a race condition. Instead, perform the actual
 * file operation directly. This function is not recommended for this use case.
 * See the recommended method below.
 *
 * @see https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use
 *
 * @param path The path to the file or directory, as a string or URL.
 * @param options Additional options for the check.
 * @returns A promise that resolves with `true` if the path exists, `false`
 * otherwise.
 *
 * @example Recommended method
 * ```ts
 * // Notice no use of exists
 * try {
 *   await Deno.remove("./foo", { recursive: true });
 * } catch (error) {
 *   if (!(error instanceof Deno.errors.NotFound)) {
 *     throw error;
 *   }
 *   // Do nothing...
 * }
 * ```
 *
 * Notice that `exists()` is not used in the above example. Doing so avoids a
 * possible race condition. See the above section for details.
 *
 * @example Basic usage
 * ```ts
 * import { exists } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * await exists("./exists"); // true
 * await exists("./does_not_exist"); // false
 * ```
 *
 * @example Check if a path is readable
 * ```ts
 * import { exists } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * await exists("./readable", { isReadable: true }); // true
 * await exists("./not_readable", { isReadable: true }); // false
 * ```
 *
 * @example Check if a path is a directory
 * ```ts
 * import { exists } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * await exists("./directory", { isDirectory: true }); // true
 * await exists("./file", { isDirectory: true }); // false
 * ```
 *
 * @example Check if a path is a file
 * ```ts
 * import { exists } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * await exists("./file", { isFile: true }); // true
 * await exists("./directory", { isFile: true }); // false
 * ```
 *
 * @example Check if a path is a readable directory
 * ```ts
 * import { exists } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * await exists("./readable_directory", { isReadable: true, isDirectory: true }); // true
 * await exists("./not_readable_directory", { isReadable: true, isDirectory: true }); // false
 * ```
 *
 * @example Check if a path is a readable file
 * ```ts
 * import { exists } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * await exists("./readable_file", { isReadable: true, isFile: true }); // true
 * await exists("./not_readable_file", { isReadable: true, isFile: true }); // false
 * ```
 */ export async function exists(path, options) {
  try {
    const stat = await Deno.stat(path);
    if (options && (options.isReadable || options.isDirectory || options.isFile)) {
      if (options.isDirectory && options.isFile) {
        throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");
      }
      if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
        return false;
      }
      if (options.isReadable) {
        if (stat.mode === null) {
          return true; // Exclusive on Non-POSIX systems
        }
        if (Deno.uid() === stat.uid) {
          return (stat.mode & 0o400) === 0o400; // User is owner and can read?
        } else if (Deno.gid() === stat.gid) {
          return (stat.mode & 0o040) === 0o040; // User group is owner and can read?
        }
        return (stat.mode & 0o004) === 0o004; // Others can read?
      }
    }
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error instanceof Deno.errors.PermissionDenied) {
      if ((await Deno.permissions.query({
        name: "read",
        path
      })).state === "granted") {
        // --allow-read not missing
        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read
      }
    }
    throw error;
  }
}
/**
 * Synchronously test whether or not the given path exists by checking with
 * the file system.
 *
 * Note: Do not use this function if performing a check before another operation
 * on that file. Doing so creates a race condition. Instead, perform the actual
 * file operation directly. This function is not recommended for this use case.
 * See the recommended method below.
 *
 * @see https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use
 *
 * @param path The path to the file or directory, as a string or URL.
 * @param options Additional options for the check.
 * @returns `true` if the path exists, `false` otherwise.
 *
 * @example Recommended method
 * ```ts
 * // Notice no use of exists
 * try {
 *   Deno.removeSync("./foo", { recursive: true });
 * } catch (error) {
 *   if (!(error instanceof Deno.errors.NotFound)) {
 *     throw error;
 *   }
 *   // Do nothing...
 * }
 * ```
 *
 * Notice that `existsSync()` is not used in the above example. Doing so avoids
 * a possible race condition. See the above section for details.
 *
 * @example Basic usage
 * ```ts
 * import { existsSync } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * existsSync("./exists"); // true
 * existsSync("./does_not_exist"); // false
 * ```
 *
 * @example Check if a path is readable
 * ```ts
 * import { existsSync } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * existsSync("./readable", { isReadable: true }); // true
 * existsSync("./not_readable", { isReadable: true }); // false
 * ```
 *
 * @example Check if a path is a directory
 * ```ts
 * import { existsSync } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * existsSync("./directory", { isDirectory: true }); // true
 * existsSync("./file", { isDirectory: true }); // false
 * ```
 *
 * @example Check if a path is a file
 * ```ts
 * import { existsSync } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * existsSync("./file", { isFile: true }); // true
 * existsSync("./directory", { isFile: true }); // false
 * ```
 *
 * @example Check if a path is a readable directory
 * ```ts
 * import { existsSync } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * existsSync("./readable_directory", { isReadable: true, isDirectory: true }); // true
 * existsSync("./not_readable_directory", { isReadable: true, isDirectory: true }); // false
 * ```
 *
 * @example Check if a path is a readable file
 * ```ts
 * import { existsSync } from "https://deno.land/std@$STD_VERSION/fs/exists.ts";
 *
 * existsSync("./readable_file", { isReadable: true, isFile: true }); // true
 * existsSync("./not_readable_file", { isReadable: true, isFile: true }); // false
 * ```
 */ export function existsSync(path, options) {
  try {
    const stat = Deno.statSync(path);
    if (options && (options.isReadable || options.isDirectory || options.isFile)) {
      if (options.isDirectory && options.isFile) {
        throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");
      }
      if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
        return false;
      }
      if (options.isReadable) {
        if (stat.mode === null) {
          return true; // Exclusive on Non-POSIX systems
        }
        if (Deno.uid() === stat.uid) {
          return (stat.mode & 0o400) === 0o400; // User is owner and can read?
        } else if (Deno.gid() === stat.gid) {
          return (stat.mode & 0o040) === 0o040; // User group is owner and can read?
        }
        return (stat.mode & 0o004) === 0o004; // Others can read?
      }
    }
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error instanceof Deno.errors.PermissionDenied) {
      if (Deno.permissions.querySync({
        name: "read",
        path
      }).state === "granted") {
        // --allow-read not missing
        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read
      }
    }
    throw error;
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/fs/exists.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\n/** Options for {@linkcode exists} and {@linkcode existsSync.} */\nexport interface ExistsOptions {\n  /**\n   * When `true`, will check if the path is readable by the user as well.\n   *\n   * @default {false}\n   */\n  isReadable?: boolean;\n  /**\n   * When `true`, will check if the path is a directory as well. Directory\n   * symlinks are included.\n   *\n   * @default {false}\n   */\n  isDirectory?: boolean;\n  /**\n   * When `true`, will check if the path is a file as well. File symlinks are\n   * included.\n   *\n   * @default {false}\n   */\n  isFile?: boolean;\n}\n\n/**\n * Asynchronously test whether or not the given path exists by checking with\n * the file system.\n *\n * Note: Do not use this function if performing a check before another operation\n * on that file. Doing so creates a race condition. Instead, perform the actual\n * file operation directly. This function is not recommended for this use case.\n * See the recommended method below.\n *\n * @see https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use\n *\n * @param path The path to the file or directory, as a string or URL.\n * @param options Additional options for the check.\n * @returns A promise that resolves with `true` if the path exists, `false`\n * otherwise.\n *\n * @example Recommended method\n * ```ts\n * // Notice no use of exists\n * try {\n *   await Deno.remove(\"./foo\", { recursive: true });\n * } catch (error) {\n *   if (!(error instanceof Deno.errors.NotFound)) {\n *     throw error;\n *   }\n *   // Do nothing...\n * }\n * ```\n *\n * Notice that `exists()` is not used in the above example. Doing so avoids a\n * possible race condition. See the above section for details.\n *\n * @example Basic usage\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * await exists(\"./exists\"); // true\n * await exists(\"./does_not_exist\"); // false\n * ```\n *\n * @example Check if a path is readable\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * await exists(\"./readable\", { isReadable: true }); // true\n * await exists(\"./not_readable\", { isReadable: true }); // false\n * ```\n *\n * @example Check if a path is a directory\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * await exists(\"./directory\", { isDirectory: true }); // true\n * await exists(\"./file\", { isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a file\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * await exists(\"./file\", { isFile: true }); // true\n * await exists(\"./directory\", { isFile: true }); // false\n * ```\n *\n * @example Check if a path is a readable directory\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * await exists(\"./readable_directory\", { isReadable: true, isDirectory: true }); // true\n * await exists(\"./not_readable_directory\", { isReadable: true, isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a readable file\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * await exists(\"./readable_file\", { isReadable: true, isFile: true }); // true\n * await exists(\"./not_readable_file\", { isReadable: true, isFile: true }); // false\n * ```\n */\nexport async function exists(\n  path: string | URL,\n  options?: ExistsOptions,\n): Promise<boolean> {\n  try {\n    const stat = await Deno.stat(path);\n    if (\n      options &&\n      (options.isReadable || options.isDirectory || options.isFile)\n    ) {\n      if (options.isDirectory && options.isFile) {\n        throw new TypeError(\n          \"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.\",\n        );\n      }\n      if (\n        (options.isDirectory && !stat.isDirectory) ||\n        (options.isFile && !stat.isFile)\n      ) {\n        return false;\n      }\n      if (options.isReadable) {\n        if (stat.mode === null) {\n          return true; // Exclusive on Non-POSIX systems\n        }\n        if (Deno.uid() === stat.uid) {\n          return (stat.mode & 0o400) === 0o400; // User is owner and can read?\n        } else if (Deno.gid() === stat.gid) {\n          return (stat.mode & 0o040) === 0o040; // User group is owner and can read?\n        }\n        return (stat.mode & 0o004) === 0o004; // Others can read?\n      }\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      return false;\n    }\n    if (error instanceof Deno.errors.PermissionDenied) {\n      if (\n        (await Deno.permissions.query({ name: \"read\", path })).state ===\n          \"granted\"\n      ) {\n        // --allow-read not missing\n        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read\n      }\n    }\n    throw error;\n  }\n}\n\n/**\n * Synchronously test whether or not the given path exists by checking with\n * the file system.\n *\n * Note: Do not use this function if performing a check before another operation\n * on that file. Doing so creates a race condition. Instead, perform the actual\n * file operation directly. This function is not recommended for this use case.\n * See the recommended method below.\n *\n * @see https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use\n *\n * @param path The path to the file or directory, as a string or URL.\n * @param options Additional options for the check.\n * @returns `true` if the path exists, `false` otherwise.\n *\n * @example Recommended method\n * ```ts\n * // Notice no use of exists\n * try {\n *   Deno.removeSync(\"./foo\", { recursive: true });\n * } catch (error) {\n *   if (!(error instanceof Deno.errors.NotFound)) {\n *     throw error;\n *   }\n *   // Do nothing...\n * }\n * ```\n *\n * Notice that `existsSync()` is not used in the above example. Doing so avoids\n * a possible race condition. See the above section for details.\n *\n * @example Basic usage\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * existsSync(\"./exists\"); // true\n * existsSync(\"./does_not_exist\"); // false\n * ```\n *\n * @example Check if a path is readable\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * existsSync(\"./readable\", { isReadable: true }); // true\n * existsSync(\"./not_readable\", { isReadable: true }); // false\n * ```\n *\n * @example Check if a path is a directory\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * existsSync(\"./directory\", { isDirectory: true }); // true\n * existsSync(\"./file\", { isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a file\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * existsSync(\"./file\", { isFile: true }); // true\n * existsSync(\"./directory\", { isFile: true }); // false\n * ```\n *\n * @example Check if a path is a readable directory\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * existsSync(\"./readable_directory\", { isReadable: true, isDirectory: true }); // true\n * existsSync(\"./not_readable_directory\", { isReadable: true, isDirectory: true }); // false\n * ```\n *\n * @example Check if a path is a readable file\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/exists.ts\";\n *\n * existsSync(\"./readable_file\", { isReadable: true, isFile: true }); // true\n * existsSync(\"./not_readable_file\", { isReadable: true, isFile: true }); // false\n * ```\n */\nexport function existsSync(\n  path: string | URL,\n  options?: ExistsOptions,\n): boolean {\n  try {\n    const stat = Deno.statSync(path);\n    if (\n      options &&\n      (options.isReadable || options.isDirectory || options.isFile)\n    ) {\n      if (options.isDirectory && options.isFile) {\n        throw new TypeError(\n          \"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.\",\n        );\n      }\n      if (\n        (options.isDirectory && !stat.isDirectory) ||\n        (options.isFile && !stat.isFile)\n      ) {\n        return false;\n      }\n      if (options.isReadable) {\n        if (stat.mode === null) {\n          return true; // Exclusive on Non-POSIX systems\n        }\n        if (Deno.uid() === stat.uid) {\n          return (stat.mode & 0o400) === 0o400; // User is owner and can read?\n        } else if (Deno.gid() === stat.gid) {\n          return (stat.mode & 0o040) === 0o040; // User group is owner and can read?\n        }\n        return (stat.mode & 0o004) === 0o004; // Others can read?\n      }\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      return false;\n    }\n    if (error instanceof Deno.errors.PermissionDenied) {\n      if (\n        Deno.permissions.querySync({ name: \"read\", path }).state === \"granted\"\n      ) {\n        // --allow-read not missing\n        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read\n      }\n    }\n    throw error;\n  }\n}\n"],"names":[],"mappings":"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"}
============
Specifier: https://deno.land/std@0.224.0/log/logger.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { getLevelByName, getLevelName, LogLevels } from "./levels.ts";
export class LoggerConfig {
  level;
  handlers;
}
/**
 * An object that encapsulates provided message and arguments as well some
 * metadata that can be later used when formatting a message.
 */ export class LogRecord {
  msg;
  #args;
  #datetime;
  level;
  levelName;
  loggerName;
  constructor(options){
    this.msg = options.msg;
    this.#args = [
      ...options.args
    ];
    this.level = options.level;
    this.loggerName = options.loggerName;
    this.#datetime = new Date();
    this.levelName = getLevelName(options.level);
  }
  get args() {
    return [
      ...this.#args
    ];
  }
  get datetime() {
    return new Date(this.#datetime.getTime());
  }
}
export class Logger {
  #level;
  handlers;
  #loggerName;
  constructor(loggerName, levelName, options = {}){
    this.#loggerName = loggerName;
    this.#level = getLevelByName(levelName);
    this.handlers = options.handlers || [];
  }
  /** Use this to retrieve the current numeric log level. */ get level() {
    return this.#level;
  }
  /** Use this to set the numeric log level. */ set level(level) {
    try {
      this.#level = getLevelByName(getLevelName(level));
    } catch (_) {
      throw new TypeError(`Invalid log level: ${level}`);
    }
  }
  get levelName() {
    return getLevelName(this.#level);
  }
  set levelName(levelName) {
    this.#level = getLevelByName(levelName);
  }
  get loggerName() {
    return this.#loggerName;
  }
  /**
   * If the level of the logger is greater than the level to log, then nothing
   * is logged, otherwise a log record is passed to each log handler.  `msg` data
   * passed in is returned.  If a function is passed in, it is only evaluated
   * if the msg will be logged and the return value will be the result of the
   * function, not the function itself, unless the function isn't called, in which
   * case undefined is returned.  All types are coerced to strings for logging.
   */ #log(level, msg, ...args) {
    if (this.level > level) {
      return msg instanceof Function ? undefined : msg;
    }
    let fnResult;
    let logMessage;
    if (msg instanceof Function) {
      fnResult = msg();
      logMessage = this.asString(fnResult);
    } else {
      logMessage = this.asString(msg);
    }
    const record = new LogRecord({
      msg: logMessage,
      args: args,
      level: level,
      loggerName: this.loggerName
    });
    this.handlers.forEach((handler)=>{
      handler.handle(record);
    });
    return msg instanceof Function ? fnResult : msg;
  }
  asString(data, isProperty = false) {
    if (typeof data === "string") {
      if (isProperty) return `"${data}"`;
      return data;
    } else if (data === null || typeof data === "number" || typeof data === "bigint" || typeof data === "boolean" || typeof data === "undefined" || typeof data === "symbol") {
      return String(data);
    } else if (data instanceof Error) {
      return data.stack;
    } else if (typeof data === "object") {
      return `{${Object.entries(data).map(([k, v])=>`"${k}":${this.asString(v, true)}`).join(",")}}`;
    }
    return "undefined";
  }
  debug(msg, ...args) {
    return this.#log(LogLevels.DEBUG, msg, ...args);
  }
  info(msg, ...args) {
    return this.#log(LogLevels.INFO, msg, ...args);
  }
  warn(msg, ...args) {
    return this.#log(LogLevels.WARN, msg, ...args);
  }
  error(msg, ...args) {
    return this.#log(LogLevels.ERROR, msg, ...args);
  }
  critical(msg, ...args) {
    return this.#log(LogLevels.CRITICAL, msg, ...args);
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/logger.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { getLevelByName, getLevelName, LogLevels } from \"./levels.ts\";\nimport type { LevelName, LogLevel } from \"./levels.ts\";\nimport type { BaseHandler } from \"./base_handler.ts\";\n\n// deno-lint-ignore no-explicit-any\nexport type GenericFunction = (...args: any[]) => any;\n\nexport interface LogRecordOptions {\n  msg: string;\n  args: unknown[];\n  level: LogLevel;\n  loggerName: string;\n}\n\nexport class LoggerConfig {\n  level?: LevelName;\n  handlers?: string[];\n}\n\nexport interface LogConfig {\n  handlers?: {\n    [name: string]: BaseHandler;\n  };\n  loggers?: {\n    [name: string]: LoggerConfig;\n  };\n}\n\n/**\n * An object that encapsulates provided message and arguments as well some\n * metadata that can be later used when formatting a message.\n */\nexport class LogRecord {\n  readonly msg: string;\n  #args: unknown[];\n  #datetime: Date;\n  readonly level: number;\n  readonly levelName: string;\n  readonly loggerName: string;\n\n  constructor(options: LogRecordOptions) {\n    this.msg = options.msg;\n    this.#args = [...options.args];\n    this.level = options.level;\n    this.loggerName = options.loggerName;\n    this.#datetime = new Date();\n    this.levelName = getLevelName(options.level);\n  }\n  get args(): unknown[] {\n    return [...this.#args];\n  }\n  get datetime(): Date {\n    return new Date(this.#datetime.getTime());\n  }\n}\n\nexport interface LoggerOptions {\n  handlers?: BaseHandler[];\n}\n\nexport class Logger {\n  #level: LogLevel;\n  handlers: BaseHandler[];\n  readonly #loggerName: string;\n\n  constructor(\n    loggerName: string,\n    levelName: LevelName,\n    options: LoggerOptions = {},\n  ) {\n    this.#loggerName = loggerName;\n    this.#level = getLevelByName(levelName);\n    this.handlers = options.handlers || [];\n  }\n\n  /** Use this to retrieve the current numeric log level. */\n  get level(): LogLevel {\n    return this.#level;\n  }\n\n  /** Use this to set the numeric log level. */\n  set level(level: LogLevel) {\n    try {\n      this.#level = getLevelByName(getLevelName(level));\n    } catch (_) {\n      throw new TypeError(`Invalid log level: ${level}`);\n    }\n  }\n\n  get levelName(): LevelName {\n    return getLevelName(this.#level);\n  }\n  set levelName(levelName: LevelName) {\n    this.#level = getLevelByName(levelName);\n  }\n\n  get loggerName(): string {\n    return this.#loggerName;\n  }\n\n  /**\n   * If the level of the logger is greater than the level to log, then nothing\n   * is logged, otherwise a log record is passed to each log handler.  `msg` data\n   * passed in is returned.  If a function is passed in, it is only evaluated\n   * if the msg will be logged and the return value will be the result of the\n   * function, not the function itself, unless the function isn't called, in which\n   * case undefined is returned.  All types are coerced to strings for logging.\n   */\n  #log<T>(\n    level: LogLevel,\n    msg: (T extends GenericFunction ? never : T) | (() => T),\n    ...args: unknown[]\n  ): T | undefined {\n    if (this.level > level) {\n      return msg instanceof Function ? undefined : msg;\n    }\n\n    let fnResult: T | undefined;\n    let logMessage: string;\n    if (msg instanceof Function) {\n      fnResult = msg();\n      logMessage = this.asString(fnResult);\n    } else {\n      logMessage = this.asString(msg);\n    }\n    const record: LogRecord = new LogRecord({\n      msg: logMessage,\n      args: args,\n      level: level,\n      loggerName: this.loggerName,\n    });\n\n    this.handlers.forEach((handler) => {\n      handler.handle(record);\n    });\n\n    return msg instanceof Function ? fnResult : msg;\n  }\n\n  asString(data: unknown, isProperty = false): string {\n    if (typeof data === \"string\") {\n      if (isProperty) return `\"${data}\"`;\n      return data;\n    } else if (\n      data === null ||\n      typeof data === \"number\" ||\n      typeof data === \"bigint\" ||\n      typeof data === \"boolean\" ||\n      typeof data === \"undefined\" ||\n      typeof data === \"symbol\"\n    ) {\n      return String(data);\n    } else if (data instanceof Error) {\n      return data.stack!;\n    } else if (typeof data === \"object\") {\n      return `{${\n        Object.entries(data)\n          .map(([k, v]) => `\"${k}\":${this.asString(v, true)}`)\n          .join(\",\")\n      }}`;\n    }\n    return \"undefined\";\n  }\n\n  debug<T>(msg: () => T, ...args: unknown[]): T | undefined;\n  debug<T>(msg: T extends GenericFunction ? never : T, ...args: unknown[]): T;\n  debug<T>(\n    msg: (T extends GenericFunction ? never : T) | (() => T),\n    ...args: unknown[]\n  ): T | undefined {\n    return this.#log(LogLevels.DEBUG, msg, ...args);\n  }\n\n  info<T>(msg: () => T, ...args: unknown[]): T | undefined;\n  info<T>(msg: T extends GenericFunction ? never : T, ...args: unknown[]): T;\n  info<T>(\n    msg: (T extends GenericFunction ? never : T) | (() => T),\n    ...args: unknown[]\n  ): T | undefined {\n    return this.#log(LogLevels.INFO, msg, ...args);\n  }\n\n  warn<T>(msg: () => T, ...args: unknown[]): T | undefined;\n  warn<T>(msg: T extends GenericFunction ? never : T, ...args: unknown[]): T;\n  warn<T>(\n    msg: (T extends GenericFunction ? never : T) | (() => T),\n    ...args: unknown[]\n  ): T | undefined {\n    return this.#log(LogLevels.WARN, msg, ...args);\n  }\n\n  error<T>(msg: () => T, ...args: unknown[]): T | undefined;\n  error<T>(msg: T extends GenericFunction ? never : T, ...args: unknown[]): T;\n  error<T>(\n    msg: (T extends GenericFunction ? never : T) | (() => T),\n    ...args: unknown[]\n  ): T | undefined {\n    return this.#log(LogLevels.ERROR, msg, ...args);\n  }\n\n  critical<T>(msg: () => T, ...args: unknown[]): T | undefined;\n  critical<T>(\n    msg: T extends GenericFunction ? never : T,\n    ...args: unknown[]\n  ): T;\n  critical<T>(\n    msg: (T extends GenericFunction ? never : T) | (() => T),\n    ...args: unknown[]\n  ): T | undefined {\n    return this.#log(LogLevels.CRITICAL, msg, ...args);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,EAAE,YAAY,EAAE,SAAS,QAAQ,cAAc;AActE,OAAO,MAAM;EACX,MAAkB;EAClB,SAAoB;AACtB;AAWA;;;CAGC,GACD,OAAO,MAAM;EACF,IAAY;EACrB,CAAC,IAAI,CAAY;EACjB,CAAC,QAAQ,CAAO;EACP,MAAc;EACd,UAAkB;EAClB,WAAmB;EAE5B,YAAY,OAAyB,CAAE;IACrC,IAAI,CAAC,GAAG,GAAG,QAAQ,GAAG;IACtB,IAAI,CAAC,CAAC,IAAI,GAAG;SAAI,QAAQ,IAAI;KAAC;IAC9B,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;IAC1B,IAAI,CAAC,UAAU,GAAG,QAAQ,UAAU;IACpC,IAAI,CAAC,CAAC,QAAQ,GAAG,IAAI;IACrB,IAAI,CAAC,SAAS,GAAG,aAAa,QAAQ,KAAK;EAC7C;EACA,IAAI,OAAkB;IACpB,OAAO;SAAI,IAAI,CAAC,CAAC,IAAI;KAAC;EACxB;EACA,IAAI,WAAiB;IACnB,OAAO,IAAI,KAAK,IAAI,CAAC,CAAC,QAAQ,CAAC,OAAO;EACxC;AACF;AAMA,OAAO,MAAM;EACX,CAAC,KAAK,CAAW;EACjB,SAAwB;EACf,CAAC,UAAU,CAAS;EAE7B,YACE,UAAkB,EAClB,SAAoB,EACpB,UAAyB,CAAC,CAAC,CAC3B;IACA,IAAI,CAAC,CAAC,UAAU,GAAG;IACnB,IAAI,CAAC,CAAC,KAAK,GAAG,eAAe;IAC7B,IAAI,CAAC,QAAQ,GAAG,QAAQ,QAAQ,IAAI,EAAE;EACxC;EAEA,wDAAwD,GACxD,IAAI,QAAkB;IACpB,OAAO,IAAI,CAAC,CAAC,KAAK;EACpB;EAEA,2CAA2C,GAC3C,IAAI,MAAM,KAAe,EAAE;IACzB,IAAI;MACF,IAAI,CAAC,CAAC,KAAK,GAAG,eAAe,aAAa;IAC5C,EAAE,OAAO,GAAG;MACV,MAAM,IAAI,UAAU,CAAC,mBAAmB,EAAE,MAAM,CAAC;IACnD;EACF;EAEA,IAAI,YAAuB;IACzB,OAAO,aAAa,IAAI,CAAC,CAAC,KAAK;EACjC;EACA,IAAI,UAAU,SAAoB,EAAE;IAClC,IAAI,CAAC,CAAC,KAAK,GAAG,eAAe;EAC/B;EAEA,IAAI,aAAqB;IACvB,OAAO,IAAI,CAAC,CAAC,UAAU;EACzB;EAEA;;;;;;;GAOC,GACD,CAAC,GAAG,CACF,KAAe,EACf,GAAwD,EACxD,GAAG,IAAe;IAElB,IAAI,IAAI,CAAC,KAAK,GAAG,OAAO;MACtB,OAAO,eAAe,WAAW,YAAY;IAC/C;IAEA,IAAI;IACJ,IAAI;IACJ,IAAI,eAAe,UAAU;MAC3B,WAAW;MACX,aAAa,IAAI,CAAC,QAAQ,CAAC;IAC7B,OAAO;MACL,aAAa,IAAI,CAAC,QAAQ,CAAC;IAC7B;IACA,MAAM,SAAoB,IAAI,UAAU;MACtC,KAAK;MACL,MAAM;MACN,OAAO;MACP,YAAY,IAAI,CAAC,UAAU;IAC7B;IAEA,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;MACrB,QAAQ,MAAM,CAAC;IACjB;IAEA,OAAO,eAAe,WAAW,WAAW;EAC9C;EAEA,SAAS,IAAa,EAAE,aAAa,KAAK,EAAU;IAClD,IAAI,OAAO,SAAS,UAAU;MAC5B,IAAI,YAAY,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;MAClC,OAAO;IACT,OAAO,IACL,SAAS,QACT,OAAO,SAAS,YAChB,OAAO,SAAS,YAChB,OAAO,SAAS,aAChB,OAAO,SAAS,eAChB,OAAO,SAAS,UAChB;MACA,OAAO,OAAO;IAChB,OAAO,IAAI,gBAAgB,OAAO;MAChC,OAAO,KAAK,KAAK;IACnB,OAAO,IAAI,OAAO,SAAS,UAAU;MACnC,OAAO,CAAC,CAAC,EACP,OAAO,OAAO,CAAC,MACZ,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,EAClD,IAAI,CAAC,KACT,CAAC,CAAC;IACL;IACA,OAAO;EACT;EAIA,MACE,GAAwD,EACxD,GAAG,IAAe,EACH;IACf,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,KAAK,EAAE,QAAQ;EAC5C;EAIA,KACE,GAAwD,EACxD,GAAG,IAAe,EACH;IACf,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,IAAI,EAAE,QAAQ;EAC3C;EAIA,KACE,GAAwD,EACxD,GAAG,IAAe,EACH;IACf,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,IAAI,EAAE,QAAQ;EAC3C;EAIA,MACE,GAAwD,EACxD,GAAG,IAAe,EACH;IACf,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,KAAK,EAAE,QAAQ;EAC5C;EAOA,SACE,GAAwD,EACxD,GAAG,IAAe,EACH;IACf,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,QAAQ,EAAE,QAAQ;EAC/C;AACF"}
============
Specifier: https://deno.land/std@0.224.0/log/formatters.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
export function jsonFormatter(logRecord) {
  return JSON.stringify({
    level: logRecord.levelName,
    datetime: logRecord.datetime.getTime(),
    message: logRecord.msg,
    args: flattenArgs(logRecord.args)
  });
}
function flattenArgs(args) {
  if (args.length === 1) {
    return args[0];
  } else if (args.length > 1) {
    return args;
  }
}
export const formatters = {
  jsonFormatter
};

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/formatters.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport type { LogRecord } from \"./logger.ts\";\n\nexport function jsonFormatter(logRecord: LogRecord): string {\n  return JSON.stringify({\n    level: logRecord.levelName,\n    datetime: logRecord.datetime.getTime(),\n    message: logRecord.msg,\n    args: flattenArgs(logRecord.args),\n  });\n}\n\nfunction flattenArgs(args: unknown[]): unknown {\n  if (args.length === 1) {\n    return args[0];\n  } else if (args.length > 1) {\n    return args;\n  }\n}\n\nexport const formatters: {\n  jsonFormatter(logRecord: LogRecord): string;\n} = {\n  jsonFormatter,\n};\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAGrC,OAAO,SAAS,cAAc,SAAoB;EAChD,OAAO,KAAK,SAAS,CAAC;IACpB,OAAO,UAAU,SAAS;IAC1B,UAAU,UAAU,QAAQ,CAAC,OAAO;IACpC,SAAS,UAAU,GAAG;IACtB,MAAM,YAAY,UAAU,IAAI;EAClC;AACF;AAEA,SAAS,YAAY,IAAe;EAClC,IAAI,KAAK,MAAM,KAAK,GAAG;IACrB,OAAO,IAAI,CAAC,EAAE;EAChB,OAAO,IAAI,KAAK,MAAM,GAAG,GAAG;IAC1B,OAAO;EACT;AACF;AAEA,OAAO,MAAM,aAET;EACF;AACF,EAAE"}
============
Specifier: https://deno.land/std@0.224.0/log/critical.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { getLogger } from "./get_logger.ts";
export function critical(msg, ...args) {
  // Assist TS compiler with pass-through generic type
  if (msg instanceof Function) {
    return getLogger("default").critical(msg, ...args);
  }
  return getLogger("default").critical(msg, ...args);
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/critical.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { getLogger } from \"./get_logger.ts\";\nimport type { GenericFunction } from \"./logger.ts\";\n\n/** Log with critical level, using default logger. */\nexport function critical<T>(msg: () => T, ...args: unknown[]): T | undefined;\nexport function critical<T>(\n  msg: T extends GenericFunction ? never : T,\n  ...args: unknown[]\n): T;\nexport function critical<T>(\n  msg: (T extends GenericFunction ? never : T) | (() => T),\n  ...args: unknown[]\n): T | undefined {\n  // Assist TS compiler with pass-through generic type\n  if (msg instanceof Function) {\n    return getLogger(\"default\").critical(msg, ...args);\n  }\n  return getLogger(\"default\").critical(msg, ...args);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,SAAS,QAAQ,kBAAkB;AAS5C,OAAO,SAAS,SACd,GAAwD,EACxD,GAAG,IAAe;EAElB,oDAAoD;EACpD,IAAI,eAAe,UAAU;IAC3B,OAAO,UAAU,WAAW,QAAQ,CAAC,QAAQ;EAC/C;EACA,OAAO,UAAU,WAAW,QAAQ,CAAC,QAAQ;AAC/C"}
============
Specifier: https://deno.land/std@0.224.0/log/get_logger.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { assert } from "../assert/assert.ts";
import { Logger } from "./logger.ts";
import { state } from "./_state.ts";
/** Get a logger instance. If not specified `name`, get the default logger. */ export function getLogger(name) {
  if (!name) {
    const d = state.loggers.get("default");
    assert(d !== undefined, `"default" logger must be set for getting logger without name`);
    return d;
  }
  const result = state.loggers.get(name);
  if (!result) {
    const logger = new Logger(name, "NOTSET", {
      handlers: []
    });
    state.loggers.set(name, logger);
    return logger;
  }
  return result;
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/get_logger.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assert } from \"../assert/assert.ts\";\nimport { Logger } from \"./logger.ts\";\nimport { state } from \"./_state.ts\";\n\n/** Get a logger instance. If not specified `name`, get the default logger. */\nexport function getLogger(name?: string): Logger {\n  if (!name) {\n    const d = state.loggers.get(\"default\");\n    assert(\n      d !== undefined,\n      `\"default\" logger must be set for getting logger without name`,\n    );\n    return d;\n  }\n  const result = state.loggers.get(name);\n  if (!result) {\n    const logger = new Logger(name, \"NOTSET\", { handlers: [] });\n    state.loggers.set(name, logger);\n    return logger;\n  }\n  return result;\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,MAAM,QAAQ,sBAAsB;AAC7C,SAAS,MAAM,QAAQ,cAAc;AACrC,SAAS,KAAK,QAAQ,cAAc;AAEpC,4EAA4E,GAC5E,OAAO,SAAS,UAAU,IAAa;EACrC,IAAI,CAAC,MAAM;IACT,MAAM,IAAI,MAAM,OAAO,CAAC,GAAG,CAAC;IAC5B,OACE,MAAM,WACN,CAAC,4DAA4D,CAAC;IAEhE,OAAO;EACT;EACA,MAAM,SAAS,MAAM,OAAO,CAAC,GAAG,CAAC;EACjC,IAAI,CAAC,QAAQ;IACX,MAAM,SAAS,IAAI,OAAO,MAAM,UAAU;MAAE,UAAU,EAAE;IAAC;IACzD,MAAM,OAAO,CAAC,GAAG,CAAC,MAAM;IACxB,OAAO;EACT;EACA,OAAO;AACT"}
============
Specifier: https://deno.land/std@0.224.0/assert/assert.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion, error will be thrown if `expr` does not have truthy value.
 *
 * @example
 * ```ts
 * import { assert } from "https://deno.land/std@$STD_VERSION/assert/assert.ts";
 *
 * assert("hello".includes("ello")); // Doesn't throw
 * assert("hello".includes("world")); // Throws
 * ```
 */ export function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/assert/assert.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion, error will be thrown if `expr` does not have truthy value.\n *\n * @example\n * ```ts\n * import { assert } from \"https://deno.land/std@$STD_VERSION/assert/assert.ts\";\n *\n * assert(\"hello\".includes(\"ello\")); // Doesn't throw\n * assert(\"hello\".includes(\"world\")); // Throws\n * ```\n */\nexport function assert(expr: unknown, msg = \"\"): asserts expr {\n  if (!expr) {\n    throw new AssertionError(msg);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;CAUC,GACD,OAAO,SAAS,OAAO,IAAa,EAAE,MAAM,EAAE;EAC5C,IAAI,CAAC,MAAM;IACT,MAAM,IAAI,eAAe;EAC3B;AACF"}
============
Specifier: https://deno.land/std@0.224.0/assert/assertion_error.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Error thrown when an assertion fails.
 *
 * @example
 * ```ts
 * import { AssertionError } from "https://deno.land/std@$STD_VERSION/assert/assertion_error.ts";
 *
 * throw new AssertionError("Assertion failed");
 * ```
 */ export class AssertionError extends Error {
  /** Constructs a new instance. */ constructor(message){
    super(message);
    this.name = "AssertionError";
  }
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/assert/assertion_error.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Error thrown when an assertion fails.\n *\n * @example\n * ```ts\n * import { AssertionError } from \"https://deno.land/std@$STD_VERSION/assert/assertion_error.ts\";\n *\n * throw new AssertionError(\"Assertion failed\");\n * ```\n */\nexport class AssertionError extends Error {\n  /** Constructs a new instance. */\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionError\";\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC;;;;;;;;;CASC,GACD,OAAO,MAAM,uBAAuB;EAClC,+BAA+B,GAC/B,YAAY,OAAe,CAAE;IAC3B,KAAK,CAAC;IACN,IAAI,CAAC,IAAI,GAAG;EACd;AACF"}
============
Specifier: https://deno.land/std@0.224.0/log/_state.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
import { DEFAULT_CONFIG } from "./_config.ts";
export const state = {
  handlers: new Map(),
  loggers: new Map(),
  config: DEFAULT_CONFIG
};

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/_state.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\nimport type { BaseHandler } from \"./base_handler.ts\";\nimport { DEFAULT_CONFIG } from \"./_config.ts\";\nimport type { Logger } from \"./logger.ts\";\n\nexport const state = {\n  handlers: new Map<string, BaseHandler>(),\n  loggers: new Map<string, Logger>(),\n  config: DEFAULT_CONFIG,\n};\n"],"names":[],"mappings":"AAAA,0EAA0E;AAG1E,SAAS,cAAc,QAAQ,eAAe;AAG9C,OAAO,MAAM,QAAQ;EACnB,UAAU,IAAI;EACd,SAAS,IAAI;EACb,QAAQ;AACV,EAAE"}
============
Specifier: https://deno.land/std@0.224.0/log/_config.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
import { ConsoleHandler } from "./console_handler.ts";
export const DEFAULT_LEVEL = "INFO";
export const DEFAULT_CONFIG = {
  handlers: {
    default: new ConsoleHandler(DEFAULT_LEVEL)
  },
  loggers: {
    default: {
      level: DEFAULT_LEVEL,
      handlers: [
        "default"
      ]
    }
  }
};

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/_config.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\nimport { ConsoleHandler } from \"./console_handler.ts\";\nimport type { LogConfig } from \"./logger.ts\";\n\nexport const DEFAULT_LEVEL = \"INFO\";\n\nexport const DEFAULT_CONFIG: LogConfig = {\n  handlers: {\n    default: new ConsoleHandler(DEFAULT_LEVEL),\n  },\n\n  loggers: {\n    default: {\n      level: DEFAULT_LEVEL,\n      handlers: [\"default\"],\n    },\n  },\n};\n"],"names":[],"mappings":"AAAA,0EAA0E;AAE1E,SAAS,cAAc,QAAQ,uBAAuB;AAGtD,OAAO,MAAM,gBAAgB,OAAO;AAEpC,OAAO,MAAM,iBAA4B;EACvC,UAAU;IACR,SAAS,IAAI,eAAe;EAC9B;EAEA,SAAS;IACP,SAAS;MACP,OAAO;MACP,UAAU;QAAC;OAAU;IACvB;EACF;AACF,EAAE"}
============
Specifier: https://deno.land/std@0.224.0/log/debug.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { getLogger } from "./get_logger.ts";
export function debug(msg, ...args) {
  // Assist TS compiler with pass-through generic type
  if (msg instanceof Function) {
    return getLogger("default").debug(msg, ...args);
  }
  return getLogger("default").debug(msg, ...args);
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/debug.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { getLogger } from \"./get_logger.ts\";\nimport type { GenericFunction } from \"./logger.ts\";\n\n/** Log with debug level, using default logger. */\nexport function debug<T>(msg: () => T, ...args: unknown[]): T | undefined;\nexport function debug<T>(\n  msg: T extends GenericFunction ? never : T,\n  ...args: unknown[]\n): T;\nexport function debug<T>(\n  msg: (T extends GenericFunction ? never : T) | (() => T),\n  ...args: unknown[]\n): T | undefined {\n  // Assist TS compiler with pass-through generic type\n  if (msg instanceof Function) {\n    return getLogger(\"default\").debug(msg, ...args);\n  }\n  return getLogger(\"default\").debug(msg, ...args);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,SAAS,QAAQ,kBAAkB;AAS5C,OAAO,SAAS,MACd,GAAwD,EACxD,GAAG,IAAe;EAElB,oDAAoD;EACpD,IAAI,eAAe,UAAU;IAC3B,OAAO,UAAU,WAAW,KAAK,CAAC,QAAQ;EAC5C;EACA,OAAO,UAAU,WAAW,KAAK,CAAC,QAAQ;AAC5C"}
============
Specifier: https://deno.land/std@0.224.0/log/error.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { getLogger } from "./get_logger.ts";
export function error(msg, ...args) {
  // Assist TS compiler with pass-through generic type
  if (msg instanceof Function) {
    return getLogger("default").error(msg, ...args);
  }
  return getLogger("default").error(msg, ...args);
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/error.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { getLogger } from \"./get_logger.ts\";\nimport type { GenericFunction } from \"./logger.ts\";\n\n/** Log with error level, using default logger. */\nexport function error<T>(msg: () => T, ...args: unknown[]): T | undefined;\nexport function error<T>(\n  msg: T extends GenericFunction ? never : T,\n  ...args: unknown[]\n): T;\nexport function error<T>(\n  msg: (T extends GenericFunction ? never : T) | (() => T),\n  ...args: unknown[]\n): T | undefined {\n  // Assist TS compiler with pass-through generic type\n  if (msg instanceof Function) {\n    return getLogger(\"default\").error(msg, ...args);\n  }\n  return getLogger(\"default\").error(msg, ...args);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,SAAS,QAAQ,kBAAkB;AAS5C,OAAO,SAAS,MACd,GAAwD,EACxD,GAAG,IAAe;EAElB,oDAAoD;EACpD,IAAI,eAAe,UAAU;IAC3B,OAAO,UAAU,WAAW,KAAK,CAAC,QAAQ;EAC5C;EACA,OAAO,UAAU,WAAW,KAAK,CAAC,QAAQ;AAC5C"}
============
Specifier: https://deno.land/std@0.224.0/log/info.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { getLogger } from "./get_logger.ts";
export function info(msg, ...args) {
  // Assist TS compiler with pass-through generic type
  if (msg instanceof Function) {
    return getLogger("default").info(msg, ...args);
  }
  return getLogger("default").info(msg, ...args);
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/info.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { getLogger } from \"./get_logger.ts\";\nimport type { GenericFunction } from \"./logger.ts\";\n\n/** Log with info level, using default logger. */\nexport function info<T>(msg: () => T, ...args: unknown[]): T | undefined;\nexport function info<T>(\n  msg: T extends GenericFunction ? never : T,\n  ...args: unknown[]\n): T;\nexport function info<T>(\n  msg: (T extends GenericFunction ? never : T) | (() => T),\n  ...args: unknown[]\n): T | undefined {\n  // Assist TS compiler with pass-through generic type\n  if (msg instanceof Function) {\n    return getLogger(\"default\").info(msg, ...args);\n  }\n  return getLogger(\"default\").info(msg, ...args);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,SAAS,QAAQ,kBAAkB;AAS5C,OAAO,SAAS,KACd,GAAwD,EACxD,GAAG,IAAe;EAElB,oDAAoD;EACpD,IAAI,eAAe,UAAU;IAC3B,OAAO,UAAU,WAAW,IAAI,CAAC,QAAQ;EAC3C;EACA,OAAO,UAAU,WAAW,IAAI,CAAC,QAAQ;AAC3C"}
============
Specifier: https://deno.land/std@0.224.0/log/setup.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { DEFAULT_CONFIG, DEFAULT_LEVEL } from "./_config.ts";
import { Logger } from "./logger.ts";
import { state } from "./_state.ts";
/** Setup logger config. */ export function setup(config) {
  state.config = {
    handlers: {
      ...DEFAULT_CONFIG.handlers,
      ...config.handlers
    },
    loggers: {
      ...DEFAULT_CONFIG.loggers,
      ...config.loggers
    }
  };
  // tear down existing handlers
  state.handlers.forEach((handler)=>{
    handler.destroy();
  });
  state.handlers.clear();
  // setup handlers
  const handlers = state.config.handlers || {};
  for (const [handlerName, handler] of Object.entries(handlers)){
    handler.setup();
    state.handlers.set(handlerName, handler);
  }
  // remove existing loggers
  state.loggers.clear();
  // setup loggers
  const loggers = state.config.loggers || {};
  for (const [loggerName, loggerConfig] of Object.entries(loggers)){
    const handlerNames = loggerConfig.handlers || [];
    const handlers = [];
    handlerNames.forEach((handlerName)=>{
      const handler = state.handlers.get(handlerName);
      if (handler) {
        handlers.push(handler);
      }
    });
    const levelName = loggerConfig.level || DEFAULT_LEVEL;
    const logger = new Logger(loggerName, levelName, {
      handlers: handlers
    });
    state.loggers.set(loggerName, logger);
  }
}
setup(DEFAULT_CONFIG);

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/setup.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { BaseHandler } from \"./base_handler.ts\";\nimport { DEFAULT_CONFIG, DEFAULT_LEVEL } from \"./_config.ts\";\nimport { type LogConfig, Logger } from \"./logger.ts\";\nimport { state } from \"./_state.ts\";\n\n/** Setup logger config. */\nexport function setup(config: LogConfig) {\n  state.config = {\n    handlers: { ...DEFAULT_CONFIG.handlers, ...config.handlers },\n    loggers: { ...DEFAULT_CONFIG.loggers, ...config.loggers },\n  };\n\n  // tear down existing handlers\n  state.handlers.forEach((handler) => {\n    handler.destroy();\n  });\n  state.handlers.clear();\n\n  // setup handlers\n  const handlers = state.config.handlers || {};\n\n  for (const [handlerName, handler] of Object.entries(handlers)) {\n    handler.setup();\n    state.handlers.set(handlerName, handler);\n  }\n\n  // remove existing loggers\n  state.loggers.clear();\n\n  // setup loggers\n  const loggers = state.config.loggers || {};\n  for (const [loggerName, loggerConfig] of Object.entries(loggers)) {\n    const handlerNames = loggerConfig.handlers || [];\n    const handlers: BaseHandler[] = [];\n\n    handlerNames.forEach((handlerName) => {\n      const handler = state.handlers.get(handlerName);\n      if (handler) {\n        handlers.push(handler);\n      }\n    });\n\n    const levelName = loggerConfig.level || DEFAULT_LEVEL;\n    const logger = new Logger(loggerName, levelName, { handlers: handlers });\n    state.loggers.set(loggerName, logger);\n  }\n}\n\nsetup(DEFAULT_CONFIG);\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAGrC,SAAS,cAAc,EAAE,aAAa,QAAQ,eAAe;AAC7D,SAAyB,MAAM,QAAQ,cAAc;AACrD,SAAS,KAAK,QAAQ,cAAc;AAEpC,yBAAyB,GACzB,OAAO,SAAS,MAAM,MAAiB;EACrC,MAAM,MAAM,GAAG;IACb,UAAU;MAAE,GAAG,eAAe,QAAQ;MAAE,GAAG,OAAO,QAAQ;IAAC;IAC3D,SAAS;MAAE,GAAG,eAAe,OAAO;MAAE,GAAG,OAAO,OAAO;IAAC;EAC1D;EAEA,8BAA8B;EAC9B,MAAM,QAAQ,CAAC,OAAO,CAAC,CAAC;IACtB,QAAQ,OAAO;EACjB;EACA,MAAM,QAAQ,CAAC,KAAK;EAEpB,iBAAiB;EACjB,MAAM,WAAW,MAAM,MAAM,CAAC,QAAQ,IAAI,CAAC;EAE3C,KAAK,MAAM,CAAC,aAAa,QAAQ,IAAI,OAAO,OAAO,CAAC,UAAW;IAC7D,QAAQ,KAAK;IACb,MAAM,QAAQ,CAAC,GAAG,CAAC,aAAa;EAClC;EAEA,0BAA0B;EAC1B,MAAM,OAAO,CAAC,KAAK;EAEnB,gBAAgB;EAChB,MAAM,UAAU,MAAM,MAAM,CAAC,OAAO,IAAI,CAAC;EACzC,KAAK,MAAM,CAAC,YAAY,aAAa,IAAI,OAAO,OAAO,CAAC,SAAU;IAChE,MAAM,eAAe,aAAa,QAAQ,IAAI,EAAE;IAChD,MAAM,WAA0B,EAAE;IAElC,aAAa,OAAO,CAAC,CAAC;MACpB,MAAM,UAAU,MAAM,QAAQ,CAAC,GAAG,CAAC;MACnC,IAAI,SAAS;QACX,SAAS,IAAI,CAAC;MAChB;IACF;IAEA,MAAM,YAAY,aAAa,KAAK,IAAI;IACxC,MAAM,SAAS,IAAI,OAAO,YAAY,WAAW;MAAE,UAAU;IAAS;IACtE,MAAM,OAAO,CAAC,GAAG,CAAC,YAAY;EAChC;AACF;AAEA,MAAM"}
============
Specifier: https://deno.land/std@0.224.0/log/warn.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { getLogger } from "./get_logger.ts";
export function warn(msg, ...args) {
  // Assist TS compiler with pass-through generic type
  if (msg instanceof Function) {
    return getLogger("default").warn(msg, ...args);
  }
  return getLogger("default").warn(msg, ...args);
}

---
{"version":3,"sources":["https://deno.land/std@0.224.0/log/warn.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { getLogger } from \"./get_logger.ts\";\nimport type { GenericFunction } from \"./logger.ts\";\n\n/** Log with warning level, using default logger. */\nexport function warn<T>(msg: () => T, ...args: unknown[]): T | undefined;\nexport function warn<T>(\n  msg: T extends GenericFunction ? never : T,\n  ...args: unknown[]\n): T;\nexport function warn<T>(\n  msg: (T extends GenericFunction ? never : T) | (() => T),\n  ...args: unknown[]\n): T | undefined {\n  // Assist TS compiler with pass-through generic type\n  if (msg instanceof Function) {\n    return getLogger(\"default\").warn(msg, ...args);\n  }\n  return getLogger(\"default\").warn(msg, ...args);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,SAAS,QAAQ,kBAAkB;AAS5C,OAAO,SAAS,KACd,GAAwD,EACxD,GAAG,IAAe;EAElB,oDAAoD;EACpD,IAAI,eAAe,UAAU;IAC3B,OAAO,UAAU,WAAW,IAAI,CAAC,QAAQ;EAC3C;EACA,OAAO,UAAU,WAAW,IAAI,CAAC,QAAQ;AAC3C"}
============
Specifier: work/src/routes.ts
Kind: JavaScript
---
import { assert } from "jsr:@std/testing/asserts";
// @deno-types="npm:@types/msgpack-lite"
import msgpack from 'npm:msgpack-lite';
import { insertLocationEvent } from "./mongodb.ts";
function unbias(i, f, a) {
  if (0 <= i && i <= a - 1) {
    i = i + 1;
    return i - f;
  } else if (a <= i && i <= 2 * a) {
    i = i - a;
    let x = i - f;
    if (x != 0) {
      x = -x;
    }
    return x;
  } else {
    assert(false) // i not in [0, 2a]
    ;
  }
}
export function validateLocationEvent(req) {
  const buffer = req.body;
  // fast checks
  assert(buffer[0] == 0x84) // must be object with 4 keys (v, t, d, m)
  ;
  assert(buffer[1] == 0xA1 && buffer[2] == 0x76) // first key is 'v'
  ;
  assert(buffer[3] == 0xA8 && buffer[4] == 0x65) // vids are 8 character strings starting with e
  ;
  // slower msgpack decode and other validation
  const msg = msgpack.decode(buffer); // throws on bad decode
  let vid = msg.v // already checked above
  ;
  assert(vid) // fail fast
  ;
  let timestamp = msg.t // too old/new checked on event insert
  ;
  assert(timestamp) // fail fast
  ;
  // translate & check coordinates from msg.d (bias-packed degrees) and msg.m (bit-packed milliseconds)
  // convert to D.DDDDDD accuracy at least 0.000017 or approx 2 meters
  let lat_ms = msg.m >> 16 & 0xFFFF;
  let lon_ms = msg.m & 0xFFFF;
  let lat_s = lat_ms / 1000;
  let lon_s = lon_ms / 1000;
  let lat_df = lat_s / 60;
  let lon_df = lon_s / 60;
  let lat_di = Math.trunc(msg.d / 361);
  let lon_di = msg.d % 361;
  let lat = unbias(lat_di, lat_df, 90);
  let lon = unbias(lon_di, lon_df, 180);
  assert(-90 <= lat && lat <= 90) // latitude range check.  range is [-90, 90]
  ;
  assert(-180 <= lon && lon <= 180) // longitude range check. range is [-180, 180]
  ;
  assert(!(lat == 0 && lon == 0)) // avoid bogus coordinates (null island)
  ;
  const event = {
    vid: vid,
    timestamp: timestamp,
    point: {
      type: "Point",
      coordinates: [
        lon,
        lat
      ] // GeoJSON Point expects longitude first
    }
  };
  return event;
}
export function registerRoutes(app) {
  app.post("/event/insert", async (req, res)=>{
    try {
      const event = validateLocationEvent(req);
      await insertLocationEvent(event);
      res.status(200).send("Event inserted successfully");
    } catch (error) {
      res.status(500).send("Error inserting event: " + error);
    }
  });
  app.post("/event/test", async (req, res)=>{
    try {
      const event = {
        vid: "e-00-000",
        timestamp: new Date().getTime(),
        point: {
          type: "Point",
          coordinates: [
            0,
            0
          ] // visiting null island
        }
      };
      await insertLocationEvent(event);
      res.status(200).send("Event inserted successfully");
    } catch (error) {
      res.status(500).send("Error inserting event: " + error);
    }
  });
}

---
{"version":3,"sources":["file:///work/src/routes.ts"],"sourcesContent":["import { assert } from \"jsr:@std/testing/asserts\";\n// @deno-types=\"npm:@types/express\"\nimport { Application, Request, Response } from 'npm:express';\nimport { MongoClient } from 'npm:mongodb';\n// @deno-types=\"npm:@types/msgpack-lite\"\nimport msgpack from 'npm:msgpack-lite';\nimport { insertLocationEvent, LocationEvent } from \"./mongodb.ts\";\n\nfunction unbias(i: number, f: number, a: number) {\n  if ( 0 <= i && i <= a-1 ) { // originally positive\n      i = i + 1\n      return i - f\n  } else if (a <= i && i <= 2*a) { // original negative (or zero)\n      i = i - a\n      let x = i - f\n      if (x != 0) { // prefer 0 to -0\n          x = -x\n      }\n      return x\n  } else {\n      assert(false) // i not in [0, 2a]\n  }\n}\n\nexport function validateLocationEvent(req: Request): LocationEvent {\n  const buffer = req.body\n\n  // fast checks\n\n  assert(buffer[0] == 0x84) // must be object with 4 keys (v, t, d, m)\n  assert(buffer[1] == 0xA1 && buffer[2] == 0x76) // first key is 'v'\n  assert(buffer[3] == 0xA8 && buffer[4] == 0x65) // vids are 8 character strings starting with e\n\n  // slower msgpack decode and other validation\n\n  const msg = msgpack.decode(buffer); // throws on bad decode\n\n  let vid: string = msg.v // already checked above\n  assert(vid) // fail fast\n  let timestamp: number = msg.t // too old/new checked on event insert\n  assert(timestamp) // fail fast\n\n  // translate & check coordinates from msg.d (bias-packed degrees) and msg.m (bit-packed milliseconds)\n  // convert to D.DDDDDD accuracy at least 0.000017 or approx 2 meters\n  let lat_ms = (msg.m >> 16) & 0xFFFF\n  let lon_ms = msg.m & 0xFFFF\n  let lat_s = lat_ms / 1000\n  let lon_s = lon_ms / 1000\n  let lat_df = lat_s / 60\n  let lon_df = lon_s / 60\n  let lat_di = Math.trunc(msg.d / 361)\n  let lon_di = (msg.d % 361)\n  let lat: number = unbias(lat_di, lat_df, 90)\n  let lon: number = unbias(lon_di, lon_df, 180)\n  assert(-90 <= lat && lat <= 90) // latitude range check.  range is [-90, 90]\n  assert(-180 <= lon && lon <= 180) // longitude range check. range is [-180, 180]\n  assert(!(lat == 0 && lon == 0)) // avoid bogus coordinates (null island)\n\n  const event: LocationEvent = {\n      vid: vid,\n      timestamp: timestamp,\n      point: {\n          type: \"Point\",\n          coordinates: [lon, lat] // GeoJSON Point expects longitude first\n      }\n  }\n\n  return event\n}\n\nexport function registerRoutes(app: Application) {\n    app.post(\"/event/insert\", async (req: Request, res: Response) => {\n        try {\n            const event = validateLocationEvent(req)\n            await insertLocationEvent(event);\n            res.status(200).send(\"Event inserted successfully\");\n        } catch (error) {\n            res.status(500).send(\"Error inserting event: \" + error);\n        }\n    });\n\n    app.post(\"/event/test\", async (req: Request, res: Response) => {\n        try {\n            const event: LocationEvent = {\n                vid: \"e-00-000\",\n                timestamp: (new Date()).getTime(),\n                point: {\n                    type: \"Point\",\n                    coordinates: [0, 0] // visiting null island\n                }\n            };\n            await insertLocationEvent(event);\n            res.status(200).send(\"Event inserted successfully\");\n        } catch (error) {\n            res.status(500).send(\"Error inserting event: \" + error);\n        }\n    });\n\n}\n"],"names":[],"mappings":"AAAA,SAAS,MAAM,QAAQ,2BAA2B;AAIlD,wCAAwC;AACxC,OAAO,aAAa,mBAAmB;AACvC,SAAS,mBAAmB,QAAuB,eAAe;AAElE,SAAS,OAAO,CAAS,EAAE,CAAS,EAAE,CAAS;EAC7C,IAAK,KAAK,KAAK,KAAK,IAAE,GAAI;IACtB,IAAI,IAAI;IACR,OAAO,IAAI;EACf,OAAO,IAAI,KAAK,KAAK,KAAK,IAAE,GAAG;IAC3B,IAAI,IAAI;IACR,IAAI,IAAI,IAAI;IACZ,IAAI,KAAK,GAAG;MACR,IAAI,CAAC;IACT;IACA,OAAO;EACX,OAAO;IACH,OAAO,OAAO,mBAAmB;;EACrC;AACF;AAEA,OAAO,SAAS,sBAAsB,GAAY;EAChD,MAAM,SAAS,IAAI,IAAI;EAEvB,cAAc;EAEd,OAAO,MAAM,CAAC,EAAE,IAAI,MAAM,0CAA0C;;EACpE,OAAO,MAAM,CAAC,EAAE,IAAI,QAAQ,MAAM,CAAC,EAAE,IAAI,MAAM,mBAAmB;;EAClE,OAAO,MAAM,CAAC,EAAE,IAAI,QAAQ,MAAM,CAAC,EAAE,IAAI,MAAM,+CAA+C;;EAE9F,6CAA6C;EAE7C,MAAM,MAAM,QAAQ,MAAM,CAAC,SAAS,uBAAuB;EAE3D,IAAI,MAAc,IAAI,CAAC,CAAC,wBAAwB;;EAChD,OAAO,KAAK,YAAY;;EACxB,IAAI,YAAoB,IAAI,CAAC,CAAC,sCAAsC;;EACpE,OAAO,WAAW,YAAY;;EAE9B,qGAAqG;EACrG,oEAAoE;EACpE,IAAI,SAAS,AAAC,IAAI,CAAC,IAAI,KAAM;EAC7B,IAAI,SAAS,IAAI,CAAC,GAAG;EACrB,IAAI,QAAQ,SAAS;EACrB,IAAI,QAAQ,SAAS;EACrB,IAAI,SAAS,QAAQ;EACrB,IAAI,SAAS,QAAQ;EACrB,IAAI,SAAS,KAAK,KAAK,CAAC,IAAI,CAAC,GAAG;EAChC,IAAI,SAAU,IAAI,CAAC,GAAG;EACtB,IAAI,MAAc,OAAO,QAAQ,QAAQ;EACzC,IAAI,MAAc,OAAO,QAAQ,QAAQ;EACzC,OAAO,CAAC,MAAM,OAAO,OAAO,IAAI,4CAA4C;;EAC5E,OAAO,CAAC,OAAO,OAAO,OAAO,KAAK,8CAA8C;;EAChF,OAAO,CAAC,CAAC,OAAO,KAAK,OAAO,CAAC,GAAG,wCAAwC;;EAExE,MAAM,QAAuB;IACzB,KAAK;IACL,WAAW;IACX,OAAO;MACH,MAAM;MACN,aAAa;QAAC;QAAK;OAAI,CAAC,wCAAwC;IACpE;EACJ;EAEA,OAAO;AACT;AAEA,OAAO,SAAS,eAAe,GAAgB;EAC3C,IAAI,IAAI,CAAC,iBAAiB,OAAO,KAAc;IAC3C,IAAI;MACA,MAAM,QAAQ,sBAAsB;MACpC,MAAM,oBAAoB;MAC1B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;IACzB,EAAE,OAAO,OAAO;MACZ,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC,4BAA4B;IACrD;EACJ;EAEA,IAAI,IAAI,CAAC,eAAe,OAAO,KAAc;IACzC,IAAI;MACA,MAAM,QAAuB;QACzB,KAAK;QACL,WAAW,AAAC,IAAI,OAAQ,OAAO;QAC/B,OAAO;UACH,MAAM;UACN,aAAa;YAAC;YAAG;WAAE,CAAC,uBAAuB;QAC/C;MACJ;MACA,MAAM,oBAAoB;MAC1B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;IACzB,EAAE,OAAO,OAAO;MACZ,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC,4BAA4B;IACrD;EACJ;AAEJ"}
============
Specifier: https://jsr.io/@std/testing/0.225.3/asserts.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
/**
 * A library of assertion functions.
 * If the assertion is false an `AssertionError` will be thrown which will
 * result in pretty-printed diff of failing assertion.
 *
 * This module is browser compatible, but do not rely on good formatting of
 * values for AssertionError messages in browsers.
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 *
 * @module
 */ import * as asserts from "jsr:@std/assert@1.0.0-rc.2";
/**
 * Make an assertion that `actual` and `expected` are almost equal numbers
 * through a given tolerance. It can be used to take into account IEEE-754
 * double-precision floating-point representation limitations. If the values
 * are not almost equal then throw.
 *
 * @example
 * ```ts
 * import { assertAlmostEquals } from "@std/testing/asserts";
 *
 * assertAlmostEquals(0.01, 0.02, 0.1); // Doesn't throw
 * assertAlmostEquals(0.01, 0.02); // Throws
 * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-16); // Doesn't throw
 * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-17); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertAlmostEquals(actual, expected, tolerance = 1e-7, msg) {
  asserts.assertAlmostEquals(actual, expected, tolerance, msg);
}
/**
 * Make an assertion that `actual` includes the `expected` values. If not then
 * an error will be thrown.
 *
 * Type parameter can be specified to ensure values under comparison have the
 * same type.
 *
 * @example
 * ```ts
 * import { assertArrayIncludes } from "@std/testing/asserts";
 *
 * assertArrayIncludes([1, 2], [2]); // Doesn't throw
 * assertArrayIncludes([1, 2], [3]); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertArrayIncludes(actual, expected, msg) {
  asserts.assertArrayIncludes(actual, expected, msg);
}
/**
 * Make an assertion that `actual` and `expected` are equal, deeply. If not
 * deeply equal, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the
 * same type.
 *
 * @example
 * ```ts
 * import { assertEquals } from "@std/testing/asserts";
 *
 * assertEquals("world", "world"); // Doesn't throw
 * assertEquals("hello", "world"); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertEquals(actual, expected, msg) {
  asserts.assertEquals(actual, expected, msg);
}
/**
 * Make an assertion that actual is not null or undefined.
 * If not then throw.
 *
 * @example
 * ```ts
 * import { assertExists } from "@std/testing/asserts";
 *
 * assertExists("something"); // Doesn't throw
 * assertExists(undefined); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertExists(actual, msg) {
  asserts.assertExists(actual, msg);
}
/**
 * Make an assertion, error will be thrown if `expr` have truthy value.
 *
 * @example
 * ```ts
 * import { assertFalse } from "@std/testing/asserts";
 *
 * assertFalse(false); // Doesn't throw
 * assertFalse(true); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertFalse(expr, msg = "") {
  asserts.assertFalse(expr, msg);
}
/**
 * Make an assertion that `actual` is greater than or equal to `expected`.
 * If not then throw.
 *
 * @example
 * ```ts
 * import { assertGreaterOrEqual } from "@std/testing/asserts";
 *
 * assertGreaterOrEqual(2, 1); // Doesn't throw
 * assertGreaterOrEqual(1, 1); // Doesn't throw
 * assertGreaterOrEqual(0, 1); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertGreaterOrEqual(actual, expected, msg) {
  asserts.assertGreaterOrEqual(actual, expected, msg);
}
/**
 * Make an assertion that `actual` is greater than `expected`.
 * If not then throw.
 *
 * @example
 * ```ts
 * import { assertGreater } from "@std/testing/asserts";
 *
 * assertGreater(2, 1); // Doesn't throw
 * assertGreater(1, 1); // Throws
 * assertGreater(0, 1); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertGreater(actual, expected, msg) {
  asserts.assertGreater(actual, expected, msg);
}
/**
 * Make an assertion that `obj` is an instance of `type`.
 * If not then throw.
 *
 * @example
 * ```ts
 * import { assertInstanceOf } from "@std/testing/asserts";
 *
 * assertInstanceOf(new Date(), Date); // Doesn't throw
 * assertInstanceOf(new Date(), Number); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertInstanceOf(actual, expectedType, msg = "") {
  asserts.assertInstanceOf(actual, expectedType, msg);
}
/**
 * Make an assertion that `error` is an `Error`.
 * If not then an error will be thrown.
 * An error class and a string that should be included in the
 * error message can also be asserted.
 *
 * @example
 * ```ts
 * import { assertIsError } from "@std/testing/asserts";
 *
 * assertIsError(null); // Throws
 * assertIsError(new RangeError("Out of range")); // Doesn't throw
 * assertIsError(new RangeError("Out of range"), SyntaxError); // Throws
 * assertIsError(new RangeError("Out of range"), SyntaxError, "Out of range"); // Doesn't throw
 * assertIsError(new RangeError("Out of range"), SyntaxError, "Within range"); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertIsError(error, // deno-lint-ignore no-explicit-any
ErrorClass, msgMatches, msg) {
  asserts.assertIsError(error, ErrorClass, msgMatches, msg);
}
/**
 * Make an assertion that `actual` is less than or equal to `expected`.
 * If not then throw.
 *
 * @example
 * ```ts
 * import { assertLessOrEqual } from "@std/testing/asserts";
 *
 * assertLessOrEqual(1, 2); // Doesn't throw
 * assertLessOrEqual(1, 1); // Doesn't throw
 * assertLessOrEqual(1, 0); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertLessOrEqual(actual, expected, msg) {
  asserts.assertLessOrEqual(actual, expected, msg);
}
/**
 * Make an assertion that `actual` is less than `expected`.
 * If not then throw.
 *
 * @example
 * ```ts
 * import { assertLess } from "@std/testing/asserts";
 *
 * assertLess(1, 2); // Doesn't throw
 * assertLess(2, 1); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertLess(actual, expected, msg) {
  asserts.assertLess(actual, expected, msg);
}
/**
 * Make an assertion that `actual` match RegExp `expected`. If not
 * then throw.
 *
 * @example
 * ```ts
 * import { assertMatch } from "@std/testing/asserts";
 *
 * assertMatch("Raptor", RegExp(/Raptor/)); // Doesn't throw
 * assertMatch("Denosaurus", RegExp(/Raptor/)); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertMatch(actual, expected, msg) {
  asserts.assertMatch(actual, expected, msg);
}
/**
 * Make an assertion that `actual` and `expected` are not equal, deeply.
 * If not then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @example
 * ```ts
 * import { assertNotEquals } from "@std/testing/asserts";
 *
 * assertNotEquals(1, 2); // Doesn't throw
 * assertNotEquals(1, 1); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertNotEquals(actual, expected, msg) {
  asserts.assertNotEquals(actual, expected, msg);
}
/**
 * Make an assertion that `obj` is not an instance of `type`.
 * If so, then throw.
 *
 * @example
 * ```ts
 * import { assertNotInstanceOf } from "@std/testing/asserts";
 *
 * assertNotInstanceOf(new Date(), Number); // Doesn't throw
 * assertNotInstanceOf(new Date(), Date); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertNotInstanceOf(actual, // deno-lint-ignore no-explicit-any
unexpectedType, msg) {
  asserts.assertNotInstanceOf(actual, unexpectedType, msg);
}
/**
 * Make an assertion that `actual` not match RegExp `expected`. If match
 * then throw.
 *
 * @example
 * ```ts
 * import { assertNotMatch } from "@std/testing/asserts";
 *
 * assertNotMatch("Denosaurus", RegExp(/Raptor/)); // Doesn't throw
 * assertNotMatch("Raptor", RegExp(/Raptor/)); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertNotMatch(actual, expected, msg) {
  asserts.assertNotMatch(actual, expected, msg);
}
/**
 * Make an assertion that `actual` and `expected` are not strictly equal.
 * If the values are strictly equal then throw.
 *
 * @example
 * ```ts
 * import { assertNotStrictEquals } from "@std/testing/asserts";
 *
 * assertNotStrictEquals(1, 1); // Doesn't throw
 * assertNotStrictEquals(1, 2); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertNotStrictEquals(actual, expected, msg) {
  asserts.assertNotStrictEquals(actual, expected, msg);
}
/**
 * Make an assertion that `actual` object is a subset of `expected` object,
 * deeply. If not, then throw.
 *
 * @example
 * ```ts
 * import { assertObjectMatch } from "@std/testing/asserts";
 *
 * assertObjectMatch({ foo: "bar" }, { foo: "bar" }); // Doesn't throw
 * assertObjectMatch({ foo: "bar" }, { foo: "baz" }); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertObjectMatch(// deno-lint-ignore no-explicit-any
actual, expected, msg) {
  asserts.assertObjectMatch(actual, expected, msg);
}
export async function assertRejects(fn, errorClassOrMsg, msgIncludesOrMsg, msg) {
  return await asserts.assertRejects(fn, // deno-lint-ignore no-explicit-any
  errorClassOrMsg, msgIncludesOrMsg, msg);
}
/**
 * Make an assertion that `actual` and `expected` are strictly equal. If
 * not then throw.
 *
 * @example
 * ```ts
 * import { assertStrictEquals } from "@std/testing/asserts";
 *
 * const a = {};
 * const b = a;
 * assertStrictEquals(a, b); // Doesn't throw
 *
 * const c = {};
 * const d = {};
 * assertStrictEquals(c, d); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertStrictEquals(actual, expected, msg) {
  asserts.assertStrictEquals(actual, expected, msg);
}
/**
 * Make an assertion that actual includes expected. If not
 * then throw.
 *
 * @example
 * ```ts
 * import { assertStringIncludes } from "@std/testing/asserts";
 *
 * assertStringIncludes("Hello", "ello"); // Doesn't throw
 * assertStringIncludes("Hello", "world"); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assertStringIncludes(actual, expected, msg) {
  asserts.assertStringIncludes(actual, expected, msg);
}
export function assertThrows(fn, errorClassOrMsg, msgIncludesOrMsg, msg) {
  return asserts.assertThrows(fn, // deno-lint-ignore no-explicit-any
  errorClassOrMsg, msgIncludesOrMsg, msg);
}
/**
 * Make an assertion, error will be thrown if `expr` does not have truthy value.
 *
 * @example
 * ```ts
 * import { assert } from "@std/testing/asserts";
 *
 * assert("hello".includes("ello")); // Doesn't throw
 * assert("hello".includes("world")); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function assert(expr, msg = "") {
  asserts.assert(expr, msg);
}
/**
 * Error thrown when an assertion fails.
 *
 * @example
 * ```ts
 * import { AssertionError } from "@std/testing/asserts";
 *
 * throw new AssertionError("Assertion failed");
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export class AssertionError extends Error {
  /** Constructs a new instance. */ constructor(message){
    super(message);
    this.name = "AssertionError";
  }
}
/**
 * Deep equality comparison used in assertions
 * @param c actual value
 * @param d expected value
 *
 * @example
 * ```ts
 * import { equal } from "@std/testing/asserts";
 *
 * equal({ foo: "bar" }, { foo: "bar" }); // Returns `true`
 * equal({ foo: "bar" }, { foo: "baz" }); // Returns `false
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function equal(c, d) {
  return asserts.equal(c, d);
}
/**
 * Forcefully throws a failed assertion.
 *
 * @example
 * ```ts
 * import { fail } from "@std/testing/asserts";
 *
 * fail("Deliberately failed!"); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function fail(msg) {
  asserts.fail(msg);
}
/**
 * Use this to stub out methods that will throw when invoked.
 *
 * @example
 * ```ts
 * import { unimplemented } from "@std/testing/asserts";
 *
 * unimplemented(); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function unimplemented(msg) {
  asserts.unimplemented(msg);
}
/**
 * Use this to assert unreachable code.
 *
 * @example
 * ```ts
 * import { unreachable } from "@std/testing/asserts";
 *
 * unreachable(); // Throws
 * ```
 *
 * @deprecated This will be removed in 1.0.0. Import from
 * {@link https://jsr.io/@std/assert | @std/assert} instead.
 */ export function unreachable() {
  asserts.unreachable();
}

---
{"version":3,"sources":["https://jsr.io/@std/testing/0.225.3/asserts.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\n/**\n * A library of assertion functions.\n * If the assertion is false an `AssertionError` will be thrown which will\n * result in pretty-printed diff of failing assertion.\n *\n * This module is browser compatible, but do not rely on good formatting of\n * values for AssertionError messages in browsers.\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n *\n * @module\n */\nimport * as asserts from \"jsr:@std/assert@1.0.0-rc.2\";\n\n/**\n * Make an assertion that `actual` and `expected` are almost equal numbers\n * through a given tolerance. It can be used to take into account IEEE-754\n * double-precision floating-point representation limitations. If the values\n * are not almost equal then throw.\n *\n * @example\n * ```ts\n * import { assertAlmostEquals } from \"@std/testing/asserts\";\n *\n * assertAlmostEquals(0.01, 0.02, 0.1); // Doesn't throw\n * assertAlmostEquals(0.01, 0.02); // Throws\n * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-16); // Doesn't throw\n * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-17); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertAlmostEquals(\n  actual: number,\n  expected: number,\n  tolerance = 1e-7,\n  msg?: string,\n) {\n  asserts.assertAlmostEquals(actual, expected, tolerance, msg);\n}\n\n/**\n * An array-like object (`Array`, `Uint8Array`, `NodeList`, etc.) that is not a string.\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport type ArrayLikeArg<T> = ArrayLike<T> & object;\n\n/**\n * Make an assertion that `actual` includes the `expected` values. If not then\n * an error will be thrown.\n *\n * Type parameter can be specified to ensure values under comparison have the\n * same type.\n *\n * @example\n * ```ts\n * import { assertArrayIncludes } from \"@std/testing/asserts\";\n *\n * assertArrayIncludes([1, 2], [2]); // Doesn't throw\n * assertArrayIncludes([1, 2], [3]); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertArrayIncludes<T>(\n  actual: ArrayLikeArg<T>,\n  expected: ArrayLikeArg<T>,\n  msg?: string,\n) {\n  asserts.assertArrayIncludes<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` and `expected` are equal, deeply. If not\n * deeply equal, then throw.\n *\n * Type parameter can be specified to ensure values under comparison have the\n * same type.\n *\n * @example\n * ```ts\n * import { assertEquals } from \"@std/testing/asserts\";\n *\n * assertEquals(\"world\", \"world\"); // Doesn't throw\n * assertEquals(\"hello\", \"world\"); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertEquals<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  asserts.assertEquals<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that actual is not null or undefined.\n * If not then throw.\n *\n * @example\n * ```ts\n * import { assertExists } from \"@std/testing/asserts\";\n *\n * assertExists(\"something\"); // Doesn't throw\n * assertExists(undefined); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertExists<T>(\n  actual: T,\n  msg?: string,\n): asserts actual is NonNullable<T> {\n  asserts.assertExists<T>(actual, msg);\n}\n\n/**\n * Assertion condition for {@linkcode assertFalse}.\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport type Falsy = false | 0 | 0n | \"\" | null | undefined;\n\n/**\n * Make an assertion, error will be thrown if `expr` have truthy value.\n *\n * @example\n * ```ts\n * import { assertFalse } from \"@std/testing/asserts\";\n *\n * assertFalse(false); // Doesn't throw\n * assertFalse(true); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertFalse(expr: unknown, msg = \"\"): asserts expr is Falsy {\n  asserts.assertFalse(expr, msg);\n}\n\n/**\n * Make an assertion that `actual` is greater than or equal to `expected`.\n * If not then throw.\n *\n * @example\n * ```ts\n * import { assertGreaterOrEqual } from \"@std/testing/asserts\";\n *\n * assertGreaterOrEqual(2, 1); // Doesn't throw\n * assertGreaterOrEqual(1, 1); // Doesn't throw\n * assertGreaterOrEqual(0, 1); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertGreaterOrEqual<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  asserts.assertGreaterOrEqual<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` is greater than `expected`.\n * If not then throw.\n *\n * @example\n * ```ts\n * import { assertGreater } from \"@std/testing/asserts\";\n *\n * assertGreater(2, 1); // Doesn't throw\n * assertGreater(1, 1); // Throws\n * assertGreater(0, 1); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertGreater<T>(actual: T, expected: T, msg?: string) {\n  asserts.assertGreater<T>(actual, expected, msg);\n}\n\n/**\n * Any constructor\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\n// deno-lint-ignore no-explicit-any\nexport type AnyConstructor = new (...args: any[]) => any;\n/** Gets constructor type\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport type GetConstructorType<T extends AnyConstructor> = T extends // deno-lint-ignore no-explicit-any\nnew (...args: any) => infer C ? C\n  : never;\n\n/**\n * Make an assertion that `obj` is an instance of `type`.\n * If not then throw.\n *\n * @example\n * ```ts\n * import { assertInstanceOf } from \"@std/testing/asserts\";\n *\n * assertInstanceOf(new Date(), Date); // Doesn't throw\n * assertInstanceOf(new Date(), Number); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertInstanceOf<T extends AnyConstructor>(\n  actual: unknown,\n  expectedType: T,\n  msg = \"\",\n): asserts actual is GetConstructorType<T> {\n  asserts.assertInstanceOf<T>(actual, expectedType, msg);\n}\n\n/**\n * Make an assertion that `error` is an `Error`.\n * If not then an error will be thrown.\n * An error class and a string that should be included in the\n * error message can also be asserted.\n *\n * @example\n * ```ts\n * import { assertIsError } from \"@std/testing/asserts\";\n *\n * assertIsError(null); // Throws\n * assertIsError(new RangeError(\"Out of range\")); // Doesn't throw\n * assertIsError(new RangeError(\"Out of range\"), SyntaxError); // Throws\n * assertIsError(new RangeError(\"Out of range\"), SyntaxError, \"Out of range\"); // Doesn't throw\n * assertIsError(new RangeError(\"Out of range\"), SyntaxError, \"Within range\"); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertIsError<E extends Error = Error>(\n  error: unknown,\n  // deno-lint-ignore no-explicit-any\n  ErrorClass?: new (...args: any[]) => E,\n  msgMatches?: string | RegExp,\n  msg?: string,\n): asserts error is E {\n  asserts.assertIsError<E>(error, ErrorClass, msgMatches, msg);\n}\n\n/**\n * Make an assertion that `actual` is less than or equal to `expected`.\n * If not then throw.\n *\n * @example\n * ```ts\n * import { assertLessOrEqual } from \"@std/testing/asserts\";\n *\n * assertLessOrEqual(1, 2); // Doesn't throw\n * assertLessOrEqual(1, 1); // Doesn't throw\n * assertLessOrEqual(1, 0); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertLessOrEqual<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  asserts.assertLessOrEqual<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` is less than `expected`.\n * If not then throw.\n *\n * @example\n * ```ts\n * import { assertLess } from \"@std/testing/asserts\";\n *\n * assertLess(1, 2); // Doesn't throw\n * assertLess(2, 1); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertLess<T>(actual: T, expected: T, msg?: string) {\n  asserts.assertLess<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` match RegExp `expected`. If not\n * then throw.\n *\n * @example\n * ```ts\n * import { assertMatch } from \"@std/testing/asserts\";\n *\n * assertMatch(\"Raptor\", RegExp(/Raptor/)); // Doesn't throw\n * assertMatch(\"Denosaurus\", RegExp(/Raptor/)); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertMatch(\n  actual: string,\n  expected: RegExp,\n  msg?: string,\n) {\n  asserts.assertMatch(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` and `expected` are not equal, deeply.\n * If not then throw.\n *\n * Type parameter can be specified to ensure values under comparison have the same type.\n *\n * @example\n * ```ts\n * import { assertNotEquals } from \"@std/testing/asserts\";\n *\n * assertNotEquals(1, 2); // Doesn't throw\n * assertNotEquals(1, 1); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertNotEquals<T>(actual: T, expected: T, msg?: string) {\n  asserts.assertNotEquals<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `obj` is not an instance of `type`.\n * If so, then throw.\n *\n * @example\n * ```ts\n * import { assertNotInstanceOf } from \"@std/testing/asserts\";\n *\n * assertNotInstanceOf(new Date(), Number); // Doesn't throw\n * assertNotInstanceOf(new Date(), Date); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertNotInstanceOf<A, T>(\n  actual: A,\n  // deno-lint-ignore no-explicit-any\n  unexpectedType: new (...args: any[]) => T,\n  msg?: string,\n): asserts actual is Exclude<A, T> {\n  asserts.assertNotInstanceOf<A, T>(actual, unexpectedType, msg);\n}\n\n/**\n * Make an assertion that `actual` not match RegExp `expected`. If match\n * then throw.\n *\n * @example\n * ```ts\n * import { assertNotMatch } from \"@std/testing/asserts\";\n *\n * assertNotMatch(\"Denosaurus\", RegExp(/Raptor/)); // Doesn't throw\n * assertNotMatch(\"Raptor\", RegExp(/Raptor/)); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertNotMatch(\n  actual: string,\n  expected: RegExp,\n  msg?: string,\n) {\n  asserts.assertNotMatch(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` and `expected` are not strictly equal.\n * If the values are strictly equal then throw.\n *\n * @example\n * ```ts\n * import { assertNotStrictEquals } from \"@std/testing/asserts\";\n *\n * assertNotStrictEquals(1, 1); // Doesn't throw\n * assertNotStrictEquals(1, 2); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertNotStrictEquals<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  asserts.assertNotStrictEquals(actual, expected, msg);\n}\n\n/**\n * Make an assertion that `actual` object is a subset of `expected` object,\n * deeply. If not, then throw.\n *\n * @example\n * ```ts\n * import { assertObjectMatch } from \"@std/testing/asserts\";\n *\n * assertObjectMatch({ foo: \"bar\" }, { foo: \"bar\" }); // Doesn't throw\n * assertObjectMatch({ foo: \"bar\" }, { foo: \"baz\" }); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertObjectMatch(\n  // deno-lint-ignore no-explicit-any\n  actual: Record<PropertyKey, any>,\n  expected: Record<PropertyKey, unknown>,\n  msg?: string,\n) {\n  asserts.assertObjectMatch(actual, expected, msg);\n}\n\n/**\n * Executes a function which returns a promise, expecting it to reject.\n *\n * @example\n * ```ts\n * import { assertRejects } from \"@std/testing/asserts\";\n *\n * await assertRejects(async () => Promise.reject(new Error())); // Doesn't throw\n * await assertRejects(async () => console.log(\"Hello world\")); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertRejects(\n  fn: () => PromiseLike<unknown>,\n  msg?: string,\n): Promise<unknown>;\n/**\n * Executes a function which returns a promise, expecting it to reject.\n * If it does not, then it throws. An error class and a string that should be\n * included in the error message can also be asserted.\n *\n * @example\n * ```ts\n * import { assertRejects } from \"@std/testing/asserts\";\n *\n * await assertRejects(async () => Promise.reject(new Error()), Error); // Doesn't throw\n * await assertRejects(async () => Promise.reject(new Error()), SyntaxError); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertRejects<E extends Error = Error>(\n  fn: () => PromiseLike<unknown>,\n  // deno-lint-ignore no-explicit-any\n  ErrorClass: new (...args: any[]) => E,\n  msgIncludes?: string,\n  msg?: string,\n): Promise<E>;\nexport async function assertRejects<E extends Error = Error>(\n  fn: () => PromiseLike<unknown>,\n  errorClassOrMsg?:\n    // deno-lint-ignore no-explicit-any\n    | (new (...args: any[]) => E)\n    | string,\n  msgIncludesOrMsg?: string,\n  msg?: string,\n): Promise<E | Error | unknown> {\n  return await asserts.assertRejects<E>(\n    fn,\n    // deno-lint-ignore no-explicit-any\n    errorClassOrMsg as new (...args: any[]) => E, // Cast errorClassOrMsg to the correct type\n    msgIncludesOrMsg,\n    msg,\n  );\n}\n\n/**\n * Make an assertion that `actual` and `expected` are strictly equal. If\n * not then throw.\n *\n * @example\n * ```ts\n * import { assertStrictEquals } from \"@std/testing/asserts\";\n *\n * const a = {};\n * const b = a;\n * assertStrictEquals(a, b); // Doesn't throw\n *\n * const c = {};\n * const d = {};\n * assertStrictEquals(c, d); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertStrictEquals<T>(\n  actual: unknown,\n  expected: T,\n  msg?: string,\n): asserts actual is T {\n  asserts.assertStrictEquals<T>(actual, expected, msg);\n}\n\n/**\n * Make an assertion that actual includes expected. If not\n * then throw.\n *\n * @example\n * ```ts\n * import { assertStringIncludes } from \"@std/testing/asserts\";\n *\n * assertStringIncludes(\"Hello\", \"ello\"); // Doesn't throw\n * assertStringIncludes(\"Hello\", \"world\"); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertStringIncludes(\n  actual: string,\n  expected: string,\n  msg?: string,\n) {\n  asserts.assertStringIncludes(actual, expected, msg);\n}\n\n/**\n * Executes a function, expecting it to throw. If it does not, then it\n * throws.\n *\n * @example\n * ```ts\n * import { assertThrows } from \"@std/testing/asserts\";\n *\n * assertThrows(() => { throw new TypeError(\"hello world!\"); }); // Doesn't throw\n * assertThrows(() => console.log(\"hello world!\")); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertThrows(\n  fn: () => unknown,\n  msg?: string,\n): unknown;\n/**\n * Executes a function, expecting it to throw. If it does not, then it\n * throws. An error class and a string that should be included in the\n * error message can also be asserted.\n *\n * @example\n * ```ts\n * import { assertThrows } from \"@std/testing/asserts\";\n *\n * assertThrows(() => { throw new TypeError(\"hello world!\"); }, TypeError); // Doesn't throw\n * assertThrows(() => { throw new TypeError(\"hello world!\"); }, RangeError); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assertThrows<E extends Error = Error>(\n  fn: () => unknown,\n  // deno-lint-ignore no-explicit-any\n  ErrorClass: new (...args: any[]) => E,\n  msgIncludes?: string,\n  msg?: string,\n): E;\nexport function assertThrows<E extends Error = Error>(\n  fn: () => unknown,\n  errorClassOrMsg?:\n    // deno-lint-ignore no-explicit-any\n    | (new (...args: any[]) => E)\n    | string,\n  msgIncludesOrMsg?: string,\n  msg?: string,\n): E | Error | unknown {\n  return asserts.assertThrows<E>(\n    fn,\n    // deno-lint-ignore no-explicit-any\n    errorClassOrMsg as new (...args: any[]) => E, // Cast errorClassOrMsg to the correct type\n    msgIncludesOrMsg,\n    msg,\n  );\n}\n\n/**\n * Make an assertion, error will be thrown if `expr` does not have truthy value.\n *\n * @example\n * ```ts\n * import { assert } from \"@std/testing/asserts\";\n *\n * assert(\"hello\".includes(\"ello\")); // Doesn't throw\n * assert(\"hello\".includes(\"world\")); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function assert(expr: unknown, msg = \"\"): asserts expr {\n  asserts.assert(expr, msg);\n}\n\n/**\n * Error thrown when an assertion fails.\n *\n * @example\n * ```ts\n * import { AssertionError } from \"@std/testing/asserts\";\n *\n * throw new AssertionError(\"Assertion failed\");\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport class AssertionError extends Error {\n  /** Constructs a new instance. */\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionError\";\n  }\n}\n\n/**\n * Deep equality comparison used in assertions\n * @param c actual value\n * @param d expected value\n *\n * @example\n * ```ts\n * import { equal } from \"@std/testing/asserts\";\n *\n * equal({ foo: \"bar\" }, { foo: \"bar\" }); // Returns `true`\n * equal({ foo: \"bar\" }, { foo: \"baz\" }); // Returns `false\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function equal(c: unknown, d: unknown): boolean {\n  return asserts.equal(c, d);\n}\n\n/**\n * Forcefully throws a failed assertion.\n *\n * @example\n * ```ts\n * import { fail } from \"@std/testing/asserts\";\n *\n * fail(\"Deliberately failed!\"); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function fail(msg?: string): never {\n  asserts.fail(msg);\n}\n\n/**\n * Use this to stub out methods that will throw when invoked.\n *\n * @example\n * ```ts\n * import { unimplemented } from \"@std/testing/asserts\";\n *\n * unimplemented(); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function unimplemented(msg?: string): never {\n  asserts.unimplemented(msg);\n}\n\n/**\n * Use this to assert unreachable code.\n *\n * @example\n * ```ts\n * import { unreachable } from \"@std/testing/asserts\";\n *\n * unreachable(); // Throws\n * ```\n *\n * @deprecated This will be removed in 1.0.0. Import from\n * {@link https://jsr.io/@std/assert | @std/assert} instead.\n */\nexport function unreachable(): never {\n  asserts.unreachable();\n}\n"],"names":[],"mappings":"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"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/mod.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/** A library of assertion functions.
 * If the assertion is false an `AssertionError` will be thrown which will
 * result in pretty-printed diff of failing assertion.
 *
 * This module is browser compatible, but do not rely on good formatting of
 * values for AssertionError messages in browsers.
 *
 * ```ts no-eval
 * import { assert } from "@std/assert/assert";
 *
 * assert("I am truthy"); // Doesn't throw
 * assert(false); // Throws `AssertionError`
 * ```
 *
 * @module
 */ export * from "./assert_almost_equals.ts";
export * from "./assert_array_includes.ts";
export * from "./assert_equals.ts";
export * from "./assert_exists.ts";
export * from "./assert_false.ts";
export * from "./assert_greater_or_equal.ts";
export * from "./assert_greater.ts";
export * from "./assert_instance_of.ts";
export * from "./assert_is_error.ts";
export * from "./assert_less_or_equal.ts";
export * from "./assert_less.ts";
export * from "./assert_match.ts";
export * from "./assert_not_equals.ts";
export * from "./assert_not_instance_of.ts";
export * from "./assert_not_match.ts";
export * from "./assert_not_strict_equals.ts";
export * from "./assert_object_match.ts";
export * from "./assert_rejects.ts";
export * from "./assert_strict_equals.ts";
export * from "./assert_string_includes.ts";
export * from "./assert_throws.ts";
export * from "./assert.ts";
export * from "./assertion_error.ts";
export * from "./equal.ts";
export * from "./fail.ts";
export * from "./unimplemented.ts";
export * from "./unreachable.ts";

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/mod.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/** A library of assertion functions.\n * If the assertion is false an `AssertionError` will be thrown which will\n * result in pretty-printed diff of failing assertion.\n *\n * This module is browser compatible, but do not rely on good formatting of\n * values for AssertionError messages in browsers.\n *\n * ```ts no-eval\n * import { assert } from \"@std/assert/assert\";\n *\n * assert(\"I am truthy\"); // Doesn't throw\n * assert(false); // Throws `AssertionError`\n * ```\n *\n * @module\n */\n\nexport * from \"./assert_almost_equals.ts\";\nexport * from \"./assert_array_includes.ts\";\nexport * from \"./assert_equals.ts\";\nexport * from \"./assert_exists.ts\";\nexport * from \"./assert_false.ts\";\nexport * from \"./assert_greater_or_equal.ts\";\nexport * from \"./assert_greater.ts\";\nexport * from \"./assert_instance_of.ts\";\nexport * from \"./assert_is_error.ts\";\nexport * from \"./assert_less_or_equal.ts\";\nexport * from \"./assert_less.ts\";\nexport * from \"./assert_match.ts\";\nexport * from \"./assert_not_equals.ts\";\nexport * from \"./assert_not_instance_of.ts\";\nexport * from \"./assert_not_match.ts\";\nexport * from \"./assert_not_strict_equals.ts\";\nexport * from \"./assert_object_match.ts\";\nexport * from \"./assert_rejects.ts\";\nexport * from \"./assert_strict_equals.ts\";\nexport * from \"./assert_string_includes.ts\";\nexport * from \"./assert_throws.ts\";\nexport * from \"./assert.ts\";\nexport * from \"./assertion_error.ts\";\nexport * from \"./equal.ts\";\nexport * from \"./fail.ts\";\nexport * from \"./unimplemented.ts\";\nexport * from \"./unreachable.ts\";\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC;;;;;;;;;;;;;;;CAeC,GAED,cAAc,4BAA4B;AAC1C,cAAc,6BAA6B;AAC3C,cAAc,qBAAqB;AACnC,cAAc,qBAAqB;AACnC,cAAc,oBAAoB;AAClC,cAAc,+BAA+B;AAC7C,cAAc,sBAAsB;AACpC,cAAc,0BAA0B;AACxC,cAAc,uBAAuB;AACrC,cAAc,4BAA4B;AAC1C,cAAc,mBAAmB;AACjC,cAAc,oBAAoB;AAClC,cAAc,yBAAyB;AACvC,cAAc,8BAA8B;AAC5C,cAAc,wBAAwB;AACtC,cAAc,gCAAgC;AAC9C,cAAc,2BAA2B;AACzC,cAAc,sBAAsB;AACpC,cAAc,4BAA4B;AAC1C,cAAc,8BAA8B;AAC5C,cAAc,qBAAqB;AACnC,cAAc,cAAc;AAC5B,cAAc,uBAAuB;AACrC,cAAc,aAAa;AAC3B,cAAc,YAAY;AAC1B,cAAc,qBAAqB;AACnC,cAAc,mBAAmB"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_almost_equals.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` and `expected` are almost equal numbers
 * through a given tolerance. It can be used to take into account IEEE-754
 * double-precision floating-point representation limitations. If the values
 * are not almost equal then throw.
 *
 * The default tolerance is one hundred thousandth of a percent of the
 * expected value.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertAlmostEquals } from "@std/assert";
 *
 * assertAlmostEquals(0.01, 0.02); // Throws
 * assertAlmostEquals(1e-8, 1e-9); // Throws
 * assertAlmostEquals(1.000000001e-8, 1.000000002e-8); // Doesn't throw
 * assertAlmostEquals(0.01, 0.02, 0.1); // Doesn't throw
 * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-16); // Doesn't throw
 * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-17); // Throws
 * ```
 *
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param tolerance The tolerance to consider the values almost equal. The
 * default is one hundred thousandth of a percent of the expected value.
 * @param msg The optional message to include in the error.
 */ export function assertAlmostEquals(actual, expected, tolerance, msg) {
  if (Object.is(actual, expected)) {
    return;
  }
  const delta = Math.abs(expected - actual);
  if (tolerance === undefined) {
    tolerance = isFinite(expected) ? Math.abs(expected * 1e-7) : 1e-7;
  }
  if (delta <= tolerance) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  const f = (n)=>Number.isInteger(n) ? n : n.toExponential();
  throw new AssertionError(`Expected actual: "${f(actual)}" to be close to "${f(expected)}": \
delta "${f(delta)}" is greater than "${f(tolerance)}"${msgSuffix}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_almost_equals.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` and `expected` are almost equal numbers\n * through a given tolerance. It can be used to take into account IEEE-754\n * double-precision floating-point representation limitations. If the values\n * are not almost equal then throw.\n *\n * The default tolerance is one hundred thousandth of a percent of the\n * expected value.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertAlmostEquals } from \"@std/assert\";\n *\n * assertAlmostEquals(0.01, 0.02); // Throws\n * assertAlmostEquals(1e-8, 1e-9); // Throws\n * assertAlmostEquals(1.000000001e-8, 1.000000002e-8); // Doesn't throw\n * assertAlmostEquals(0.01, 0.02, 0.1); // Doesn't throw\n * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-16); // Doesn't throw\n * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-17); // Throws\n * ```\n *\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param tolerance The tolerance to consider the values almost equal. The\n * default is one hundred thousandth of a percent of the expected value.\n * @param msg The optional message to include in the error.\n */\nexport function assertAlmostEquals(\n  actual: number,\n  expected: number,\n  tolerance?: number,\n  msg?: string,\n) {\n  if (Object.is(actual, expected)) {\n    return;\n  }\n  const delta = Math.abs(expected - actual);\n  if (tolerance === undefined) {\n    tolerance = isFinite(expected) ? Math.abs(expected * 1e-7) : 1e-7;\n  }\n  if (delta <= tolerance) {\n    return;\n  }\n\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  const f = (n: number) => Number.isInteger(n) ? n : n.toExponential();\n  throw new AssertionError(\n    `Expected actual: \"${f(actual)}\" to be close to \"${f(expected)}\": \\\ndelta \"${f(delta)}\" is greater than \"${f(tolerance)}\"${msgSuffix}`,\n  );\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BC,GACD,OAAO,SAAS,mBACd,MAAc,EACd,QAAgB,EAChB,SAAkB,EAClB,GAAY;EAEZ,IAAI,OAAO,EAAE,CAAC,QAAQ,WAAW;IAC/B;EACF;EACA,MAAM,QAAQ,KAAK,GAAG,CAAC,WAAW;EAClC,IAAI,cAAc,WAAW;IAC3B,YAAY,SAAS,YAAY,KAAK,GAAG,CAAC,WAAW,QAAQ;EAC/D;EACA,IAAI,SAAS,WAAW;IACtB;EACF;EAEA,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,IAAI,CAAC,IAAc,OAAO,SAAS,CAAC,KAAK,IAAI,EAAE,aAAa;EAClE,MAAM,IAAI,eACR,CAAC,kBAAkB,EAAE,EAAE,QAAQ,kBAAkB,EAAE,EAAE,UAAU;OAC5D,EAAE,EAAE,OAAO,mBAAmB,EAAE,EAAE,WAAW,CAAC,EAAE,UAAU,CAAC;AAElE"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assertion_error.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Error thrown when an assertion fails.
 *
 * @example Usage
 * ```ts no-eval
 * import { AssertionError } from "@std/assert/assertion-error";
 *
 * throw new AssertionError("Assertion failed");
 * ```
 */ export class AssertionError extends Error {
  /** Constructs a new instance.
   *
   * @example Usage
   * ```ts no-eval
   * import { AssertionError } from "@std/assert/assertion-error";
   *
   * throw new AssertionError("Assertion failed");
   * ```
   *
   * @param message The error message.
   */ constructor(message){
    super(message);
    this.name = "AssertionError";
  }
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assertion_error.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Error thrown when an assertion fails.\n *\n * @example Usage\n * ```ts no-eval\n * import { AssertionError } from \"@std/assert/assertion-error\";\n *\n * throw new AssertionError(\"Assertion failed\");\n * ```\n */\nexport class AssertionError extends Error {\n  /** Constructs a new instance.\n   *\n   * @example Usage\n   * ```ts no-eval\n   * import { AssertionError } from \"@std/assert/assertion-error\";\n   *\n   * throw new AssertionError(\"Assertion failed\");\n   * ```\n   *\n   * @param message The error message.\n   */\n  constructor(message: string) {\n    super(message);\n    this.name = \"AssertionError\";\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC;;;;;;;;;CASC,GACD,OAAO,MAAM,uBAAuB;EAClC;;;;;;;;;;GAUC,GACD,YAAY,OAAe,CAAE;IAC3B,KAAK,CAAC;IACN,IAAI,CAAC,IAAI,GAAG;EACd;AACF"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_array_includes.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { equal } from "./equal.ts";
import { format } from "jsr:/@std/internal@^1.0.0/format";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` includes the `expected` values. If not then
 * an error will be thrown.
 *
 * Type parameter can be specified to ensure values under comparison have the
 * same type.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertArrayIncludes } from "@std/assert/assert-array-includes";
 *
 * assertArrayIncludes([1, 2], [2]); // Doesn't throw
 * assertArrayIncludes([1, 2], [3]); // Throws
 * ```
 *
 * @typeParam T The type of the elements in the array to compare.
 * @param actual The array-like object to check for.
 * @param expected The array-like object to check for.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertArrayIncludes(actual, expected, msg) {
  const missing = [];
  for(let i = 0; i < expected.length; i++){
    let found = false;
    for(let j = 0; j < actual.length; j++){
      if (equal(expected[i], actual[j])) {
        found = true;
        break;
      }
    }
    if (!found) {
      missing.push(expected[i]);
    }
  }
  if (missing.length === 0) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  msg = `Expected actual: "${format(actual)}" to include: "${format(expected)}"${msgSuffix}\nmissing: ${format(missing)}`;
  throw new AssertionError(msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_array_includes.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { equal } from \"./equal.ts\";\nimport { format } from \"jsr:/@std/internal@^1.0.0/format\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/** An array-like object (`Array`, `Uint8Array`, `NodeList`, etc.) that is not a string */\nexport type ArrayLikeArg<T> = ArrayLike<T> & object;\n\n/**\n * Make an assertion that `actual` includes the `expected` values. If not then\n * an error will be thrown.\n *\n * Type parameter can be specified to ensure values under comparison have the\n * same type.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertArrayIncludes } from \"@std/assert/assert-array-includes\";\n *\n * assertArrayIncludes([1, 2], [2]); // Doesn't throw\n * assertArrayIncludes([1, 2], [3]); // Throws\n * ```\n *\n * @typeParam T The type of the elements in the array to compare.\n * @param actual The array-like object to check for.\n * @param expected The array-like object to check for.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertArrayIncludes<T>(\n  actual: ArrayLikeArg<T>,\n  expected: ArrayLikeArg<T>,\n  msg?: string,\n) {\n  const missing: unknown[] = [];\n  for (let i = 0; i < expected.length; i++) {\n    let found = false;\n    for (let j = 0; j < actual.length; j++) {\n      if (equal(expected[i], actual[j])) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      missing.push(expected[i]);\n    }\n  }\n  if (missing.length === 0) {\n    return;\n  }\n\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  msg = `Expected actual: \"${format(actual)}\" to include: \"${\n    format(expected)\n  }\"${msgSuffix}\\nmissing: ${format(missing)}`;\n  throw new AssertionError(msg);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,KAAK,QAAQ,aAAa;AACnC,SAAS,MAAM,QAAQ,mCAAmC;AAC1D,SAAS,cAAc,QAAQ,uBAAuB;AAKtD;;;;;;;;;;;;;;;;;;;CAmBC,GACD,OAAO,SAAS,oBACd,MAAuB,EACvB,QAAyB,EACzB,GAAY;EAEZ,MAAM,UAAqB,EAAE;EAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;IACxC,IAAI,QAAQ;IACZ,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;MACtC,IAAI,MAAM,QAAQ,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,GAAG;QACjC,QAAQ;QACR;MACF;IACF;IACA,IAAI,CAAC,OAAO;MACV,QAAQ,IAAI,CAAC,QAAQ,CAAC,EAAE;IAC1B;EACF;EACA,IAAI,QAAQ,MAAM,KAAK,GAAG;IACxB;EACF;EAEA,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,CAAC,kBAAkB,EAAE,OAAO,QAAQ,eAAe,EACvD,OAAO,UACR,CAAC,EAAE,UAAU,WAAW,EAAE,OAAO,SAAS,CAAC;EAC5C,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/equal.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
function isKeyedCollection(x) {
  return [
    Symbol.iterator,
    "size"
  ].every((k)=>k in x);
}
function constructorsEqual(a, b) {
  return a.constructor === b.constructor || a.constructor === Object && !b.constructor || !a.constructor && b.constructor === Object;
}
/**
 * Deep equality comparison used in assertions
 *
 * @param c The actual value
 * @param d The expected value
 * @returns `true` if the values are deeply equal, `false` otherwise
 *
 * @example Usage
 * ```ts
 * import { equal } from "@std/assert/equal";
 *
 * equal({ foo: "bar" }, { foo: "bar" }); // Returns `true`
 * equal({ foo: "bar" }, { foo: "baz" }); // Returns `false
 * ```
 */ export function equal(c, d) {
  const seen = new Map();
  return function compare(a, b) {
    // Have to render RegExp & Date for string comparison
    // unless it's mistreated as object
    if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
      return String(a) === String(b);
    }
    if (a instanceof Date && b instanceof Date) {
      const aTime = a.getTime();
      const bTime = b.getTime();
      // Check for NaN equality manually since NaN is not
      // equal to itself.
      if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
        return true;
      }
      return aTime === bTime;
    }
    if (typeof a === "number" && typeof b === "number") {
      return Number.isNaN(a) && Number.isNaN(b) || a === b;
    }
    if (Object.is(a, b)) {
      return true;
    }
    if (a && typeof a === "object" && b && typeof b === "object") {
      if (a && b && !constructorsEqual(a, b)) {
        return false;
      }
      if (a instanceof WeakMap || b instanceof WeakMap) {
        if (!(a instanceof WeakMap && b instanceof WeakMap)) return false;
        throw new TypeError("cannot compare WeakMap instances");
      }
      if (a instanceof WeakSet || b instanceof WeakSet) {
        if (!(a instanceof WeakSet && b instanceof WeakSet)) return false;
        throw new TypeError("cannot compare WeakSet instances");
      }
      if (a instanceof WeakRef || b instanceof WeakRef) {
        if (!(a instanceof WeakRef && b instanceof WeakRef)) return false;
        return compare(a.deref(), b.deref());
      }
      if (seen.get(a) === b) {
        return true;
      }
      if (Object.keys(a).length !== Object.keys(b).length) {
        return false;
      }
      seen.set(a, b);
      if (isKeyedCollection(a) && isKeyedCollection(b)) {
        if (a.size !== b.size) {
          return false;
        }
        let unmatchedEntries = a.size;
        for (const [aKey, aValue] of a.entries()){
          for (const [bKey, bValue] of b.entries()){
            /* Given that Map keys can be references, we need
             * to ensure that they are also deeply equal */ if (aKey === aValue && bKey === bValue && compare(aKey, bKey) || compare(aKey, bKey) && compare(aValue, bValue)) {
              unmatchedEntries--;
              break;
            }
          }
        }
        return unmatchedEntries === 0;
      }
      const merged = {
        ...a,
        ...b
      };
      for (const key of [
        ...Object.getOwnPropertyNames(merged),
        ...Object.getOwnPropertySymbols(merged)
      ]){
        if (!compare(a && a[key], b && b[key])) {
          return false;
        }
        if (key in a && !(key in b) || key in b && !(key in a)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }(c, d);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/equal.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction isKeyedCollection(x: unknown): x is Set<unknown> {\n  return [Symbol.iterator, \"size\"].every((k) => k in (x as Set<unknown>));\n}\n\nfunction constructorsEqual(a: object, b: object) {\n  return a.constructor === b.constructor ||\n    a.constructor === Object && !b.constructor ||\n    !a.constructor && b.constructor === Object;\n}\n\n/**\n * Deep equality comparison used in assertions\n *\n * @param c The actual value\n * @param d The expected value\n * @returns `true` if the values are deeply equal, `false` otherwise\n *\n * @example Usage\n * ```ts\n * import { equal } from \"@std/assert/equal\";\n *\n * equal({ foo: \"bar\" }, { foo: \"bar\" }); // Returns `true`\n * equal({ foo: \"bar\" }, { foo: \"baz\" }); // Returns `false\n * ```\n */\nexport function equal(c: unknown, d: unknown): boolean {\n  const seen = new Map();\n  return (function compare(a: unknown, b: unknown): boolean {\n    // Have to render RegExp & Date for string comparison\n    // unless it's mistreated as object\n    if (\n      a &&\n      b &&\n      ((a instanceof RegExp && b instanceof RegExp) ||\n        (a instanceof URL && b instanceof URL))\n    ) {\n      return String(a) === String(b);\n    }\n    if (a instanceof Date && b instanceof Date) {\n      const aTime = a.getTime();\n      const bTime = b.getTime();\n      // Check for NaN equality manually since NaN is not\n      // equal to itself.\n      if (Number.isNaN(aTime) && Number.isNaN(bTime)) {\n        return true;\n      }\n      return aTime === bTime;\n    }\n    if (typeof a === \"number\" && typeof b === \"number\") {\n      return Number.isNaN(a) && Number.isNaN(b) || a === b;\n    }\n    if (Object.is(a, b)) {\n      return true;\n    }\n    if (a && typeof a === \"object\" && b && typeof b === \"object\") {\n      if (a && b && !constructorsEqual(a, b)) {\n        return false;\n      }\n      if (a instanceof WeakMap || b instanceof WeakMap) {\n        if (!(a instanceof WeakMap && b instanceof WeakMap)) return false;\n        throw new TypeError(\"cannot compare WeakMap instances\");\n      }\n      if (a instanceof WeakSet || b instanceof WeakSet) {\n        if (!(a instanceof WeakSet && b instanceof WeakSet)) return false;\n        throw new TypeError(\"cannot compare WeakSet instances\");\n      }\n      if (a instanceof WeakRef || b instanceof WeakRef) {\n        if (!(a instanceof WeakRef && b instanceof WeakRef)) return false;\n        return compare(a.deref(), b.deref());\n      }\n      if (seen.get(a) === b) {\n        return true;\n      }\n      if (Object.keys(a).length !== Object.keys(b).length) {\n        return false;\n      }\n      seen.set(a, b);\n      if (isKeyedCollection(a) && isKeyedCollection(b)) {\n        if (a.size !== b.size) {\n          return false;\n        }\n\n        let unmatchedEntries = a.size;\n\n        for (const [aKey, aValue] of a.entries()) {\n          for (const [bKey, bValue] of b.entries()) {\n            /* Given that Map keys can be references, we need\n             * to ensure that they are also deeply equal */\n            if (\n              (aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||\n              (compare(aKey, bKey) && compare(aValue, bValue))\n            ) {\n              unmatchedEntries--;\n              break;\n            }\n          }\n        }\n\n        return unmatchedEntries === 0;\n      }\n      const merged = { ...a, ...b };\n      for (\n        const key of [\n          ...Object.getOwnPropertyNames(merged),\n          ...Object.getOwnPropertySymbols(merged),\n        ]\n      ) {\n        type Key = keyof typeof merged;\n        if (!compare(a && a[key as Key], b && b[key as Key])) {\n          return false;\n        }\n        if (((key in a) && (!(key in b))) || ((key in b) && (!(key in a)))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  })(c, d);\n}\n"],"names":[],"mappings":"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"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/format.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Converts the input into a string. Objects, Sets and Maps are sorted so as to
 * make tests less flaky.
 *
 * @param v Value to be formatted
 *
 * @returns The formatted string
 *
 * @example Usage
 * ```ts
 * import { format } from "@std/internal/format";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(format({ a: 1, b: 2 }), "{\n  a: 1,\n  b: 2,\n}");
 * assertEquals(format(new Set([1, 2])), "Set(2) {\n  1,\n  2,\n}");
 * assertEquals(format(new Map([[1, 2]])), "Map(1) {\n  1 => 2,\n}");
 * ```
 */ export function format(v) {
  // deno-lint-ignore no-explicit-any
  const { Deno } = globalThis;
  return typeof Deno?.inspect === "function" ? Deno.inspect(v, {
    depth: Infinity,
    sorted: true,
    trailingComma: true,
    compact: false,
    iterableLimit: Infinity,
    // getters should be true in assertEquals.
    getters: true,
    strAbbreviateSize: Infinity
  }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}

---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/format.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * Converts the input into a string. Objects, Sets and Maps are sorted so as to\n * make tests less flaky.\n *\n * @param v Value to be formatted\n *\n * @returns The formatted string\n *\n * @example Usage\n * ```ts\n * import { format } from \"@std/internal/format\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(format({ a: 1, b: 2 }), \"{\\n  a: 1,\\n  b: 2,\\n}\");\n * assertEquals(format(new Set([1, 2])), \"Set(2) {\\n  1,\\n  2,\\n}\");\n * assertEquals(format(new Map([[1, 2]])), \"Map(1) {\\n  1 => 2,\\n}\");\n * ```\n */\nexport function format(v: unknown): string {\n  // deno-lint-ignore no-explicit-any\n  const { Deno } = globalThis as any;\n  return typeof Deno?.inspect === \"function\"\n    ? Deno.inspect(v, {\n      depth: Infinity,\n      sorted: true,\n      trailingComma: true,\n      compact: false,\n      iterableLimit: Infinity,\n      // getters should be true in assertEquals.\n      getters: true,\n      strAbbreviateSize: Infinity,\n    })\n    : `\"${String(v).replace(/(?=[\"\\\\])/g, \"\\\\\")}\"`;\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,OAAO,CAAU;EAC/B,mCAAmC;EACnC,MAAM,EAAE,IAAI,EAAE,GAAG;EACjB,OAAO,OAAO,MAAM,YAAY,aAC5B,KAAK,OAAO,CAAC,GAAG;IAChB,OAAO;IACP,QAAQ;IACR,eAAe;IACf,SAAS;IACT,eAAe;IACf,0CAA0C;IAC1C,SAAS;IACT,mBAAmB;EACrB,KACE,CAAC,CAAC,EAAE,OAAO,GAAG,OAAO,CAAC,cAAc,MAAM,CAAC,CAAC;AAClD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_equals.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { equal } from "./equal.ts";
import { buildMessage, diff, diffStr, format } from "jsr:@std/internal@^1.0.0";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` and `expected` are equal, deeply. If not
 * deeply equal, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the
 * same type.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertEquals } from "@std/assert/assert-equals";
 *
 * assertEquals("world", "world"); // Doesn't throw
 * assertEquals("hello", "world"); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare. This is usually inferred.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertEquals(actual, expected, msg) {
  if (equal(actual, expected)) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  let message = `Values are not equal${msgSuffix}`;
  const actualString = format(actual);
  const expectedString = format(expected);
  const stringDiff = typeof actual === "string" && typeof expected === "string";
  const diffResult = stringDiff ? diffStr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
  const diffMsg = buildMessage(diffResult, {
    stringDiff
  }).join("\n");
  message = `${message}\n${diffMsg}`;
  throw new AssertionError(message);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_equals.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { equal } from \"./equal.ts\";\nimport { buildMessage, diff, diffStr, format } from \"jsr:@std/internal@^1.0.0\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` and `expected` are equal, deeply. If not\n * deeply equal, then throw.\n *\n * Type parameter can be specified to ensure values under comparison have the\n * same type.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertEquals } from \"@std/assert/assert-equals\";\n *\n * assertEquals(\"world\", \"world\"); // Doesn't throw\n * assertEquals(\"hello\", \"world\"); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare. This is usually inferred.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertEquals<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  if (equal(actual, expected)) {\n    return;\n  }\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  let message = `Values are not equal${msgSuffix}`;\n\n  const actualString = format(actual);\n  const expectedString = format(expected);\n  const stringDiff = (typeof actual === \"string\") &&\n    (typeof expected === \"string\");\n  const diffResult = stringDiff\n    ? diffStr(actual as string, expected as string)\n    : diff(actualString.split(\"\\n\"), expectedString.split(\"\\n\"));\n  const diffMsg = buildMessage(diffResult, { stringDiff }).join(\"\\n\");\n  message = `${message}\\n${diffMsg}`;\n  throw new AssertionError(message);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,KAAK,QAAQ,aAAa;AACnC,SAAS,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,QAAQ,2BAA2B;AAC/E,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;;;CAmBC,GACD,OAAO,SAAS,aACd,MAAS,EACT,QAAW,EACX,GAAY;EAEZ,IAAI,MAAM,QAAQ,WAAW;IAC3B;EACF;EACA,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,IAAI,UAAU,CAAC,oBAAoB,EAAE,UAAU,CAAC;EAEhD,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAC9B,MAAM,aAAa,AAAC,OAAO,WAAW,YACnC,OAAO,aAAa;EACvB,MAAM,aAAa,aACf,QAAQ,QAAkB,YAC1B,KAAK,aAAa,KAAK,CAAC,OAAO,eAAe,KAAK,CAAC;EACxD,MAAM,UAAU,aAAa,YAAY;IAAE;EAAW,GAAG,IAAI,CAAC;EAC9D,UAAU,CAAC,EAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC;EAClC,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/mod.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Internal utilities for the public API of the Deno Standard Library.
 *
 * Note: this module is for internal use only and should not be used directly.
 *
 * ```ts
 * import { diff, diffStr, buildMessage } from "@std/internal";
 * import { assertEquals } from "@std/assert";
 *
 * const a = [1, 2, 3];
 * const b = [1, 2, 4];
 *
 * assertEquals(diff(a, b), [
 *   { type: "common", value: 1 },
 *   { type: "common", value: 2 },
 *   { type: "removed", value: 3 },
 *   { type: "added", value: 4 },
 * ]);
 *
 * const diffResult = diffStr("Hello, world!", "Hello, world");
 *
 * console.log(buildMessage(diffResult));
 * // [
 * //   "",
 * //   "",
 * //   "    [Diff] Actual / Expected",
 * //   "",
 * //   "",
 * //   "-   Hello, world!",
 * //   "+   Hello, world",
 * //   "",
 * // ]
 * ```
 *
 * @module
 */ export * from "./build_message.ts";
export * from "./diff.ts";
export * from "./diff_str.ts";
export * from "./format.ts";
export * from "./styles.ts";
export * from "./types.ts";

---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/mod.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Internal utilities for the public API of the Deno Standard Library.\n *\n * Note: this module is for internal use only and should not be used directly.\n *\n * ```ts\n * import { diff, diffStr, buildMessage } from \"@std/internal\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const a = [1, 2, 3];\n * const b = [1, 2, 4];\n *\n * assertEquals(diff(a, b), [\n *   { type: \"common\", value: 1 },\n *   { type: \"common\", value: 2 },\n *   { type: \"removed\", value: 3 },\n *   { type: \"added\", value: 4 },\n * ]);\n *\n * const diffResult = diffStr(\"Hello, world!\", \"Hello, world\");\n *\n * console.log(buildMessage(diffResult));\n * // [\n * //   \"\",\n * //   \"\",\n * //   \"    [Diff] Actual / Expected\",\n * //   \"\",\n * //   \"\",\n * //   \"-   Hello, world!\",\n * //   \"+   Hello, world\",\n * //   \"\",\n * // ]\n * ```\n *\n * @module\n */\nexport * from \"./build_message.ts\";\nexport * from \"./diff.ts\";\nexport * from \"./diff_str.ts\";\nexport * from \"./format.ts\";\nexport * from \"./styles.ts\";\nexport * from \"./types.ts\";\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCC,GACD,cAAc,qBAAqB;AACnC,cAAc,YAAY;AAC1B,cAAc,gBAAgB;AAC9B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,aAAa"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/build_message.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { bgGreen, bgRed, bold, gray, green, red, white } from "./styles.ts";
/**
 * Colors the output of assertion diffs.
 *
 * @param diffType Difference type, either added or removed.
 * @param background If true, colors the background instead of the text.
 *
 * @returns A function that colors the input string.
 *
 * @example Usage
 * ```ts
 * import { createColor } from "@std/internal";
 * import { assertEquals } from "@std/assert";
 * import { bold, green, red, white } from "@std/fmt/colors";
 *
 * assertEquals(createColor("added")("foo"), green(bold("foo")));
 * assertEquals(createColor("removed")("foo"), red(bold("foo")));
 * assertEquals(createColor("common")("foo"), white("foo"));
 * ```
 */ export function createColor(diffType, /**
   * TODO(@littledivy): Remove this when we can detect true color terminals. See
   * https://github.com/denoland/deno_std/issues/2575.
   */ background = false) {
  switch(diffType){
    case "added":
      return (s)=>background ? bgGreen(white(s)) : green(bold(s));
    case "removed":
      return (s)=>background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
/**
 * Prefixes `+` or `-` in diff output.
 *
 * @param diffType Difference type, either added or removed
 *
 * @returns A string representing the sign.
 *
 * @example Usage
 * ```ts
 * import { createSign } from "@std/internal";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(createSign("added"), "+   ");
 * assertEquals(createSign("removed"), "-   ");
 * assertEquals(createSign("common"), "    ");
 * ```
 */ export function createSign(diffType) {
  switch(diffType){
    case "added":
      return "+   ";
    case "removed":
      return "-   ";
    default:
      return "    ";
  }
}
/**
 * Builds a message based on the provided diff result.
 *
 * @param diffResult The diff result array.
 * @param options Optional parameters for customizing the message.
 *
 * @returns An array of strings representing the built message.
 *
 * @example Usage
 * ```ts no-assert
 * import { diffStr, buildMessage } from "@std/internal";
 *
 * const diffResult = diffStr("Hello, world!", "Hello, world");
 *
 * console.log(buildMessage(diffResult));
 * // [
 * //   "",
 * //   "",
 * //   "    [Diff] Actual / Expected",
 * //   "",
 * //   "",
 * //   "-   Hello, world!",
 * //   "+   Hello, world",
 * //   "",
 * // ]
 * ```
 */ export function buildMessage(diffResult, options = {}) {
  const { stringDiff = false } = options;
  const messages = [
    "",
    "",
    `    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`,
    "",
    ""
  ];
  const diffMessages = diffResult.map((result)=>{
    const color = createColor(result.type);
    const line = result.details?.map((detail)=>detail.type !== "common" ? createColor(detail.type, true)(detail.value) : detail.value).join("") ?? result.value;
    return color(`${createSign(result.type)}${line}`);
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages, "");
  return messages;
}

---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/build_message.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { bgGreen, bgRed, bold, gray, green, red, white } from \"./styles.ts\";\nimport type { DiffResult, DiffType } from \"./types.ts\";\n\n/**\n * Colors the output of assertion diffs.\n *\n * @param diffType Difference type, either added or removed.\n * @param background If true, colors the background instead of the text.\n *\n * @returns A function that colors the input string.\n *\n * @example Usage\n * ```ts\n * import { createColor } from \"@std/internal\";\n * import { assertEquals } from \"@std/assert\";\n * import { bold, green, red, white } from \"@std/fmt/colors\";\n *\n * assertEquals(createColor(\"added\")(\"foo\"), green(bold(\"foo\")));\n * assertEquals(createColor(\"removed\")(\"foo\"), red(bold(\"foo\")));\n * assertEquals(createColor(\"common\")(\"foo\"), white(\"foo\"));\n * ```\n */\nexport function createColor(\n  diffType: DiffType,\n  /**\n   * TODO(@littledivy): Remove this when we can detect true color terminals. See\n   * https://github.com/denoland/deno_std/issues/2575.\n   */\n  background = false,\n): (s: string) => string {\n  switch (diffType) {\n    case \"added\":\n      return (s) => background ? bgGreen(white(s)) : green(bold(s));\n    case \"removed\":\n      return (s) => background ? bgRed(white(s)) : red(bold(s));\n    default:\n      return white;\n  }\n}\n\n/**\n * Prefixes `+` or `-` in diff output.\n *\n * @param diffType Difference type, either added or removed\n *\n * @returns A string representing the sign.\n *\n * @example Usage\n * ```ts\n * import { createSign } from \"@std/internal\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(createSign(\"added\"), \"+   \");\n * assertEquals(createSign(\"removed\"), \"-   \");\n * assertEquals(createSign(\"common\"), \"    \");\n * ```\n */\nexport function createSign(diffType: DiffType): string {\n  switch (diffType) {\n    case \"added\":\n      return \"+   \";\n    case \"removed\":\n      return \"-   \";\n    default:\n      return \"    \";\n  }\n}\n\n/** Options for {@linkcode buildMessage}. */\nexport interface BuildMessageOptions {\n  /**\n   * Whether to output the diff as a single string.\n   *\n   * @default {false}\n   */\n  stringDiff?: boolean;\n}\n\n/**\n * Builds a message based on the provided diff result.\n *\n * @param diffResult The diff result array.\n * @param options Optional parameters for customizing the message.\n *\n * @returns An array of strings representing the built message.\n *\n * @example Usage\n * ```ts no-assert\n * import { diffStr, buildMessage } from \"@std/internal\";\n *\n * const diffResult = diffStr(\"Hello, world!\", \"Hello, world\");\n *\n * console.log(buildMessage(diffResult));\n * // [\n * //   \"\",\n * //   \"\",\n * //   \"    [Diff] Actual / Expected\",\n * //   \"\",\n * //   \"\",\n * //   \"-   Hello, world!\",\n * //   \"+   Hello, world\",\n * //   \"\",\n * // ]\n * ```\n */\nexport function buildMessage(\n  diffResult: ReadonlyArray<DiffResult<string>>,\n  options: BuildMessageOptions = {},\n): string[] {\n  const { stringDiff = false } = options;\n  const messages = [\n    \"\",\n    \"\",\n    `    ${gray(bold(\"[Diff]\"))} ${red(bold(\"Actual\"))} / ${\n      green(bold(\"Expected\"))\n    }`,\n    \"\",\n    \"\",\n  ];\n  const diffMessages = diffResult.map((result) => {\n    const color = createColor(result.type);\n    const line = result.details?.map((detail) =>\n      detail.type !== \"common\"\n        ? createColor(detail.type, true)(detail.value)\n        : detail.value\n    ).join(\"\") ?? result.value;\n    return color(`${createSign(result.type)}${line}`);\n  });\n  messages.push(...(stringDiff ? [diffMessages.join(\"\")] : diffMessages), \"\");\n  return messages;\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,QAAQ,cAAc;AAG5E;;;;;;;;;;;;;;;;;;CAkBC,GACD,OAAO,SAAS,YACd,QAAkB,EAClB;;;GAGC,GACD,aAAa,KAAK;EAElB,OAAQ;IACN,KAAK;MACH,OAAO,CAAC,IAAM,aAAa,QAAQ,MAAM,MAAM,MAAM,KAAK;IAC5D,KAAK;MACH,OAAO,CAAC,IAAM,aAAa,MAAM,MAAM,MAAM,IAAI,KAAK;IACxD;MACE,OAAO;EACX;AACF;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD,OAAO,SAAS,WAAW,QAAkB;EAC3C,OAAQ;IACN,KAAK;MACH,OAAO;IACT,KAAK;MACH,OAAO;IACT;MACE,OAAO;EACX;AACF;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BC,GACD,OAAO,SAAS,aACd,UAA6C,EAC7C,UAA+B,CAAC,CAAC;EAEjC,MAAM,EAAE,aAAa,KAAK,EAAE,GAAG;EAC/B,MAAM,WAAW;IACf;IACA;IACA,CAAC,IAAI,EAAE,KAAK,KAAK,WAAW,CAAC,EAAE,IAAI,KAAK,WAAW,GAAG,EACpD,MAAM,KAAK,aACZ,CAAC;IACF;IACA;GACD;EACD,MAAM,eAAe,WAAW,GAAG,CAAC,CAAC;IACnC,MAAM,QAAQ,YAAY,OAAO,IAAI;IACrC,MAAM,OAAO,OAAO,OAAO,EAAE,IAAI,CAAC,SAChC,OAAO,IAAI,KAAK,WACZ,YAAY,OAAO,IAAI,EAAE,MAAM,OAAO,KAAK,IAC3C,OAAO,KAAK,EAChB,KAAK,OAAO,OAAO,KAAK;IAC1B,OAAO,MAAM,CAAC,EAAE,WAAW,OAAO,IAAI,EAAE,EAAE,KAAK,CAAC;EAClD;EACA,SAAS,IAAI,IAAK,aAAa;IAAC,aAAa,IAAI,CAAC;GAAI,GAAG,cAAe;EACxE,OAAO;AACT"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/styles.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
// on npm.
// This code is vendored from `fmt/colors.ts`.
// deno-lint-ignore no-explicit-any
const { Deno } = globalThis;
const noColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : false;
const enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1b[${open.join(";")}m`,
    close: `\x1b[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code) {
  return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
/**
 * Sets the style of text to be printed to bold.
 *
 * Disable by setting the `NO_COLOR` environmental variable.
 *
 * @param str Text to make bold
 *
 * @returns Bold text for printing
 *
 * @example Usage
 * ```ts no-assert
 * import { bold } from "@std/internal/styles";
 *
 * console.log(bold("Hello, world!")); // Prints "Hello, world!" in bold
 * ```
 */ export function bold(str) {
  return run(str, code([
    1
  ], 22));
}
/**
 * Sets the color of text to be printed to red.
 *
 * Disable by setting the `NO_COLOR` environmental variable.
 *
 * @param str Text to make red
 *
 * @returns Red text for printing
 *
 * @example Usage
 * ```ts no-assert
 * import { red } from "@std/internal/styles";
 *
 * console.log(red("Hello, world!")); // Prints "Hello, world!" in red
 * ```
 */ export function red(str) {
  return run(str, code([
    31
  ], 39));
}
/**
 * Sets the color of text to be printed to green.
 *
 * Disable by setting the `NO_COLOR` environmental variable.
 *
 * @param str Text to make green
 *
 * @returns Green text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { green } from "@std/internal/styles";
 *
 * console.log(green("Hello, world!")); // Prints "Hello, world!" in green
 * ```
 */ export function green(str) {
  return run(str, code([
    32
  ], 39));
}
/**
 * Sets the color of text to be printed to yellow.
 *
 * Disable by setting the `NO_COLOR` environmental variable.
 *
 * @param str Text to make yellow
 *
 * @returns Yellow text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { yellow } from "@std/internal/styles";
 *
 * console.log(yellow("Hello, world!")); // Prints "Hello, world!" in yellow
 * ```
 */ export function yellow(str) {
  return run(str, code([
    33
  ], 39));
}
/**
 * Sets the color of text to be printed to white.
 *
 * @param str Text to make white
 *
 * @returns White text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { white } from "@std/internal/styles";
 *
 * console.log(white("Hello, world!")); // Prints "Hello, world!" in white
 * ```
 */ export function white(str) {
  return run(str, code([
    37
  ], 39));
}
/**
 * Sets the color of text to be printed to gray.
 *
 * @param str Text to make gray
 *
 * @returns Gray text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { gray } from "@std/internal/styles";
 *
 * console.log(gray("Hello, world!")); // Prints "Hello, world!" in gray
 * ```
 */ export function gray(str) {
  return brightBlack(str);
}
/**
 * Sets the color of text to be printed to bright-black.
 *
 * @param str Text to make bright-black
 *
 * @returns Bright-black text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { brightBlack } from "@std/internal/styles";
 *
 * console.log(brightBlack("Hello, world!")); // Prints "Hello, world!" in bright-black
 * ```
 */ export function brightBlack(str) {
  return run(str, code([
    90
  ], 39));
}
/**
 * Sets the background color of text to be printed to red.
 *
 * @param str Text to make its background red
 *
 * @returns Red background text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { bgRed } from "@std/internal/styles";
 *
 * console.log(bgRed("Hello, world!")); // Prints "Hello, world!" with red background
 * ```
 */ export function bgRed(str) {
  return run(str, code([
    41
  ], 49));
}
/**
 * Sets the background color of text to be printed to green.
 *
 * @param str Text to make its background green
 *
 * @returns Green background text for print
 *
 * @example Usage
 * ```ts no-assert
 * import { bgGreen } from "@std/internal/styles";
 *
 * console.log(bgGreen("Hello, world!")); // Prints "Hello, world!" with green background
 * ```
 */ export function bgGreen(str) {
  return run(str, code([
    42
  ], 49));
}
// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js
const ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
].join("|"), "g");
/**
 * Remove ANSI escape codes from the string.
 *
 * @param string Text to remove ANSI escape codes from
 *
 * @returns Text without ANSI escape codes
 *
 * @example Usage
 * ```ts no-assert
 * import { red, stripAnsiCode } from "@std/internal/styles";
 *
 * console.log(stripAnsiCode(red("Hello, world!"))); // Prints "Hello, world!"
 * ```
 */ export function stripAnsiCode(string) {
  return string.replace(ANSI_PATTERN, "");
}

---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/styles.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n\n// This code is vendored from `fmt/colors.ts`.\n\n// deno-lint-ignore no-explicit-any\nconst { Deno } = globalThis as any;\nconst noColor = typeof Deno?.noColor === \"boolean\"\n  ? Deno.noColor as boolean\n  : false;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\nconst enabled = !noColor;\n\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\n/**\n * Sets the style of text to be printed to bold.\n *\n * Disable by setting the `NO_COLOR` environmental variable.\n *\n * @param str Text to make bold\n *\n * @returns Bold text for printing\n *\n * @example Usage\n * ```ts no-assert\n * import { bold } from \"@std/internal/styles\";\n *\n * console.log(bold(\"Hello, world!\")); // Prints \"Hello, world!\" in bold\n * ```\n */\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\n/**\n * Sets the color of text to be printed to red.\n *\n * Disable by setting the `NO_COLOR` environmental variable.\n *\n * @param str Text to make red\n *\n * @returns Red text for printing\n *\n * @example Usage\n * ```ts no-assert\n * import { red } from \"@std/internal/styles\";\n *\n * console.log(red(\"Hello, world!\")); // Prints \"Hello, world!\" in red\n * ```\n */\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\n/**\n * Sets the color of text to be printed to green.\n *\n * Disable by setting the `NO_COLOR` environmental variable.\n *\n * @param str Text to make green\n *\n * @returns Green text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { green } from \"@std/internal/styles\";\n *\n * console.log(green(\"Hello, world!\")); // Prints \"Hello, world!\" in green\n * ```\n */\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\n/**\n * Sets the color of text to be printed to yellow.\n *\n * Disable by setting the `NO_COLOR` environmental variable.\n *\n * @param str Text to make yellow\n *\n * @returns Yellow text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { yellow } from \"@std/internal/styles\";\n *\n * console.log(yellow(\"Hello, world!\")); // Prints \"Hello, world!\" in yellow\n * ```\n */\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\n/**\n * Sets the color of text to be printed to white.\n *\n * @param str Text to make white\n *\n * @returns White text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { white } from \"@std/internal/styles\";\n *\n * console.log(white(\"Hello, world!\")); // Prints \"Hello, world!\" in white\n * ```\n */\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\n/**\n * Sets the color of text to be printed to gray.\n *\n * @param str Text to make gray\n *\n * @returns Gray text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { gray } from \"@std/internal/styles\";\n *\n * console.log(gray(\"Hello, world!\")); // Prints \"Hello, world!\" in gray\n * ```\n */\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\n/**\n * Sets the color of text to be printed to bright-black.\n *\n * @param str Text to make bright-black\n *\n * @returns Bright-black text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { brightBlack } from \"@std/internal/styles\";\n *\n * console.log(brightBlack(\"Hello, world!\")); // Prints \"Hello, world!\" in bright-black\n * ```\n */\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\n/**\n * Sets the background color of text to be printed to red.\n *\n * @param str Text to make its background red\n *\n * @returns Red background text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { bgRed } from \"@std/internal/styles\";\n *\n * console.log(bgRed(\"Hello, world!\")); // Prints \"Hello, world!\" with red background\n * ```\n */\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\n/**\n * Sets the background color of text to be printed to green.\n *\n * @param str Text to make its background green\n *\n * @returns Green background text for print\n *\n * @example Usage\n * ```ts no-assert\n * import { bgGreen } from \"@std/internal/styles\";\n *\n * console.log(bgGreen(\"Hello, world!\")); // Prints \"Hello, world!\" with green background\n * ```\n */\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\n// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TXZcf-nq-uy=><~]))\",\n  ].join(\"|\"),\n  \"g\",\n);\n\n/**\n * Remove ANSI escape codes from the string.\n *\n * @param string Text to remove ANSI escape codes from\n *\n * @returns Text without ANSI escape codes\n *\n * @example Usage\n * ```ts no-assert\n * import { red, stripAnsiCode } from \"@std/internal/styles\";\n *\n * console.log(stripAnsiCode(red(\"Hello, world!\"))); // Prints \"Hello, world!\"\n * ```\n */\nexport function stripAnsiCode(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,+EAA+E;AAC/E,UAAU;AAEV,8CAA8C;AAE9C,mCAAmC;AACnC,MAAM,EAAE,IAAI,EAAE,GAAG;AACjB,MAAM,UAAU,OAAO,MAAM,YAAY,YACrC,KAAK,OAAO,GACZ;AAQJ,MAAM,UAAU,CAAC;AAEjB,SAAS,KAAK,IAAc,EAAE,KAAa;EACzC,OAAO;IACL,MAAM,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC;IAC/B,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACvB,QAAQ,IAAI,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,EAAE;EAC1C;AACF;AAEA,SAAS,IAAI,GAAW,EAAE,IAAU;EAClC,OAAO,UACH,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,IAAI,OAAO,CAAC,KAAK,MAAM,EAAE,KAAK,IAAI,EAAE,EAAE,KAAK,KAAK,CAAC,CAAC,GACjE;AACN;AAEA;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,KAAK,GAAW;EAC9B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAE,EAAE;AAC5B;AAEA;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,IAAI,GAAW;EAC7B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,OAAO,GAAW;EAChC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,KAAK,GAAW;EAC9B,OAAO,YAAY;AACrB;AAEA;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,YAAY,GAAW;EACrC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,MAAM,GAAW;EAC/B,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,QAAQ,GAAW;EACjC,OAAO,IAAI,KAAK,KAAK;IAAC;GAAG,EAAE;AAC7B;AAEA,6FAA6F;AAC7F,MAAM,eAAe,IAAI,OACvB;EACE;EACA;CACD,CAAC,IAAI,CAAC,MACP;AAGF;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,cAAc,MAAc;EAC1C,OAAO,OAAO,OAAO,CAAC,cAAc;AACtC"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/diff.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
/**
 * Creates an array of common elements between two arrays.
 *
 * @typeParam T The type of elements in the arrays.
 *
 * @param A The first array.
 * @param B The second array.
 *
 * @returns An array containing the common elements between the two arrays.
 *
 * @example Usage
 * ```ts
 * import { createCommon } from "@std/internal/diff";
 * import { assertEquals } from "@std/assert";
 *
 * const a = [1, 2, 3];
 * const b = [1, 2, 4];
 *
 * assertEquals(createCommon(a, b), [1, 2]);
 * ```
 */ export function createCommon(A, B) {
  const common = [];
  if (A.length === 0 || B.length === 0) return [];
  for(let i = 0; i < Math.min(A.length, B.length); i += 1){
    const a = A[i];
    const b = B[i];
    if (a !== undefined && a === b) {
      common.push(a);
    } else {
      return common;
    }
  }
  return common;
}
/**
 * Asserts that the value is a {@linkcode FarthestPoint}.
 * If not, an error is thrown.
 *
 * @param value The value to check.
 *
 * @returns A void value that returns once the assertion completes.
 *
 * @example Usage
 * ```ts
 * import { assertFp } from "@std/internal/diff";
 * import { assertThrows } from "@std/assert";
 *
 * assertFp({ y: 0, id: 0 });
 * assertThrows(() => assertFp({ id: 0 }));
 * assertThrows(() => assertFp({ y: 0 }));
 * assertThrows(() => assertFp(undefined));
 * ```
 */ export function assertFp(value) {
  if (value == null || typeof value !== "object" || typeof value?.y !== "number" || typeof value?.id !== "number") {
    throw new Error("Unexpected missing FarthestPoint");
  }
}
/**
 * Creates an array of backtraced differences.
 *
 * @typeParam T The type of elements in the arrays.
 *
 * @param A The first array.
 * @param B The second array.
 * @param current The current {@linkcode FarthestPoint}.
 * @param swapped Boolean indicating if the arrays are swapped.
 * @param routes The routes array.
 * @param diffTypesPtrOffset The offset of the diff types in the routes array.
 *
 * @returns An array of backtraced differences.
 *
 * @example Usage
 * ```ts
 * import { backTrace } from "@std/internal/diff";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(
 *   backTrace([], [], { y: 0, id: 0 }, false, new Uint32Array(0), 0),
 *   [],
 * );
 * ```
 */ export function backTrace(A, B, current, swapped, routes, diffTypesPtrOffset) {
  const M = A.length;
  const N = B.length;
  const result = [];
  let a = M - 1;
  let b = N - 1;
  let j = routes[current.id];
  let type = routes[current.id + diffTypesPtrOffset];
  while(true){
    if (!j && !type) break;
    const prev = j;
    if (type === REMOVED) {
      result.unshift({
        type: swapped ? "removed" : "added",
        value: B[b]
      });
      b -= 1;
    } else if (type === ADDED) {
      result.unshift({
        type: swapped ? "added" : "removed",
        value: A[a]
      });
      a -= 1;
    } else {
      result.unshift({
        type: "common",
        value: A[a]
      });
      a -= 1;
      b -= 1;
    }
    j = routes[prev];
    type = routes[prev + diffTypesPtrOffset];
  }
  return result;
}
/**
 * Creates a {@linkcode FarthestPoint}.
 *
 * @param k The current index.
 * @param M The length of the first array.
 * @param routes The routes array.
 * @param diffTypesPtrOffset The offset of the diff types in the routes array.
 * @param ptr The current pointer.
 * @param slide The slide {@linkcode FarthestPoint}.
 * @param down The down {@linkcode FarthestPoint}.
 *
 * @returns A {@linkcode FarthestPoint}.
 *
 * @example Usage
 * ```ts
 * import { createFp } from "@std/internal/diff";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(
 *   createFp(
 *     0,
 *     0,
 *     new Uint32Array(0),
 *     0,
 *     0,
 *     { y: -1, id: 0 },
 *     { y: 0, id: 0 },
 *   ),
 *   { y: -1, id: 1 },
 * );
 * ```
 */ export function createFp(k, M, routes, diffTypesPtrOffset, ptr, slide, down) {
  if (slide && slide.y === -1 && down && down.y === -1) {
    return {
      y: 0,
      id: 0
    };
  }
  const isAdding = down?.y === -1 || k === M || (slide?.y || 0) > (down?.y || 0) + 1;
  if (slide && isAdding) {
    const prev = slide.id;
    ptr++;
    routes[ptr] = prev;
    routes[ptr + diffTypesPtrOffset] = ADDED;
    return {
      y: slide.y,
      id: ptr
    };
  }
  if (down && !isAdding) {
    const prev = down.id;
    ptr++;
    routes[ptr] = prev;
    routes[ptr + diffTypesPtrOffset] = REMOVED;
    return {
      y: down.y + 1,
      id: ptr
    };
  }
  throw new Error("Unexpected missing FarthestPoint");
}
/**
 * Renders the differences between the actual and expected values.
 *
 * @typeParam T The type of elements in the arrays.
 *
 * @param A Actual value
 * @param B Expected value
 *
 * @returns An array of differences between the actual and expected values.
 *
 * @example Usage
 * ```ts
 * import { diff } from "@std/internal/diff";
 * import { assertEquals } from "@std/assert";
 *
 * const a = [1, 2, 3];
 * const b = [1, 2, 4];
 *
 * assertEquals(diff(a, b), [
 *   { type: "common", value: 1 },
 *   { type: "common", value: 2 },
 *   { type: "removed", value: 3 },
 *   { type: "added", value: 4 },
 * ]);
 * ```
 */ export function diff(A, B) {
  const prefixCommon = createCommon(A, B);
  A = A.slice(prefixCommon.length);
  B = B.slice(prefixCommon.length);
  const swapped = B.length > A.length;
  [A, B] = swapped ? [
    B,
    A
  ] : [
    A,
    B
  ];
  const M = A.length;
  const N = B.length;
  if (!M && !N && !prefixCommon.length) return [];
  if (!N) {
    return [
      ...prefixCommon.map((value)=>({
          type: "common",
          value
        })),
      ...A.map((value)=>({
          type: swapped ? "added" : "removed",
          value
        }))
    ];
  }
  const offset = N;
  const delta = M - N;
  const length = M + N + 1;
  const fp = Array.from({
    length
  }, ()=>({
      y: -1,
      id: -1
    }));
  /**
   * Note: this buffer is used to save memory and improve performance. The first
   * half is used to save route and the last half is used to save diff type.
   */ const routes = new Uint32Array((M * N + length + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  function snake(k, A, B, slide, down) {
    const M = A.length;
    const N = B.length;
    const fp = createFp(k, M, routes, diffTypesPtrOffset, ptr, slide, down);
    ptr = fp.id;
    while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
      const prev = fp.id;
      ptr++;
      fp.id = ptr;
      fp.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp;
  }
  let currentFp = fp[delta + offset];
  assertFp(currentFp);
  let p = -1;
  while(currentFp.y < N){
    p = p + 1;
    for(let k = -p; k < delta; ++k){
      const index = k + offset;
      fp[index] = snake(k, A, B, fp[index - 1], fp[index + 1]);
    }
    for(let k = delta + p; k > delta; --k){
      const index = k + offset;
      fp[index] = snake(k, A, B, fp[index - 1], fp[index + 1]);
    }
    const index = delta + offset;
    fp[delta + offset] = snake(delta, A, B, fp[index - 1], fp[index + 1]);
    currentFp = fp[delta + offset];
    assertFp(currentFp);
  }
  return [
    ...prefixCommon.map((value)=>({
        type: "common",
        value
      })),
    ...backTrace(A, B, currentFp, swapped, routes, diffTypesPtrOffset)
  ];
}

---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/diff.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport type { DiffResult, DiffType } from \"./types.ts\";\n\n/** Represents the farthest point in the diff algorithm. */\nexport interface FarthestPoint {\n  /** The y-coordinate of the point. */\n  y: number;\n  /** The id of the point. */\n  id: number;\n}\n\nconst REMOVED = 1;\nconst COMMON = 2;\nconst ADDED = 3;\n\n/**\n * Creates an array of common elements between two arrays.\n *\n * @typeParam T The type of elements in the arrays.\n *\n * @param A The first array.\n * @param B The second array.\n *\n * @returns An array containing the common elements between the two arrays.\n *\n * @example Usage\n * ```ts\n * import { createCommon } from \"@std/internal/diff\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const a = [1, 2, 3];\n * const b = [1, 2, 4];\n *\n * assertEquals(createCommon(a, b), [1, 2]);\n * ```\n */\nexport function createCommon<T>(A: T[], B: T[]): T[] {\n  const common: T[] = [];\n  if (A.length === 0 || B.length === 0) return [];\n  for (let i = 0; i < Math.min(A.length, B.length); i += 1) {\n    const a = A[i];\n    const b = B[i];\n    if (a !== undefined && a === b) {\n      common.push(a);\n    } else {\n      return common;\n    }\n  }\n  return common;\n}\n\n/**\n * Asserts that the value is a {@linkcode FarthestPoint}.\n * If not, an error is thrown.\n *\n * @param value The value to check.\n *\n * @returns A void value that returns once the assertion completes.\n *\n * @example Usage\n * ```ts\n * import { assertFp } from \"@std/internal/diff\";\n * import { assertThrows } from \"@std/assert\";\n *\n * assertFp({ y: 0, id: 0 });\n * assertThrows(() => assertFp({ id: 0 }));\n * assertThrows(() => assertFp({ y: 0 }));\n * assertThrows(() => assertFp(undefined));\n * ```\n */\nexport function assertFp(value: unknown): asserts value is FarthestPoint {\n  if (\n    value == null ||\n    typeof value !== \"object\" ||\n    typeof (value as FarthestPoint)?.y !== \"number\" ||\n    typeof (value as FarthestPoint)?.id !== \"number\"\n  ) {\n    throw new Error(\"Unexpected missing FarthestPoint\");\n  }\n}\n\n/**\n * Creates an array of backtraced differences.\n *\n * @typeParam T The type of elements in the arrays.\n *\n * @param A The first array.\n * @param B The second array.\n * @param current The current {@linkcode FarthestPoint}.\n * @param swapped Boolean indicating if the arrays are swapped.\n * @param routes The routes array.\n * @param diffTypesPtrOffset The offset of the diff types in the routes array.\n *\n * @returns An array of backtraced differences.\n *\n * @example Usage\n * ```ts\n * import { backTrace } from \"@std/internal/diff\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(\n *   backTrace([], [], { y: 0, id: 0 }, false, new Uint32Array(0), 0),\n *   [],\n * );\n * ```\n */\nexport function backTrace<T>(\n  A: T[],\n  B: T[],\n  current: FarthestPoint,\n  swapped: boolean,\n  routes: Uint32Array,\n  diffTypesPtrOffset: number,\n): Array<{\n  type: DiffType;\n  value: T;\n}> {\n  const M = A.length;\n  const N = B.length;\n  const result: { type: DiffType; value: T }[] = [];\n  let a = M - 1;\n  let b = N - 1;\n  let j = routes[current.id];\n  let type = routes[current.id + diffTypesPtrOffset];\n  while (true) {\n    if (!j && !type) break;\n    const prev = j!;\n    if (type === REMOVED) {\n      result.unshift({\n        type: swapped ? \"removed\" : \"added\",\n        value: B[b]!,\n      });\n      b -= 1;\n    } else if (type === ADDED) {\n      result.unshift({\n        type: swapped ? \"added\" : \"removed\",\n        value: A[a]!,\n      });\n      a -= 1;\n    } else {\n      result.unshift({ type: \"common\", value: A[a]! });\n      a -= 1;\n      b -= 1;\n    }\n    j = routes[prev];\n    type = routes[prev + diffTypesPtrOffset];\n  }\n  return result;\n}\n\n/**\n * Creates a {@linkcode FarthestPoint}.\n *\n * @param k The current index.\n * @param M The length of the first array.\n * @param routes The routes array.\n * @param diffTypesPtrOffset The offset of the diff types in the routes array.\n * @param ptr The current pointer.\n * @param slide The slide {@linkcode FarthestPoint}.\n * @param down The down {@linkcode FarthestPoint}.\n *\n * @returns A {@linkcode FarthestPoint}.\n *\n * @example Usage\n * ```ts\n * import { createFp } from \"@std/internal/diff\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(\n *   createFp(\n *     0,\n *     0,\n *     new Uint32Array(0),\n *     0,\n *     0,\n *     { y: -1, id: 0 },\n *     { y: 0, id: 0 },\n *   ),\n *   { y: -1, id: 1 },\n * );\n * ```\n */\nexport function createFp(\n  k: number,\n  M: number,\n  routes: Uint32Array,\n  diffTypesPtrOffset: number,\n  ptr: number,\n  slide?: FarthestPoint,\n  down?: FarthestPoint,\n): FarthestPoint {\n  if (slide && slide.y === -1 && down && down.y === -1) {\n    return { y: 0, id: 0 };\n  }\n  const isAdding = (down?.y === -1) ||\n    k === M ||\n    (slide?.y || 0) > (down?.y || 0) + 1;\n  if (slide && isAdding) {\n    const prev = slide.id;\n    ptr++;\n    routes[ptr] = prev;\n    routes[ptr + diffTypesPtrOffset] = ADDED;\n    return { y: slide.y, id: ptr };\n  }\n  if (down && !isAdding) {\n    const prev = down.id;\n    ptr++;\n    routes[ptr] = prev;\n    routes[ptr + diffTypesPtrOffset] = REMOVED;\n    return { y: down.y + 1, id: ptr };\n  }\n  throw new Error(\"Unexpected missing FarthestPoint\");\n}\n\n/**\n * Renders the differences between the actual and expected values.\n *\n * @typeParam T The type of elements in the arrays.\n *\n * @param A Actual value\n * @param B Expected value\n *\n * @returns An array of differences between the actual and expected values.\n *\n * @example Usage\n * ```ts\n * import { diff } from \"@std/internal/diff\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const a = [1, 2, 3];\n * const b = [1, 2, 4];\n *\n * assertEquals(diff(a, b), [\n *   { type: \"common\", value: 1 },\n *   { type: \"common\", value: 2 },\n *   { type: \"removed\", value: 3 },\n *   { type: \"added\", value: 4 },\n * ]);\n * ```\n */\nexport function diff<T>(A: T[], B: T[]): DiffResult<T>[] {\n  const prefixCommon = createCommon(A, B);\n  A = A.slice(prefixCommon.length);\n  B = B.slice(prefixCommon.length);\n  const swapped = B.length > A.length;\n  [A, B] = swapped ? [B, A] : [A, B];\n  const M = A.length;\n  const N = B.length;\n  if (!M && !N && !prefixCommon.length) return [];\n  if (!N) {\n    return [\n      ...prefixCommon.map((value) => ({ type: \"common\", value })),\n      ...A.map((value) => ({ type: swapped ? \"added\" : \"removed\", value })),\n    ] as DiffResult<T>[];\n  }\n  const offset = N;\n  const delta = M - N;\n  const length = M + N + 1;\n  const fp: FarthestPoint[] = Array.from({ length }, () => ({ y: -1, id: -1 }));\n\n  /**\n   * Note: this buffer is used to save memory and improve performance. The first\n   * half is used to save route and the last half is used to save diff type.\n   */\n  const routes = new Uint32Array((M * N + length + 1) * 2);\n  const diffTypesPtrOffset = routes.length / 2;\n  let ptr = 0;\n\n  function snake<T>(\n    k: number,\n    A: T[],\n    B: T[],\n    slide?: FarthestPoint,\n    down?: FarthestPoint,\n  ): FarthestPoint {\n    const M = A.length;\n    const N = B.length;\n    const fp = createFp(k, M, routes, diffTypesPtrOffset, ptr, slide, down);\n    ptr = fp.id;\n    while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {\n      const prev = fp.id;\n      ptr++;\n      fp.id = ptr;\n      fp.y += 1;\n      routes[ptr] = prev;\n      routes[ptr + diffTypesPtrOffset] = COMMON;\n    }\n    return fp;\n  }\n\n  let currentFp = fp[delta + offset];\n  assertFp(currentFp);\n  let p = -1;\n  while (currentFp.y < N) {\n    p = p + 1;\n    for (let k = -p; k < delta; ++k) {\n      const index = k + offset;\n      fp[index] = snake(k, A, B, fp[index - 1], fp[index + 1]);\n    }\n    for (let k = delta + p; k > delta; --k) {\n      const index = k + offset;\n      fp[index] = snake(k, A, B, fp[index - 1], fp[index + 1]);\n    }\n    const index = delta + offset;\n    fp[delta + offset] = snake(delta, A, B, fp[index - 1], fp[index + 1]);\n    currentFp = fp[delta + offset];\n    assertFp(currentFp);\n  }\n  return [\n    ...prefixCommon.map((value) => ({ type: \"common\", value })),\n    ...backTrace(A, B, currentFp, swapped, routes, diffTypesPtrOffset),\n  ] as DiffResult<T>[];\n}\n"],"names":[],"mappings":"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"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/diff_str.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
import { diff } from "./diff.ts";
/**
 * Unescape invisible characters.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences}
 *
 * @param string String to unescape.
 *
 * @returns Unescaped string.
 *
 * @example Usage
 * ```ts
 * import { unescape } from "@std/internal/diff-str";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(unescape("Hello\nWorld"), "Hello\\n\nWorld");
 * ```
 */ export function unescape(string) {
  return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v")// This does not remove line breaks
  .replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
}
const WHITESPACE_SYMBOLS = /([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/;
/**
 * Tokenizes a string into an array of tokens.
 *
 * @param string The string to tokenize.
 * @param wordDiff If true, performs word-based tokenization. Default is false.
 *
 * @returns An array of tokens.
 *
 * @example Usage
 * ```ts
 * import { tokenize } from "@std/internal/diff-str";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(tokenize("Hello\nWorld"), ["Hello\n", "World"]);
 * ```
 */ export function tokenize(string, wordDiff = false) {
  if (wordDiff) {
    return string.split(WHITESPACE_SYMBOLS).filter((token)=>token);
  }
  const tokens = [];
  const lines = string.split(/(\n|\r\n)/).filter((line)=>line);
  for (const [i, line] of lines.entries()){
    if (i % 2) {
      tokens[tokens.length - 1] += line;
    } else {
      tokens.push(line);
    }
  }
  return tokens;
}
/**
 * Create details by filtering relevant word-diff for current line and merge
 * "space-diff" if surrounded by word-diff for cleaner displays.
 *
 * @param line Current line
 * @param tokens Word-diff tokens
 *
 * @returns Array of diff results.
 *
 * @example Usage
 * ```ts
 * import { createDetails } from "@std/internal/diff-str";
 * import { assertEquals } from "@std/assert";
 *
 * const tokens = [
 *   { type: "added", value: "a" },
 *   { type: "removed", value: "b" },
 *   { type: "common", value: "c" },
 * ] as const;
 * assertEquals(
 *   createDetails({ type: "added", value: "a" }, [...tokens]),
 *   [{ type: "added", value: "a" }, { type: "common", value: "c" }]
 * );
 * ```
 */ export function createDetails(line, tokens) {
  return tokens.filter(({ type })=>type === line.type || type === "common").map((result, i, t)=>{
    const token = t[i - 1];
    if (result.type === "common" && token && token.type === t[i + 1]?.type && /\s+/.test(result.value)) {
      return {
        ...result,
        type: token.type
      };
    }
    return result;
  });
}
/**
 * Renders the differences between the actual and expected strings. Partially
 * inspired from {@link https://github.com/kpdecker/jsdiff}.
 *
 * @param A Actual string
 * @param B Expected string
 *
 * @returns Array of diff results.
 *
 * @example Usage
 * ```ts
 * import { diffStr } from "@std/internal/diff-str";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(diffStr("Hello!", "Hello"), [
 *   {
 *     type: "removed",
 *     value: "Hello!\n",
 *     details: [
 *       { type: "common", value: "Hello" },
 *       { type: "removed", value: "!" },
 *       { type: "common", value: "\n" }
 *     ]
 *   },
 *   {
 *     type: "added",
 *     value: "Hello\n",
 *     details: [
 *       { type: "common", value: "Hello" },
 *       { type: "common", value: "\n" }
 *     ]
 *   }
 * ]);
 * ```
 */ export function diffStr(A, B) {
  // Compute multi-line diff
  const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
  const added = [];
  const removed = [];
  for (const result of diffResult){
    if (result.type === "added") {
      added.push(result);
    }
    if (result.type === "removed") {
      removed.push(result);
    }
  }
  // Compute word-diff
  const hasMoreRemovedLines = added.length < removed.length;
  const aLines = hasMoreRemovedLines ? added : removed;
  const bLines = hasMoreRemovedLines ? removed : added;
  for (const a of aLines){
    let tokens = [];
    let b;
    // Search another diff line with at least one common token
    while(bLines.length){
      b = bLines.shift();
      const tokenized = [
        tokenize(a.value, true),
        tokenize(b.value, true)
      ];
      if (hasMoreRemovedLines) tokenized.reverse();
      tokens = diff(tokenized[0], tokenized[1]);
      if (tokens.some(({ type, value })=>type === "common" && value.trim().length)) {
        break;
      }
    }
    // Register word-diff details
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}

---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/diff_str.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\nimport type { DiffResult } from \"./types.ts\";\nimport { diff } from \"./diff.ts\";\n\n/**\n * Unescape invisible characters.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences}\n *\n * @param string String to unescape.\n *\n * @returns Unescaped string.\n *\n * @example Usage\n * ```ts\n * import { unescape } from \"@std/internal/diff-str\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(unescape(\"Hello\\nWorld\"), \"Hello\\\\n\\nWorld\");\n * ```\n */\nexport function unescape(string: string): string {\n  return string\n    .replaceAll(\"\\b\", \"\\\\b\")\n    .replaceAll(\"\\f\", \"\\\\f\")\n    .replaceAll(\"\\t\", \"\\\\t\")\n    .replaceAll(\"\\v\", \"\\\\v\")\n    // This does not remove line breaks\n    .replaceAll(\n      /\\r\\n|\\r|\\n/g,\n      (str) => str === \"\\r\" ? \"\\\\r\" : str === \"\\n\" ? \"\\\\n\\n\" : \"\\\\r\\\\n\\r\\n\",\n    );\n}\n\nconst WHITESPACE_SYMBOLS = /([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/;\n\n/**\n * Tokenizes a string into an array of tokens.\n *\n * @param string The string to tokenize.\n * @param wordDiff If true, performs word-based tokenization. Default is false.\n *\n * @returns An array of tokens.\n *\n * @example Usage\n * ```ts\n * import { tokenize } from \"@std/internal/diff-str\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(tokenize(\"Hello\\nWorld\"), [\"Hello\\n\", \"World\"]);\n * ```\n */\nexport function tokenize(string: string, wordDiff = false): string[] {\n  if (wordDiff) {\n    return string\n      .split(WHITESPACE_SYMBOLS)\n      .filter((token) => token);\n  }\n  const tokens: string[] = [];\n  const lines = string.split(/(\\n|\\r\\n)/).filter((line) => line);\n\n  for (const [i, line] of lines.entries()) {\n    if (i % 2) {\n      tokens[tokens.length - 1] += line;\n    } else {\n      tokens.push(line);\n    }\n  }\n  return tokens;\n}\n\n/**\n * Create details by filtering relevant word-diff for current line and merge\n * \"space-diff\" if surrounded by word-diff for cleaner displays.\n *\n * @param line Current line\n * @param tokens Word-diff tokens\n *\n * @returns Array of diff results.\n *\n * @example Usage\n * ```ts\n * import { createDetails } from \"@std/internal/diff-str\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const tokens = [\n *   { type: \"added\", value: \"a\" },\n *   { type: \"removed\", value: \"b\" },\n *   { type: \"common\", value: \"c\" },\n * ] as const;\n * assertEquals(\n *   createDetails({ type: \"added\", value: \"a\" }, [...tokens]),\n *   [{ type: \"added\", value: \"a\" }, { type: \"common\", value: \"c\" }]\n * );\n * ```\n */\nexport function createDetails(\n  line: DiffResult<string>,\n  tokens: DiffResult<string>[],\n): DiffResult<string>[] {\n  return tokens.filter(({ type }) => type === line.type || type === \"common\")\n    .map((result, i, t) => {\n      const token = t[i - 1];\n      if (\n        (result.type === \"common\") && token &&\n        (token.type === t[i + 1]?.type) && /\\s+/.test(result.value)\n      ) {\n        return {\n          ...result,\n          type: token.type,\n        };\n      }\n      return result;\n    });\n}\n\n/**\n * Renders the differences between the actual and expected strings. Partially\n * inspired from {@link https://github.com/kpdecker/jsdiff}.\n *\n * @param A Actual string\n * @param B Expected string\n *\n * @returns Array of diff results.\n *\n * @example Usage\n * ```ts\n * import { diffStr } from \"@std/internal/diff-str\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(diffStr(\"Hello!\", \"Hello\"), [\n *   {\n *     type: \"removed\",\n *     value: \"Hello!\\n\",\n *     details: [\n *       { type: \"common\", value: \"Hello\" },\n *       { type: \"removed\", value: \"!\" },\n *       { type: \"common\", value: \"\\n\" }\n *     ]\n *   },\n *   {\n *     type: \"added\",\n *     value: \"Hello\\n\",\n *     details: [\n *       { type: \"common\", value: \"Hello\" },\n *       { type: \"common\", value: \"\\n\" }\n *     ]\n *   }\n * ]);\n * ```\n */\nexport function diffStr(A: string, B: string): DiffResult<string>[] {\n  // Compute multi-line diff\n  const diffResult = diff(\n    tokenize(`${unescape(A)}\\n`),\n    tokenize(`${unescape(B)}\\n`),\n  );\n\n  const added = [];\n  const removed = [];\n  for (const result of diffResult) {\n    if (result.type === \"added\") {\n      added.push(result);\n    }\n    if (result.type === \"removed\") {\n      removed.push(result);\n    }\n  }\n\n  // Compute word-diff\n  const hasMoreRemovedLines = added.length < removed.length;\n  const aLines = hasMoreRemovedLines ? added : removed;\n  const bLines = hasMoreRemovedLines ? removed : added;\n  for (const a of aLines) {\n    let tokens = [] as Array<DiffResult<string>>;\n    let b: undefined | DiffResult<string>;\n    // Search another diff line with at least one common token\n    while (bLines.length) {\n      b = bLines.shift();\n      const tokenized = [\n        tokenize(a.value, true),\n        tokenize(b!.value, true),\n      ] as [string[], string[]];\n      if (hasMoreRemovedLines) tokenized.reverse();\n      tokens = diff(tokenized[0], tokenized[1]);\n      if (\n        tokens.some(({ type, value }) =>\n          type === \"common\" && value.trim().length\n        )\n      ) {\n        break;\n      }\n    }\n    // Register word-diff details\n    a.details = createDetails(a, tokens);\n    if (b) {\n      b.details = createDetails(b, tokens);\n    }\n  }\n\n  return diffResult;\n}\n"],"names":[],"mappings":"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"}
============
Specifier: https://jsr.io/@std/internal/1.0.1/types.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
/** Ways that lines in a diff can be different. */ 
---
{"version":3,"sources":["https://jsr.io/@std/internal/1.0.1/types.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\n/** Ways that lines in a diff can be different. */\nexport type DiffType = \"removed\" | \"common\" | \"added\";\n\n/**\n * Represents the result of a diff operation.\n *\n * @typeParam T The type of the value in the diff result.\n */\nexport interface DiffResult<T> {\n  /** The type of the diff. */\n  type: DiffType;\n  /** The value of the diff. */\n  value: T;\n  /** The details of the diff. */\n  details?: DiffResult<T>[];\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAE1E,gDAAgD,GAChD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_exists.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that actual is not null or undefined.
 * If not then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertExists } from "@std/assert/assert-exists";
 *
 * assertExists("something"); // Doesn't throw
 * assertExists(undefined); // Throws
 * ```
 *
 * @typeParam T The type of the actual value.
 * @param actual The actual value to check.
 * @param msg The optional message to include in the error if the assertion fails.
 */ export function assertExists(actual, msg) {
  if (actual === undefined || actual === null) {
    const msgSuffix = msg ? `: ${msg}` : ".";
    msg = `Expected actual: "${actual}" to not be null or undefined${msgSuffix}`;
    throw new AssertionError(msg);
  }
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_exists.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that actual is not null or undefined.\n * If not then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertExists } from \"@std/assert/assert-exists\";\n *\n * assertExists(\"something\"); // Doesn't throw\n * assertExists(undefined); // Throws\n * ```\n *\n * @typeParam T The type of the actual value.\n * @param actual The actual value to check.\n * @param msg The optional message to include in the error if the assertion fails.\n */\nexport function assertExists<T>(\n  actual: T,\n  msg?: string,\n): asserts actual is NonNullable<T> {\n  if (actual === undefined || actual === null) {\n    const msgSuffix = msg ? `: ${msg}` : \".\";\n    msg =\n      `Expected actual: \"${actual}\" to not be null or undefined${msgSuffix}`;\n    throw new AssertionError(msg);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,aACd,MAAS,EACT,GAAY;EAEZ,IAAI,WAAW,aAAa,WAAW,MAAM;IAC3C,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;IACrC,MACE,CAAC,kBAAkB,EAAE,OAAO,6BAA6B,EAAE,UAAU,CAAC;IACxE,MAAM,IAAI,eAAe;EAC3B;AACF"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_false.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion, error will be thrown if `expr` have truthy value.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertFalse } from "@std/assert/assert-false";
 *
 * assertFalse(false); // Doesn't throw
 * assertFalse(true); // Throws
 * ```
 *
 * @param expr The expression to test.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertFalse(expr, msg = "") {
  if (expr) {
    throw new AssertionError(msg);
  }
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_false.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/** Assertion condition for {@linkcode assertFalse}. */\nexport type Falsy = false | 0 | 0n | \"\" | null | undefined;\n\n/**\n * Make an assertion, error will be thrown if `expr` have truthy value.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertFalse } from \"@std/assert/assert-false\";\n *\n * assertFalse(false); // Doesn't throw\n * assertFalse(true); // Throws\n * ```\n *\n * @param expr The expression to test.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertFalse(expr: unknown, msg = \"\"): asserts expr is Falsy {\n  if (expr) {\n    throw new AssertionError(msg);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAKtD;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,YAAY,IAAa,EAAE,MAAM,EAAE;EACjD,IAAI,MAAM;IACR,MAAM,IAAI,eAAe;EAC3B;AACF"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_greater_or_equal.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { format } from "jsr:/@std/internal@^1.0.0/format";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` is greater than or equal to `expected`.
 * If not then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertGreaterOrEqual } from "@std/assert/assert-greater-or-equal";
 *
 * assertGreaterOrEqual(2, 1); // Doesn't throw
 * assertGreaterOrEqual(1, 1); // Doesn't throw
 * assertGreaterOrEqual(0, 1); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertGreaterOrEqual(actual, expected, msg) {
  if (actual >= expected) return;
  const actualString = format(actual);
  const expectedString = format(expected);
  throw new AssertionError(msg ?? `Expect ${actualString} >= ${expectedString}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_greater_or_equal.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { format } from \"jsr:/@std/internal@^1.0.0/format\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` is greater than or equal to `expected`.\n * If not then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertGreaterOrEqual } from \"@std/assert/assert-greater-or-equal\";\n *\n * assertGreaterOrEqual(2, 1); // Doesn't throw\n * assertGreaterOrEqual(1, 1); // Doesn't throw\n * assertGreaterOrEqual(0, 1); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertGreaterOrEqual<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  if (actual >= expected) return;\n\n  const actualString = format(actual);\n  const expectedString = format(expected);\n  throw new AssertionError(\n    msg ?? `Expect ${actualString} >= ${expectedString}`,\n  );\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,MAAM,QAAQ,mCAAmC;AAC1D,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,qBACd,MAAS,EACT,QAAW,EACX,GAAY;EAEZ,IAAI,UAAU,UAAU;EAExB,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAC9B,MAAM,IAAI,eACR,OAAO,CAAC,OAAO,EAAE,aAAa,IAAI,EAAE,eAAe,CAAC;AAExD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_greater.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { format } from "jsr:/@std/internal@^1.0.0/format";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` is greater than `expected`.
 * If not then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertGreater } from "@std/assert/assert-greater";
 *
 * assertGreater(2, 1); // Doesn't throw
 * assertGreater(1, 1); // Throws
 * assertGreater(0, 1); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertGreater(actual, expected, msg) {
  if (actual > expected) return;
  const actualString = format(actual);
  const expectedString = format(expected);
  throw new AssertionError(msg ?? `Expect ${actualString} > ${expectedString}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_greater.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { format } from \"jsr:/@std/internal@^1.0.0/format\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` is greater than `expected`.\n * If not then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertGreater } from \"@std/assert/assert-greater\";\n *\n * assertGreater(2, 1); // Doesn't throw\n * assertGreater(1, 1); // Throws\n * assertGreater(0, 1); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertGreater<T>(actual: T, expected: T, msg?: string) {\n  if (actual > expected) return;\n\n  const actualString = format(actual);\n  const expectedString = format(expected);\n  throw new AssertionError(msg ?? `Expect ${actualString} > ${expectedString}`);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,MAAM,QAAQ,mCAAmC;AAC1D,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,cAAiB,MAAS,EAAE,QAAW,EAAE,GAAY;EACnE,IAAI,SAAS,UAAU;EAEvB,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAC9B,MAAM,IAAI,eAAe,OAAO,CAAC,OAAO,EAAE,aAAa,GAAG,EAAE,eAAe,CAAC;AAC9E"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_instance_of.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `obj` is an instance of `type`.
 * If not then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertInstanceOf } from "@std/assert/assert-instance-of";
 *
 * assertInstanceOf(new Date(), Date); // Doesn't throw
 * assertInstanceOf(new Date(), Number); // Throws
 * ```
 *
 * @typeParam T The expected type of the object.
 * @param actual The object to check.
 * @param expectedType The expected class constructor.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertInstanceOf(actual, expectedType, msg = "") {
  if (actual instanceof expectedType) return;
  const msgSuffix = msg ? `: ${msg}` : ".";
  const expectedTypeStr = expectedType.name;
  let actualTypeStr = "";
  if (actual === null) {
    actualTypeStr = "null";
  } else if (actual === undefined) {
    actualTypeStr = "undefined";
  } else if (typeof actual === "object") {
    actualTypeStr = actual.constructor?.name ?? "Object";
  } else {
    actualTypeStr = typeof actual;
  }
  if (expectedTypeStr === actualTypeStr) {
    msg = `Expected object to be an instance of "${expectedTypeStr}"${msgSuffix}`;
  } else if (actualTypeStr === "function") {
    msg = `Expected object to be an instance of "${expectedTypeStr}" but was not an instanced object${msgSuffix}`;
  } else {
    msg = `Expected object to be an instance of "${expectedTypeStr}" but was "${actualTypeStr}"${msgSuffix}`;
  }
  throw new AssertionError(msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_instance_of.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/** Any constructor */\n// deno-lint-ignore no-explicit-any\nexport type AnyConstructor = new (...args: any[]) => any;\n/** Gets constructor type */\nexport type GetConstructorType<T extends AnyConstructor> = T extends // deno-lint-ignore no-explicit-any\nnew (...args: any) => infer C ? C\n  : never;\n\n/**\n * Make an assertion that `obj` is an instance of `type`.\n * If not then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertInstanceOf } from \"@std/assert/assert-instance-of\";\n *\n * assertInstanceOf(new Date(), Date); // Doesn't throw\n * assertInstanceOf(new Date(), Number); // Throws\n * ```\n *\n * @typeParam T The expected type of the object.\n * @param actual The object to check.\n * @param expectedType The expected class constructor.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertInstanceOf<T extends AnyConstructor>(\n  actual: unknown,\n  expectedType: T,\n  msg = \"\",\n): asserts actual is GetConstructorType<T> {\n  if (actual instanceof expectedType) return;\n\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  const expectedTypeStr = expectedType.name;\n\n  let actualTypeStr = \"\";\n  if (actual === null) {\n    actualTypeStr = \"null\";\n  } else if (actual === undefined) {\n    actualTypeStr = \"undefined\";\n  } else if (typeof actual === \"object\") {\n    actualTypeStr = actual.constructor?.name ?? \"Object\";\n  } else {\n    actualTypeStr = typeof actual;\n  }\n\n  if (expectedTypeStr === actualTypeStr) {\n    msg =\n      `Expected object to be an instance of \"${expectedTypeStr}\"${msgSuffix}`;\n  } else if (actualTypeStr === \"function\") {\n    msg =\n      `Expected object to be an instance of \"${expectedTypeStr}\" but was not an instanced object${msgSuffix}`;\n  } else {\n    msg =\n      `Expected object to be an instance of \"${expectedTypeStr}\" but was \"${actualTypeStr}\"${msgSuffix}`;\n  }\n\n  throw new AssertionError(msg);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAUtD;;;;;;;;;;;;;;;;CAgBC,GACD,OAAO,SAAS,iBACd,MAAe,EACf,YAAe,EACf,MAAM,EAAE;EAER,IAAI,kBAAkB,cAAc;EAEpC,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,kBAAkB,aAAa,IAAI;EAEzC,IAAI,gBAAgB;EACpB,IAAI,WAAW,MAAM;IACnB,gBAAgB;EAClB,OAAO,IAAI,WAAW,WAAW;IAC/B,gBAAgB;EAClB,OAAO,IAAI,OAAO,WAAW,UAAU;IACrC,gBAAgB,OAAO,WAAW,EAAE,QAAQ;EAC9C,OAAO;IACL,gBAAgB,OAAO;EACzB;EAEA,IAAI,oBAAoB,eAAe;IACrC,MACE,CAAC,sCAAsC,EAAE,gBAAgB,CAAC,EAAE,UAAU,CAAC;EAC3E,OAAO,IAAI,kBAAkB,YAAY;IACvC,MACE,CAAC,sCAAsC,EAAE,gBAAgB,iCAAiC,EAAE,UAAU,CAAC;EAC3G,OAAO;IACL,MACE,CAAC,sCAAsC,EAAE,gBAAgB,WAAW,EAAE,cAAc,CAAC,EAAE,UAAU,CAAC;EACtG;EAEA,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_is_error.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
import { stripAnsiCode } from "jsr:/@std/internal@^1.0.0/styles";
/**
 * Make an assertion that `error` is an `Error`.
 * If not then an error will be thrown.
 * An error class and a string that should be included in the
 * error message can also be asserted.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertIsError } from "@std/assert/assert-is-error";
 *
 * assertIsError(null); // Throws
 * assertIsError(new RangeError("Out of range")); // Doesn't throw
 * assertIsError(new RangeError("Out of range"), SyntaxError); // Throws
 * assertIsError(new RangeError("Out of range"), SyntaxError, "Out of range"); // Doesn't throw
 * assertIsError(new RangeError("Out of range"), SyntaxError, "Within range"); // Throws
 * ```
 *
 * @typeParam E The type of the error to assert.
 * @param error The error to assert.
 * @param ErrorClass The optional error class to assert.
 * @param msgMatches The optional string or RegExp to assert in the error message.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertIsError(error, // deno-lint-ignore no-explicit-any
ErrorClass, msgMatches, msg) {
  const msgSuffix = msg ? `: ${msg}` : ".";
  if (!(error instanceof Error)) {
    throw new AssertionError(`Expected "error" to be an Error object${msgSuffix}}`);
  }
  if (ErrorClass && !(error instanceof ErrorClass)) {
    msg = `Expected error to be instance of "${ErrorClass.name}", but was "${error?.constructor?.name}"${msgSuffix}`;
    throw new AssertionError(msg);
  }
  let msgCheck;
  if (typeof msgMatches === "string") {
    msgCheck = stripAnsiCode(error.message).includes(stripAnsiCode(msgMatches));
  }
  if (msgMatches instanceof RegExp) {
    msgCheck = msgMatches.test(stripAnsiCode(error.message));
  }
  if (msgMatches && !msgCheck) {
    msg = `Expected error message to include ${msgMatches instanceof RegExp ? msgMatches.toString() : JSON.stringify(msgMatches)}, but got ${JSON.stringify(error?.message)}${msgSuffix}`;
    throw new AssertionError(msg);
  }
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_is_error.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\nimport { stripAnsiCode } from \"jsr:/@std/internal@^1.0.0/styles\";\n\n/**\n * Make an assertion that `error` is an `Error`.\n * If not then an error will be thrown.\n * An error class and a string that should be included in the\n * error message can also be asserted.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertIsError } from \"@std/assert/assert-is-error\";\n *\n * assertIsError(null); // Throws\n * assertIsError(new RangeError(\"Out of range\")); // Doesn't throw\n * assertIsError(new RangeError(\"Out of range\"), SyntaxError); // Throws\n * assertIsError(new RangeError(\"Out of range\"), SyntaxError, \"Out of range\"); // Doesn't throw\n * assertIsError(new RangeError(\"Out of range\"), SyntaxError, \"Within range\"); // Throws\n * ```\n *\n * @typeParam E The type of the error to assert.\n * @param error The error to assert.\n * @param ErrorClass The optional error class to assert.\n * @param msgMatches The optional string or RegExp to assert in the error message.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertIsError<E extends Error = Error>(\n  error: unknown,\n  // deno-lint-ignore no-explicit-any\n  ErrorClass?: new (...args: any[]) => E,\n  msgMatches?: string | RegExp,\n  msg?: string,\n): asserts error is E {\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  if (!(error instanceof Error)) {\n    throw new AssertionError(\n      `Expected \"error\" to be an Error object${msgSuffix}}`,\n    );\n  }\n  if (ErrorClass && !(error instanceof ErrorClass)) {\n    msg =\n      `Expected error to be instance of \"${ErrorClass.name}\", but was \"${error?.constructor?.name}\"${msgSuffix}`;\n    throw new AssertionError(msg);\n  }\n  let msgCheck;\n  if (typeof msgMatches === \"string\") {\n    msgCheck = stripAnsiCode(error.message).includes(\n      stripAnsiCode(msgMatches),\n    );\n  }\n  if (msgMatches instanceof RegExp) {\n    msgCheck = msgMatches.test(stripAnsiCode(error.message));\n  }\n\n  if (msgMatches && !msgCheck) {\n    msg = `Expected error message to include ${\n      msgMatches instanceof RegExp\n        ? msgMatches.toString()\n        : JSON.stringify(msgMatches)\n    }, but got ${JSON.stringify(error?.message)}${msgSuffix}`;\n    throw new AssertionError(msg);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AACtD,SAAS,aAAa,QAAQ,mCAAmC;AAEjE;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,OAAO,SAAS,cACd,KAAc,EACd,mCAAmC;AACnC,UAAsC,EACtC,UAA4B,EAC5B,GAAY;EAEZ,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,IAAI,CAAC,CAAC,iBAAiB,KAAK,GAAG;IAC7B,MAAM,IAAI,eACR,CAAC,sCAAsC,EAAE,UAAU,CAAC,CAAC;EAEzD;EACA,IAAI,cAAc,CAAC,CAAC,iBAAiB,UAAU,GAAG;IAChD,MACE,CAAC,kCAAkC,EAAE,WAAW,IAAI,CAAC,YAAY,EAAE,OAAO,aAAa,KAAK,CAAC,EAAE,UAAU,CAAC;IAC5G,MAAM,IAAI,eAAe;EAC3B;EACA,IAAI;EACJ,IAAI,OAAO,eAAe,UAAU;IAClC,WAAW,cAAc,MAAM,OAAO,EAAE,QAAQ,CAC9C,cAAc;EAElB;EACA,IAAI,sBAAsB,QAAQ;IAChC,WAAW,WAAW,IAAI,CAAC,cAAc,MAAM,OAAO;EACxD;EAEA,IAAI,cAAc,CAAC,UAAU;IAC3B,MAAM,CAAC,kCAAkC,EACvC,sBAAsB,SAClB,WAAW,QAAQ,KACnB,KAAK,SAAS,CAAC,YACpB,UAAU,EAAE,KAAK,SAAS,CAAC,OAAO,SAAS,EAAE,UAAU,CAAC;IACzD,MAAM,IAAI,eAAe;EAC3B;AACF"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_less_or_equal.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { format } from "jsr:/@std/internal@^1.0.0/format";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` is less than or equal to `expected`.
 * If not then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertLessOrEqual } from "@std/assert/assert-less-or-equal";
 *
 * assertLessOrEqual(1, 2); // Doesn't throw
 * assertLessOrEqual(1, 1); // Doesn't throw
 * assertLessOrEqual(1, 0); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertLessOrEqual(actual, expected, msg) {
  if (actual <= expected) return;
  const actualString = format(actual);
  const expectedString = format(expected);
  throw new AssertionError(msg ?? `Expect ${actualString} <= ${expectedString}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_less_or_equal.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { format } from \"jsr:/@std/internal@^1.0.0/format\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` is less than or equal to `expected`.\n * If not then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertLessOrEqual } from \"@std/assert/assert-less-or-equal\";\n *\n * assertLessOrEqual(1, 2); // Doesn't throw\n * assertLessOrEqual(1, 1); // Doesn't throw\n * assertLessOrEqual(1, 0); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertLessOrEqual<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  if (actual <= expected) return;\n\n  const actualString = format(actual);\n  const expectedString = format(expected);\n  throw new AssertionError(\n    msg ?? `Expect ${actualString} <= ${expectedString}`,\n  );\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,MAAM,QAAQ,mCAAmC;AAC1D,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,kBACd,MAAS,EACT,QAAW,EACX,GAAY;EAEZ,IAAI,UAAU,UAAU;EAExB,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAC9B,MAAM,IAAI,eACR,OAAO,CAAC,OAAO,EAAE,aAAa,IAAI,EAAE,eAAe,CAAC;AAExD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_less.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { format } from "jsr:/@std/internal@^1.0.0/format";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` is less than `expected`.
 * If not then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertLess } from "@std/assert/assert-less";
 *
 * assertLess(1, 2); // Doesn't throw
 * assertLess(2, 1); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertLess(actual, expected, msg) {
  if (actual < expected) return;
  const actualString = format(actual);
  const expectedString = format(expected);
  throw new AssertionError(msg ?? `Expect ${actualString} < ${expectedString}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_less.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { format } from \"jsr:/@std/internal@^1.0.0/format\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` is less than `expected`.\n * If not then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertLess } from \"@std/assert/assert-less\";\n *\n * assertLess(1, 2); // Doesn't throw\n * assertLess(2, 1); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertLess<T>(actual: T, expected: T, msg?: string) {\n  if (actual < expected) return;\n\n  const actualString = format(actual);\n  const expectedString = format(expected);\n  throw new AssertionError(msg ?? `Expect ${actualString} < ${expectedString}`);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,MAAM,QAAQ,mCAAmC;AAC1D,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;CAgBC,GACD,OAAO,SAAS,WAAc,MAAS,EAAE,QAAW,EAAE,GAAY;EAChE,IAAI,SAAS,UAAU;EAEvB,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAC9B,MAAM,IAAI,eAAe,OAAO,CAAC,OAAO,EAAE,aAAa,GAAG,EAAE,eAAe,CAAC;AAC9E"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_match.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` match RegExp `expected`. If not
 * then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertMatch } from "@std/assert/assert-match";
 *
 * assertMatch("Raptor", RegExp(/Raptor/)); // Doesn't throw
 * assertMatch("Denosaurus", RegExp(/Raptor/)); // Throws
 * ```
 *
 * @param actual The actual value to be matched.
 * @param expected The expected pattern to match.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertMatch(actual, expected, msg) {
  if (expected.test(actual)) return;
  const msgSuffix = msg ? `: ${msg}` : ".";
  msg = `Expected actual: "${actual}" to match: "${expected}"${msgSuffix}`;
  throw new AssertionError(msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_match.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` match RegExp `expected`. If not\n * then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertMatch } from \"@std/assert/assert-match\";\n *\n * assertMatch(\"Raptor\", RegExp(/Raptor/)); // Doesn't throw\n * assertMatch(\"Denosaurus\", RegExp(/Raptor/)); // Throws\n * ```\n *\n * @param actual The actual value to be matched.\n * @param expected The expected pattern to match.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertMatch(\n  actual: string,\n  expected: RegExp,\n  msg?: string,\n) {\n  if (expected.test(actual)) return;\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  msg = `Expected actual: \"${actual}\" to match: \"${expected}\"${msgSuffix}`;\n  throw new AssertionError(msg);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,YACd,MAAc,EACd,QAAgB,EAChB,GAAY;EAEZ,IAAI,SAAS,IAAI,CAAC,SAAS;EAC3B,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,CAAC,kBAAkB,EAAE,OAAO,aAAa,EAAE,SAAS,CAAC,EAAE,UAAU,CAAC;EACxE,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_equals.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { equal } from "./equal.ts";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` and `expected` are not equal, deeply.
 * If not then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertNotEquals } from "@std/assert/assert-not-equals";
 *
 * assertNotEquals(1, 2); // Doesn't throw
 * assertNotEquals(1, 1); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertNotEquals(actual, expected, msg) {
  if (!equal(actual, expected)) {
    return;
  }
  const actualString = String(actual);
  const expectedString = String(expected);
  const msgSuffix = msg ? `: ${msg}` : ".";
  throw new AssertionError(`Expected actual: ${actualString} not to be: ${expectedString}${msgSuffix}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_equals.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { equal } from \"./equal.ts\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` and `expected` are not equal, deeply.\n * If not then throw.\n *\n * Type parameter can be specified to ensure values under comparison have the same type.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertNotEquals } from \"@std/assert/assert-not-equals\";\n *\n * assertNotEquals(1, 2); // Doesn't throw\n * assertNotEquals(1, 1); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertNotEquals<T>(actual: T, expected: T, msg?: string) {\n  if (!equal(actual, expected)) {\n    return;\n  }\n  const actualString = String(actual);\n  const expectedString = String(expected);\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  throw new AssertionError(\n    `Expected actual: ${actualString} not to be: ${expectedString}${msgSuffix}`,\n  );\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AAErC,SAAS,KAAK,QAAQ,aAAa;AACnC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;;CAkBC,GACD,OAAO,SAAS,gBAAmB,MAAS,EAAE,QAAW,EAAE,GAAY;EACrE,IAAI,CAAC,MAAM,QAAQ,WAAW;IAC5B;EACF;EACA,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAC9B,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,IAAI,eACR,CAAC,iBAAiB,EAAE,aAAa,YAAY,EAAE,eAAe,EAAE,UAAU,CAAC;AAE/E"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_instance_of.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { assertFalse } from "./assert_false.ts";
/**
 * Make an assertion that `obj` is not an instance of `type`.
 * If so, then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertNotInstanceOf } from "@std/assert/assert-not-instance-of";
 *
 * assertNotInstanceOf(new Date(), Number); // Doesn't throw
 * assertNotInstanceOf(new Date(), Date); // Throws
 * ```
 *
 * @typeParam A The type of the object to check.
 * @typeParam T The type of the class to check against.
 * @param actual The object to check.
 * @param unexpectedType The class constructor to check against.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertNotInstanceOf(actual, // deno-lint-ignore no-explicit-any
unexpectedType, msg) {
  const msgSuffix = msg ? `: ${msg}` : ".";
  msg = `Expected object to not be an instance of "${typeof unexpectedType}"${msgSuffix}`;
  assertFalse(actual instanceof unexpectedType, msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_instance_of.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { assertFalse } from \"./assert_false.ts\";\n\n/**\n * Make an assertion that `obj` is not an instance of `type`.\n * If so, then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertNotInstanceOf } from \"@std/assert/assert-not-instance-of\";\n *\n * assertNotInstanceOf(new Date(), Number); // Doesn't throw\n * assertNotInstanceOf(new Date(), Date); // Throws\n * ```\n *\n * @typeParam A The type of the object to check.\n * @typeParam T The type of the class to check against.\n * @param actual The object to check.\n * @param unexpectedType The class constructor to check against.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertNotInstanceOf<A, T>(\n  actual: A,\n  // deno-lint-ignore no-explicit-any\n  unexpectedType: new (...args: any[]) => T,\n  msg?: string,\n): asserts actual is Exclude<A, T> {\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  msg =\n    `Expected object to not be an instance of \"${typeof unexpectedType}\"${msgSuffix}`;\n  assertFalse(actual instanceof unexpectedType, msg);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,WAAW,QAAQ,oBAAoB;AAEhD;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,oBACd,MAAS,EACT,mCAAmC;AACnC,cAAyC,EACzC,GAAY;EAEZ,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MACE,CAAC,0CAA0C,EAAE,OAAO,eAAe,CAAC,EAAE,UAAU,CAAC;EACnF,YAAY,kBAAkB,gBAAgB;AAChD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_match.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` not match RegExp `expected`. If match
 * then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertNotMatch } from "@std/assert/assert-not-match";
 *
 * assertNotMatch("Denosaurus", RegExp(/Raptor/)); // Doesn't throw
 * assertNotMatch("Raptor", RegExp(/Raptor/)); // Throws
 * ```
 *
 * @param actual The actual value to match.
 * @param expected The expected value to not match.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertNotMatch(actual, expected, msg) {
  if (!expected.test(actual)) return;
  const msgSuffix = msg ? `: ${msg}` : ".";
  msg = `Expected actual: "${actual}" to not match: "${expected}"${msgSuffix}`;
  throw new AssertionError(msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_match.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` not match RegExp `expected`. If match\n * then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertNotMatch } from \"@std/assert/assert-not-match\";\n *\n * assertNotMatch(\"Denosaurus\", RegExp(/Raptor/)); // Doesn't throw\n * assertNotMatch(\"Raptor\", RegExp(/Raptor/)); // Throws\n * ```\n *\n * @param actual The actual value to match.\n * @param expected The expected value to not match.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertNotMatch(\n  actual: string,\n  expected: RegExp,\n  msg?: string,\n) {\n  if (!expected.test(actual)) return;\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  msg = `Expected actual: \"${actual}\" to not match: \"${expected}\"${msgSuffix}`;\n  throw new AssertionError(msg);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,eACd,MAAc,EACd,QAAgB,EAChB,GAAY;EAEZ,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS;EAC5B,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,CAAC,kBAAkB,EAAE,OAAO,iBAAiB,EAAE,SAAS,CAAC,EAAE,UAAU,CAAC;EAC5E,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_strict_equals.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
import { format } from "jsr:/@std/internal@^1.0.0/format";
/**
 * Make an assertion that `actual` and `expected` are not strictly equal, using
 * {@linkcode Object.is} for equality comparison. If the values are strictly
 * equal then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertNotStrictEquals } from "@std/assert/assert-not-strict-equals";
 *
 * assertNotStrictEquals(1, 1); // Doesn't throw
 * assertNotStrictEquals(1, 2); // Throws
 * ```
 *
 * @typeParam T The type of the values to compare.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertNotStrictEquals(actual, expected, msg) {
  if (!Object.is(actual, expected)) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  throw new AssertionError(`Expected "actual" to not be strictly equal to: ${format(actual)}${msgSuffix}\n`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_not_strict_equals.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\nimport { format } from \"jsr:/@std/internal@^1.0.0/format\";\n\n/**\n * Make an assertion that `actual` and `expected` are not strictly equal, using\n * {@linkcode Object.is} for equality comparison. If the values are strictly\n * equal then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertNotStrictEquals } from \"@std/assert/assert-not-strict-equals\";\n *\n * assertNotStrictEquals(1, 1); // Doesn't throw\n * assertNotStrictEquals(1, 2); // Throws\n * ```\n *\n * @typeParam T The type of the values to compare.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertNotStrictEquals<T>(\n  actual: T,\n  expected: T,\n  msg?: string,\n) {\n  if (!Object.is(actual, expected)) {\n    return;\n  }\n\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  throw new AssertionError(\n    `Expected \"actual\" to not be strictly equal to: ${\n      format(actual)\n    }${msgSuffix}\\n`,\n  );\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AACtD,SAAS,MAAM,QAAQ,mCAAmC;AAE1D;;;;;;;;;;;;;;;;;CAiBC,GACD,OAAO,SAAS,sBACd,MAAS,EACT,QAAW,EACX,GAAY;EAEZ,IAAI,CAAC,OAAO,EAAE,CAAC,QAAQ,WAAW;IAChC;EACF;EAEA,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,IAAI,eACR,CAAC,+CAA+C,EAC9C,OAAO,QACR,EAAE,UAAU,EAAE,CAAC;AAEpB"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_object_match.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { assertEquals } from "./assert_equals.ts";
/**
 * Make an assertion that `actual` object is a subset of `expected` object,
 * deeply. If not, then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertObjectMatch } from "@std/assert/assert-object-match";
 *
 * assertObjectMatch({ foo: "bar" }, { foo: "bar" }); // Doesn't throw
 * assertObjectMatch({ foo: "bar" }, { foo: "baz" }); // Throws
 * ```
 *
 * @param actual The actual value to be matched.
 * @param expected The expected value to match.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertObjectMatch(// deno-lint-ignore no-explicit-any
actual, expected, msg) {
  function filter(a, b) {
    const seen = new WeakMap();
    return fn(a, b);
    function fn(a, b) {
      // Prevent infinite loop with circular references with same filter
      if (seen.has(a) && seen.get(a) === b) {
        return a;
      }
      try {
        seen.set(a, b);
      } catch (err) {
        if (err instanceof TypeError) {
          throw new TypeError(`Cannot assertObjectMatch ${a === null ? null : `type ${typeof a}`}`);
        }
      }
      // Filter keys and symbols which are present in both actual and expected
      const filtered = {};
      const entries = [
        ...Object.getOwnPropertyNames(a),
        ...Object.getOwnPropertySymbols(a)
      ].filter((key)=>key in b).map((key)=>[
          key,
          a[key]
        ]);
      for (const [key, value] of entries){
        // On array references, build a filtered array and filter nested objects inside
        if (Array.isArray(value)) {
          const subset = b[key];
          if (Array.isArray(subset)) {
            filtered[key] = fn({
              ...value
            }, {
              ...subset
            });
            continue;
          }
        } else if (value instanceof RegExp) {
          filtered[key] = value;
          continue;
        } else if (typeof value === "object" && value !== null) {
          const subset = b[key];
          if (typeof subset === "object" && subset) {
            // When both operands are maps, build a filtered map with common keys and filter nested objects inside
            if (value instanceof Map && subset instanceof Map) {
              filtered[key] = new Map([
                ...value
              ].filter(([k])=>subset.has(k)).map(([k, v])=>[
                  k,
                  typeof v === "object" ? fn(v, subset.get(k)) : v
                ]));
              continue;
            }
            // When both operands are set, build a filtered set with common values
            if (value instanceof Set && subset instanceof Set) {
              filtered[key] = new Set([
                ...value
              ].filter((v)=>subset.has(v)));
              continue;
            }
            filtered[key] = fn(value, subset);
            continue;
          }
        }
        filtered[key] = value;
      }
      return filtered;
    }
  }
  return assertEquals(// get the intersection of "actual" and "expected"
  // side effect: all the instances' constructor field is "Object" now.
  filter(actual, expected), // set (nested) instances' constructor field to be "Object" without changing expected value.
  // see https://github.com/denoland/deno_std/pull/1419
  filter(expected, expected), msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_object_match.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { assertEquals } from \"./assert_equals.ts\";\n\n/**\n * Make an assertion that `actual` object is a subset of `expected` object,\n * deeply. If not, then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertObjectMatch } from \"@std/assert/assert-object-match\";\n *\n * assertObjectMatch({ foo: \"bar\" }, { foo: \"bar\" }); // Doesn't throw\n * assertObjectMatch({ foo: \"bar\" }, { foo: \"baz\" }); // Throws\n * ```\n *\n * @param actual The actual value to be matched.\n * @param expected The expected value to match.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertObjectMatch(\n  // deno-lint-ignore no-explicit-any\n  actual: Record<PropertyKey, any>,\n  expected: Record<PropertyKey, unknown>,\n  msg?: string,\n): void {\n  type loose = Record<PropertyKey, unknown>;\n\n  function filter(a: loose, b: loose) {\n    const seen = new WeakMap();\n    return fn(a, b);\n\n    function fn(a: loose, b: loose): loose {\n      // Prevent infinite loop with circular references with same filter\n      if ((seen.has(a)) && (seen.get(a) === b)) {\n        return a;\n      }\n      try {\n        seen.set(a, b);\n      } catch (err) {\n        if (err instanceof TypeError) {\n          throw new TypeError(\n            `Cannot assertObjectMatch ${\n              a === null ? null : `type ${typeof a}`\n            }`,\n          );\n        }\n      }\n      // Filter keys and symbols which are present in both actual and expected\n      const filtered = {} as loose;\n      const entries = [\n        ...Object.getOwnPropertyNames(a),\n        ...Object.getOwnPropertySymbols(a),\n      ]\n        .filter((key) => key in b)\n        .map((key) => [key, a[key as string]]) as Array<[string, unknown]>;\n      for (const [key, value] of entries) {\n        // On array references, build a filtered array and filter nested objects inside\n        if (Array.isArray(value)) {\n          const subset = (b as loose)[key];\n          if (Array.isArray(subset)) {\n            filtered[key] = fn({ ...value }, { ...subset });\n            continue;\n          }\n        } // On regexp references, keep value as it to avoid loosing pattern and flags\n        else if (value instanceof RegExp) {\n          filtered[key] = value;\n          continue;\n        } // On nested objects references, build a filtered object recursively\n        else if (typeof value === \"object\" && value !== null) {\n          const subset = (b as loose)[key];\n          if ((typeof subset === \"object\") && subset) {\n            // When both operands are maps, build a filtered map with common keys and filter nested objects inside\n            if ((value instanceof Map) && (subset instanceof Map)) {\n              filtered[key] = new Map(\n                [...value].filter(([k]) => subset.has(k)).map((\n                  [k, v],\n                ) => [k, typeof v === \"object\" ? fn(v, subset.get(k)) : v]),\n              );\n              continue;\n            }\n            // When both operands are set, build a filtered set with common values\n            if ((value instanceof Set) && (subset instanceof Set)) {\n              filtered[key] = new Set([...value].filter((v) => subset.has(v)));\n              continue;\n            }\n            filtered[key] = fn(value as loose, subset as loose);\n            continue;\n          }\n        }\n        filtered[key] = value;\n      }\n      return filtered;\n    }\n  }\n  return assertEquals(\n    // get the intersection of \"actual\" and \"expected\"\n    // side effect: all the instances' constructor field is \"Object\" now.\n    filter(actual, expected),\n    // set (nested) instances' constructor field to be \"Object\" without changing expected value.\n    // see https://github.com/denoland/deno_std/pull/1419\n    filter(expected, expected),\n    msg,\n  );\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,YAAY,QAAQ,qBAAqB;AAElD;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,kBACd,mCAAmC;AACnC,MAAgC,EAChC,QAAsC,EACtC,GAAY;EAIZ,SAAS,OAAO,CAAQ,EAAE,CAAQ;IAChC,MAAM,OAAO,IAAI;IACjB,OAAO,GAAG,GAAG;IAEb,SAAS,GAAG,CAAQ,EAAE,CAAQ;MAC5B,kEAAkE;MAClE,IAAI,AAAC,KAAK,GAAG,CAAC,MAAQ,KAAK,GAAG,CAAC,OAAO,GAAI;QACxC,OAAO;MACT;MACA,IAAI;QACF,KAAK,GAAG,CAAC,GAAG;MACd,EAAE,OAAO,KAAK;QACZ,IAAI,eAAe,WAAW;UAC5B,MAAM,IAAI,UACR,CAAC,yBAAyB,EACxB,MAAM,OAAO,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,CACvC,CAAC;QAEN;MACF;MACA,wEAAwE;MACxE,MAAM,WAAW,CAAC;MAClB,MAAM,UAAU;WACX,OAAO,mBAAmB,CAAC;WAC3B,OAAO,qBAAqB,CAAC;OACjC,CACE,MAAM,CAAC,CAAC,MAAQ,OAAO,GACvB,GAAG,CAAC,CAAC,MAAQ;UAAC;UAAK,CAAC,CAAC,IAAc;SAAC;MACvC,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,QAAS;QAClC,+EAA+E;QAC/E,IAAI,MAAM,OAAO,CAAC,QAAQ;UACxB,MAAM,SAAS,AAAC,CAAW,CAAC,IAAI;UAChC,IAAI,MAAM,OAAO,CAAC,SAAS;YACzB,QAAQ,CAAC,IAAI,GAAG,GAAG;cAAE,GAAG,KAAK;YAAC,GAAG;cAAE,GAAG,MAAM;YAAC;YAC7C;UACF;QACF,OACK,IAAI,iBAAiB,QAAQ;UAChC,QAAQ,CAAC,IAAI,GAAG;UAChB;QACF,OACK,IAAI,OAAO,UAAU,YAAY,UAAU,MAAM;UACpD,MAAM,SAAS,AAAC,CAAW,CAAC,IAAI;UAChC,IAAI,AAAC,OAAO,WAAW,YAAa,QAAQ;YAC1C,sGAAsG;YACtG,IAAI,AAAC,iBAAiB,OAAS,kBAAkB,KAAM;cACrD,QAAQ,CAAC,IAAI,GAAG,IAAI,IAClB;mBAAI;eAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,GAAK,OAAO,GAAG,CAAC,IAAI,GAAG,CAAC,CAC5C,CAAC,GAAG,EAAE,GACH;kBAAC;kBAAG,OAAO,MAAM,WAAW,GAAG,GAAG,OAAO,GAAG,CAAC,MAAM;iBAAE;cAE5D;YACF;YACA,sEAAsE;YACtE,IAAI,AAAC,iBAAiB,OAAS,kBAAkB,KAAM;cACrD,QAAQ,CAAC,IAAI,GAAG,IAAI,IAAI;mBAAI;eAAM,CAAC,MAAM,CAAC,CAAC,IAAM,OAAO,GAAG,CAAC;cAC5D;YACF;YACA,QAAQ,CAAC,IAAI,GAAG,GAAG,OAAgB;YACnC;UACF;QACF;QACA,QAAQ,CAAC,IAAI,GAAG;MAClB;MACA,OAAO;IACT;EACF;EACA,OAAO,aACL,kDAAkD;EAClD,qEAAqE;EACrE,OAAO,QAAQ,WACf,4FAA4F;EAC5F,qDAAqD;EACrD,OAAO,UAAU,WACjB;AAEJ"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_rejects.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
import { assertIsError } from "./assert_is_error.ts";
export async function assertRejects(fn, errorClassOrMsg, msgIncludesOrMsg, msg) {
  // deno-lint-ignore no-explicit-any
  let ErrorClass = undefined;
  let msgIncludes = undefined;
  let err;
  if (typeof errorClassOrMsg !== "string") {
    if (errorClassOrMsg === undefined || errorClassOrMsg.prototype instanceof Error || errorClassOrMsg.prototype === Error.prototype) {
      // deno-lint-ignore no-explicit-any
      ErrorClass = errorClassOrMsg;
      msgIncludes = msgIncludesOrMsg;
    }
  } else {
    msg = errorClassOrMsg;
  }
  let doesThrow = false;
  let isPromiseReturned = false;
  const msgSuffix = msg ? `: ${msg}` : ".";
  try {
    const possiblePromise = fn();
    if (possiblePromise && typeof possiblePromise === "object" && typeof possiblePromise.then === "function") {
      isPromiseReturned = true;
      await possiblePromise;
    } else {
      throw Error();
    }
  } catch (error) {
    if (!isPromiseReturned) {
      throw new AssertionError(`Function throws when expected to reject${msgSuffix}`);
    }
    if (ErrorClass) {
      if (!(error instanceof Error)) {
        throw new AssertionError(`A non-Error object was rejected${msgSuffix}`);
      }
      assertIsError(error, ErrorClass, msgIncludes, msg);
    }
    err = error;
    doesThrow = true;
  }
  if (!doesThrow) {
    throw new AssertionError(`Expected function to reject${msgSuffix}`);
  }
  return err;
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_rejects.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\nimport { assertIsError } from \"./assert_is_error.ts\";\n\n/**\n * Executes a function which returns a promise, expecting it to reject.\n *\n * To assert that a synchronous function throws, use {@linkcode assertThrows}.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertRejects } from \"@std/assert/assert-rejects\";\n *\n * await assertRejects(async () => Promise.reject(new Error())); // Doesn't throw\n * await assertRejects(async () => console.log(\"Hello world\")); // Throws\n * ```\n *\n * @param fn The function to execute.\n * @param msg The optional message to display if the assertion fails.\n * @returns The promise which resolves to the thrown error.\n */\nexport function assertRejects(\n  fn: () => PromiseLike<unknown>,\n  msg?: string,\n): Promise<unknown>;\n/**\n * Executes a function which returns a promise, expecting it to reject.\n * If it does not, then it throws. An error class and a string that should be\n * included in the error message can also be asserted.\n *\n * To assert that a synchronous function throws, use {@linkcode assertThrows}.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertRejects } from \"@std/assert/assert-rejects\";\n *\n * await assertRejects(async () => Promise.reject(new Error()), Error); // Doesn't throw\n * await assertRejects(async () => Promise.reject(new Error()), SyntaxError); // Throws\n * ```\n *\n * @typeParam E The error class to assert.\n * @param fn The function to execute.\n * @param ErrorClass The error class to assert.\n * @param msgIncludes The string that should be included in the error message.\n * @param msg The optional message to display if the assertion fails.\n * @returns The promise which resolves to the thrown error.\n */\nexport function assertRejects<E extends Error = Error>(\n  fn: () => PromiseLike<unknown>,\n  // deno-lint-ignore no-explicit-any\n  ErrorClass: new (...args: any[]) => E,\n  msgIncludes?: string,\n  msg?: string,\n): Promise<E>;\nexport async function assertRejects<E extends Error = Error>(\n  fn: () => PromiseLike<unknown>,\n  errorClassOrMsg?:\n    // deno-lint-ignore no-explicit-any\n    | (new (...args: any[]) => E)\n    | string,\n  msgIncludesOrMsg?: string,\n  msg?: string,\n): Promise<E | Error | unknown> {\n  // deno-lint-ignore no-explicit-any\n  let ErrorClass: (new (...args: any[]) => E) | undefined = undefined;\n  let msgIncludes: string | undefined = undefined;\n  let err;\n\n  if (typeof errorClassOrMsg !== \"string\") {\n    if (\n      errorClassOrMsg === undefined ||\n      errorClassOrMsg.prototype instanceof Error ||\n      errorClassOrMsg.prototype === Error.prototype\n    ) {\n      // deno-lint-ignore no-explicit-any\n      ErrorClass = errorClassOrMsg as new (...args: any[]) => E;\n      msgIncludes = msgIncludesOrMsg;\n    }\n  } else {\n    msg = errorClassOrMsg;\n  }\n  let doesThrow = false;\n  let isPromiseReturned = false;\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  try {\n    const possiblePromise = fn();\n    if (\n      possiblePromise &&\n      typeof possiblePromise === \"object\" &&\n      typeof possiblePromise.then === \"function\"\n    ) {\n      isPromiseReturned = true;\n      await possiblePromise;\n    } else {\n      throw Error();\n    }\n  } catch (error) {\n    if (!isPromiseReturned) {\n      throw new AssertionError(\n        `Function throws when expected to reject${msgSuffix}`,\n      );\n    }\n    if (ErrorClass) {\n      if (!(error instanceof Error)) {\n        throw new AssertionError(`A non-Error object was rejected${msgSuffix}`);\n      }\n      assertIsError(\n        error,\n        ErrorClass,\n        msgIncludes,\n        msg,\n      );\n    }\n    err = error;\n    doesThrow = true;\n  }\n  if (!doesThrow) {\n    throw new AssertionError(\n      `Expected function to reject${msgSuffix}`,\n    );\n  }\n  return err;\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AACtD,SAAS,aAAa,QAAQ,uBAAuB;AAoDrD,OAAO,eAAe,cACpB,EAA8B,EAC9B,eAGU,EACV,gBAAyB,EACzB,GAAY;EAEZ,mCAAmC;EACnC,IAAI,aAAsD;EAC1D,IAAI,cAAkC;EACtC,IAAI;EAEJ,IAAI,OAAO,oBAAoB,UAAU;IACvC,IACE,oBAAoB,aACpB,gBAAgB,SAAS,YAAY,SACrC,gBAAgB,SAAS,KAAK,MAAM,SAAS,EAC7C;MACA,mCAAmC;MACnC,aAAa;MACb,cAAc;IAChB;EACF,OAAO;IACL,MAAM;EACR;EACA,IAAI,YAAY;EAChB,IAAI,oBAAoB;EACxB,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,IAAI;IACF,MAAM,kBAAkB;IACxB,IACE,mBACA,OAAO,oBAAoB,YAC3B,OAAO,gBAAgB,IAAI,KAAK,YAChC;MACA,oBAAoB;MACpB,MAAM;IACR,OAAO;MACL,MAAM;IACR;EACF,EAAE,OAAO,OAAO;IACd,IAAI,CAAC,mBAAmB;MACtB,MAAM,IAAI,eACR,CAAC,uCAAuC,EAAE,UAAU,CAAC;IAEzD;IACA,IAAI,YAAY;MACd,IAAI,CAAC,CAAC,iBAAiB,KAAK,GAAG;QAC7B,MAAM,IAAI,eAAe,CAAC,+BAA+B,EAAE,UAAU,CAAC;MACxE;MACA,cACE,OACA,YACA,aACA;IAEJ;IACA,MAAM;IACN,YAAY;EACd;EACA,IAAI,CAAC,WAAW;IACd,MAAM,IAAI,eACR,CAAC,2BAA2B,EAAE,UAAU,CAAC;EAE7C;EACA,OAAO;AACT"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_strict_equals.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { buildMessage, diff, diffStr, format, red } from "jsr:@std/internal@^1.0.0";
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that `actual` and `expected` are strictly equal, using
 * {@linkcode Object.is} for equality comparison. If not, then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertStrictEquals } from "@std/assert/assert-strict-equals";
 *
 * const a = {};
 * const b = a;
 * assertStrictEquals(a, b); // Doesn't throw
 *
 * const c = {};
 * const d = {};
 * assertStrictEquals(c, d); // Throws
 * ```
 *
 * @typeParam T The type of the expected value.
 * @param actual The actual value to compare.
 * @param expected The expected value to compare.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertStrictEquals(actual, expected, msg) {
  if (Object.is(actual, expected)) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  let message;
  const actualString = format(actual);
  const expectedString = format(expected);
  if (actualString === expectedString) {
    const withOffset = actualString.split("\n").map((l)=>`    ${l}`).join("\n");
    message = `Values have the same structure but are not reference-equal${msgSuffix}\n\n${red(withOffset)}\n`;
  } else {
    const stringDiff = typeof actual === "string" && typeof expected === "string";
    const diffResult = stringDiff ? diffStr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
    const diffMsg = buildMessage(diffResult, {
      stringDiff
    }).join("\n");
    message = `Values are not strictly equal${msgSuffix}\n${diffMsg}`;
  }
  throw new AssertionError(message);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_strict_equals.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { buildMessage, diff, diffStr, format, red } from \"jsr:@std/internal@^1.0.0\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that `actual` and `expected` are strictly equal, using\n * {@linkcode Object.is} for equality comparison. If not, then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertStrictEquals } from \"@std/assert/assert-strict-equals\";\n *\n * const a = {};\n * const b = a;\n * assertStrictEquals(a, b); // Doesn't throw\n *\n * const c = {};\n * const d = {};\n * assertStrictEquals(c, d); // Throws\n * ```\n *\n * @typeParam T The type of the expected value.\n * @param actual The actual value to compare.\n * @param expected The expected value to compare.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertStrictEquals<T>(\n  actual: unknown,\n  expected: T,\n  msg?: string,\n): asserts actual is T {\n  if (Object.is(actual, expected)) {\n    return;\n  }\n\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  let message: string;\n\n  const actualString = format(actual);\n  const expectedString = format(expected);\n\n  if (actualString === expectedString) {\n    const withOffset = actualString\n      .split(\"\\n\")\n      .map((l) => `    ${l}`)\n      .join(\"\\n\");\n    message =\n      `Values have the same structure but are not reference-equal${msgSuffix}\\n\\n${\n        red(withOffset)\n      }\\n`;\n  } else {\n    const stringDiff = (typeof actual === \"string\") &&\n      (typeof expected === \"string\");\n    const diffResult = stringDiff\n      ? diffStr(actual as string, expected as string)\n      : diff(actualString.split(\"\\n\"), expectedString.split(\"\\n\"));\n    const diffMsg = buildMessage(diffResult, { stringDiff }).join(\"\\n\");\n    message = `Values are not strictly equal${msgSuffix}\\n${diffMsg}`;\n  }\n\n  throw new AssertionError(message);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,QAAQ,2BAA2B;AACpF,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;;;;;;;CAqBC,GACD,OAAO,SAAS,mBACd,MAAe,EACf,QAAW,EACX,GAAY;EAEZ,IAAI,OAAO,EAAE,CAAC,QAAQ,WAAW;IAC/B;EACF;EAEA,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,IAAI;EAEJ,MAAM,eAAe,OAAO;EAC5B,MAAM,iBAAiB,OAAO;EAE9B,IAAI,iBAAiB,gBAAgB;IACnC,MAAM,aAAa,aAChB,KAAK,CAAC,MACN,GAAG,CAAC,CAAC,IAAM,CAAC,IAAI,EAAE,EAAE,CAAC,EACrB,IAAI,CAAC;IACR,UACE,CAAC,0DAA0D,EAAE,UAAU,IAAI,EACzE,IAAI,YACL,EAAE,CAAC;EACR,OAAO;IACL,MAAM,aAAa,AAAC,OAAO,WAAW,YACnC,OAAO,aAAa;IACvB,MAAM,aAAa,aACf,QAAQ,QAAkB,YAC1B,KAAK,aAAa,KAAK,CAAC,OAAO,eAAe,KAAK,CAAC;IACxD,MAAM,UAAU,aAAa,YAAY;MAAE;IAAW,GAAG,IAAI,CAAC;IAC9D,UAAU,CAAC,6BAA6B,EAAE,UAAU,EAAE,EAAE,QAAQ,CAAC;EACnE;EAEA,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_string_includes.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion that actual includes expected. If not
 * then throw.
 *
 * @example Usage
 * ```ts no-eval
 * import { assertStringIncludes } from "@std/assert/assert-string-includes";
 *
 * assertStringIncludes("Hello", "ello"); // Doesn't throw
 * assertStringIncludes("Hello", "world"); // Throws
 * ```
 *
 * @param actual The actual string to check for inclusion.
 * @param expected The expected string to check for inclusion.
 * @param msg The optional message to display if the assertion fails.
 */ export function assertStringIncludes(actual, expected, msg) {
  if (actual.includes(expected)) return;
  const msgSuffix = msg ? `: ${msg}` : ".";
  msg = `Expected actual: "${actual}" to contain: "${expected}"${msgSuffix}`;
  throw new AssertionError(msg);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_string_includes.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion that actual includes expected. If not\n * then throw.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertStringIncludes } from \"@std/assert/assert-string-includes\";\n *\n * assertStringIncludes(\"Hello\", \"ello\"); // Doesn't throw\n * assertStringIncludes(\"Hello\", \"world\"); // Throws\n * ```\n *\n * @param actual The actual string to check for inclusion.\n * @param expected The expected string to check for inclusion.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assertStringIncludes(\n  actual: string,\n  expected: string,\n  msg?: string,\n) {\n  if (actual.includes(expected)) return;\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  msg = `Expected actual: \"${actual}\" to contain: \"${expected}\"${msgSuffix}`;\n  throw new AssertionError(msg);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;;;CAeC,GACD,OAAO,SAAS,qBACd,MAAc,EACd,QAAgB,EAChB,GAAY;EAEZ,IAAI,OAAO,QAAQ,CAAC,WAAW;EAC/B,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,CAAC,kBAAkB,EAAE,OAAO,eAAe,EAAE,SAAS,CAAC,EAAE,UAAU,CAAC;EAC1E,MAAM,IAAI,eAAe;AAC3B"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert_throws.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { assertIsError } from "./assert_is_error.ts";
import { AssertionError } from "./assertion_error.ts";
export function assertThrows(fn, errorClassOrMsg, msgIncludesOrMsg, msg) {
  // deno-lint-ignore no-explicit-any
  let ErrorClass = undefined;
  let msgIncludes = undefined;
  let err;
  if (typeof errorClassOrMsg !== "string") {
    if (errorClassOrMsg === undefined || errorClassOrMsg?.prototype instanceof Error || errorClassOrMsg?.prototype === Error.prototype) {
      // deno-lint-ignore no-explicit-any
      ErrorClass = errorClassOrMsg;
      msgIncludes = msgIncludesOrMsg;
    } else {
      msg = msgIncludesOrMsg;
    }
  } else {
    msg = errorClassOrMsg;
  }
  let doesThrow = false;
  const msgSuffix = msg ? `: ${msg}` : ".";
  try {
    fn();
  } catch (error) {
    if (ErrorClass) {
      if (error instanceof Error === false) {
        throw new AssertionError(`A non-Error object was thrown${msgSuffix}`);
      }
      assertIsError(error, ErrorClass, msgIncludes, msg);
    }
    err = error;
    doesThrow = true;
  }
  if (!doesThrow) {
    msg = `Expected function to throw${msgSuffix}`;
    throw new AssertionError(msg);
  }
  return err;
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert_throws.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { assertIsError } from \"./assert_is_error.ts\";\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Executes a function, expecting it to throw. If it does not, then it\n * throws.\n *\n * To assert that an asynchronous function rejects, use\n * {@linkcode assertRejects}.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertThrows } from \"@std/assert/assert-throws\";\n *\n * assertThrows(() => { throw new TypeError(\"hello world!\"); }); // Doesn't throw\n * assertThrows(() => console.log(\"hello world!\")); // Throws\n * ```\n *\n * @param fn The function to execute.\n * @param msg The optional message to display if the assertion fails.\n * @returns The error that was thrown.\n */\nexport function assertThrows(\n  fn: () => unknown,\n  msg?: string,\n): unknown;\n/**\n * Executes a function, expecting it to throw. If it does not, then it\n * throws. An error class and a string that should be included in the\n * error message can also be asserted.\n *\n * To assert that an asynchronous function rejects, use\n * {@linkcode assertRejects}.\n *\n * @example Usage\n * ```ts no-eval\n * import { assertThrows } from \"@std/assert/assert-throws\";\n *\n * assertThrows(() => { throw new TypeError(\"hello world!\"); }, TypeError); // Doesn't throw\n * assertThrows(() => { throw new TypeError(\"hello world!\"); }, RangeError); // Throws\n * ```\n *\n * @typeParam E The error class to assert.\n * @param fn The function to execute.\n * @param ErrorClass The error class to assert.\n * @param msgIncludes The string that should be included in the error message.\n * @param msg The optional message to display if the assertion fails.\n * @returns The error that was thrown.\n */\nexport function assertThrows<E extends Error = Error>(\n  fn: () => unknown,\n  // deno-lint-ignore no-explicit-any\n  ErrorClass: new (...args: any[]) => E,\n  msgIncludes?: string,\n  msg?: string,\n): E;\nexport function assertThrows<E extends Error = Error>(\n  fn: () => unknown,\n  errorClassOrMsg?:\n    // deno-lint-ignore no-explicit-any\n    | (new (...args: any[]) => E)\n    | string,\n  msgIncludesOrMsg?: string,\n  msg?: string,\n): E | Error | unknown {\n  // deno-lint-ignore no-explicit-any\n  let ErrorClass: (new (...args: any[]) => E) | undefined = undefined;\n  let msgIncludes: string | undefined = undefined;\n  let err;\n\n  if (typeof errorClassOrMsg !== \"string\") {\n    if (\n      errorClassOrMsg === undefined ||\n      errorClassOrMsg?.prototype instanceof Error ||\n      errorClassOrMsg?.prototype === Error.prototype\n    ) {\n      // deno-lint-ignore no-explicit-any\n      ErrorClass = errorClassOrMsg as new (...args: any[]) => E;\n      msgIncludes = msgIncludesOrMsg;\n    } else {\n      msg = msgIncludesOrMsg;\n    }\n  } else {\n    msg = errorClassOrMsg;\n  }\n  let doesThrow = false;\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  try {\n    fn();\n  } catch (error) {\n    if (ErrorClass) {\n      if (error instanceof Error === false) {\n        throw new AssertionError(`A non-Error object was thrown${msgSuffix}`);\n      }\n      assertIsError(\n        error,\n        ErrorClass,\n        msgIncludes,\n        msg,\n      );\n    }\n    err = error;\n    doesThrow = true;\n  }\n  if (!doesThrow) {\n    msg = `Expected function to throw${msgSuffix}`;\n    throw new AssertionError(msg);\n  }\n  return err;\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,aAAa,QAAQ,uBAAuB;AACrD,SAAS,cAAc,QAAQ,uBAAuB;AAuDtD,OAAO,SAAS,aACd,EAAiB,EACjB,eAGU,EACV,gBAAyB,EACzB,GAAY;EAEZ,mCAAmC;EACnC,IAAI,aAAsD;EAC1D,IAAI,cAAkC;EACtC,IAAI;EAEJ,IAAI,OAAO,oBAAoB,UAAU;IACvC,IACE,oBAAoB,aACpB,iBAAiB,qBAAqB,SACtC,iBAAiB,cAAc,MAAM,SAAS,EAC9C;MACA,mCAAmC;MACnC,aAAa;MACb,cAAc;IAChB,OAAO;MACL,MAAM;IACR;EACF,OAAO;IACL,MAAM;EACR;EACA,IAAI,YAAY;EAChB,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,IAAI;IACF;EACF,EAAE,OAAO,OAAO;IACd,IAAI,YAAY;MACd,IAAI,iBAAiB,UAAU,OAAO;QACpC,MAAM,IAAI,eAAe,CAAC,6BAA6B,EAAE,UAAU,CAAC;MACtE;MACA,cACE,OACA,YACA,aACA;IAEJ;IACA,MAAM;IACN,YAAY;EACd;EACA,IAAI,CAAC,WAAW;IACd,MAAM,CAAC,0BAA0B,EAAE,UAAU,CAAC;IAC9C,MAAM,IAAI,eAAe;EAC3B;EACA,OAAO;AACT"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/assert.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Make an assertion, error will be thrown if `expr` does not have truthy value.
 *
 * @example Usage
 * ```ts no-eval
 * import { assert } from "@std/assert/assert";
 *
 * assert("hello".includes("ello")); // Doesn't throw
 * assert("hello".includes("world")); // Throws
 * ```
 *
 * @param expr The expression to test.
 * @param msg The optional message to display if the assertion fails.
 */ export function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/assert.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Make an assertion, error will be thrown if `expr` does not have truthy value.\n *\n * @example Usage\n * ```ts no-eval\n * import { assert } from \"@std/assert/assert\";\n *\n * assert(\"hello\".includes(\"ello\")); // Doesn't throw\n * assert(\"hello\".includes(\"world\")); // Throws\n * ```\n *\n * @param expr The expression to test.\n * @param msg The optional message to display if the assertion fails.\n */\nexport function assert(expr: unknown, msg = \"\"): asserts expr {\n  if (!expr) {\n    throw new AssertionError(msg);\n  }\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;;CAaC,GACD,OAAO,SAAS,OAAO,IAAa,EAAE,MAAM,EAAE;EAC5C,IAAI,CAAC,MAAM;IACT,MAAM,IAAI,eAAe;EAC3B;AACF"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/fail.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Forcefully throws a failed assertion.
 *
 * @example Usage
 * ```ts no-eval
 * import { fail } from "@std/assert/fail";
 *
 * fail("Deliberately failed!"); // Throws
 * ```
 *
 * @param msg Optional message to include in the error.
 * @returns Never returns, always throws.
 */ export function fail(msg) {
  const msgSuffix = msg ? `: ${msg}` : ".";
  throw new AssertionError(`Failed assertion${msgSuffix}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/fail.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Forcefully throws a failed assertion.\n *\n * @example Usage\n * ```ts no-eval\n * import { fail } from \"@std/assert/fail\";\n *\n * fail(\"Deliberately failed!\"); // Throws\n * ```\n *\n * @param msg Optional message to include in the error.\n * @returns Never returns, always throws.\n */\nexport function fail(msg?: string): never {\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  throw new AssertionError(`Failed assertion${msgSuffix}`);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;CAYC,GACD,OAAO,SAAS,KAAK,GAAY;EAC/B,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,IAAI,eAAe,CAAC,gBAAgB,EAAE,UAAU,CAAC;AACzD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/unimplemented.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Use this to stub out methods that will throw when invoked.
 *
 * @example Usage
 * ```ts no-eval
 * import { unimplemented } from "@std/assert/unimplemented";
 *
 * unimplemented(); // Throws
 * ```
 *
 * @param msg Optional message to include in the error.
 * @returns Never returns, always throws.
 */ export function unimplemented(msg) {
  const msgSuffix = msg ? `: ${msg}` : ".";
  throw new AssertionError(`Unimplemented${msgSuffix}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/unimplemented.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Use this to stub out methods that will throw when invoked.\n *\n * @example Usage\n * ```ts no-eval\n * import { unimplemented } from \"@std/assert/unimplemented\";\n *\n * unimplemented(); // Throws\n * ```\n *\n * @param msg Optional message to include in the error.\n * @returns Never returns, always throws.\n */\nexport function unimplemented(msg?: string): never {\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  throw new AssertionError(`Unimplemented${msgSuffix}`);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;CAYC,GACD,OAAO,SAAS,cAAc,GAAY;EACxC,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,IAAI,eAAe,CAAC,aAAa,EAAE,UAAU,CAAC;AACtD"}
============
Specifier: https://jsr.io/@std/assert/1.0.0-rc.2/unreachable.ts
Kind: JavaScript
---
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { AssertionError } from "./assertion_error.ts";
/**
 * Use this to assert unreachable code.
 *
 * @example Usage
 * ```ts no-eval
 * import { unreachable } from "@std/assert/unreachable";
 *
 * unreachable(); // Throws
 * ```
 *
 * @param msg Optional message to include in the error.
 * @returns Never returns, always throws.
 */ export function unreachable(msg) {
  const msgSuffix = msg ? `: ${msg}` : ".";
  throw new AssertionError(`Unreachable${msgSuffix}`);
}

---
{"version":3,"sources":["https://jsr.io/@std/assert/1.0.0-rc.2/unreachable.ts"],"sourcesContent":["// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport { AssertionError } from \"./assertion_error.ts\";\n\n/**\n * Use this to assert unreachable code.\n *\n * @example Usage\n * ```ts no-eval\n * import { unreachable } from \"@std/assert/unreachable\";\n *\n * unreachable(); // Throws\n * ```\n *\n * @param msg Optional message to include in the error.\n * @returns Never returns, always throws.\n */\nexport function unreachable(msg?: string): never {\n  const msgSuffix = msg ? `: ${msg}` : \".\";\n  throw new AssertionError(`Unreachable${msgSuffix}`);\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,qCAAqC;AACrC,SAAS,cAAc,QAAQ,uBAAuB;AAEtD;;;;;;;;;;;;CAYC,GACD,OAAO,SAAS,YAAY,GAAY;EACtC,MAAM,YAAY,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG;EACrC,MAAM,IAAI,eAAe,CAAC,WAAW,EAAE,UAAU,CAAC;AACpD"}
============
